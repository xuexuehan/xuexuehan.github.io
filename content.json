[{"title":"利用西门子数据集获取函数调用序列","date":"2019-04-08T08:07:10.000Z","path":"2019/04/08/利用西门子数据集获取函数调用序列/","text":"利用pvtrace工具获取测试集 replace 的函数调用关系图 About西门子数据集的目录结构参见此篇博文，本篇博文主要介绍根据需求编写测试脚本，利用pvtrace工具动态的将测试用例传入程序并获取函数调用关系图。由于在西门子的7个子测试集中，replace测试集含有的函数最多，因此本篇博文选用replace测试集作为例子，其他数据集也一样操作。 测试脚本范例理解上篇博文已经介绍replace数据集给我们提供了范例脚本，存储在scripts目录中，该脚本用于运行source.alt / source.orig 目录中被测程序的正确原型，但是研究软件缺陷定位不可能只运行正确的程序，将测试用例动态传入错误版本的程序并分析其运行结果更为重要，下面我们介绍如何利用套件中已经给出的范例脚本修改得到自己需要的运行脚本。 打开scripts目录下的runall.sh脚本，部分截图如下： 可以看出，该脚本的功能： 遍历inputs文件夹下的所有测试用例（replace测试集的inputs文件夹下包含3个子文件夹，里面的测试用例共计5542个）； 将每个测试用例依次传入被测程序中，并指定输出结果存放的路径； 如果想要将该脚本修改为执行错误版本程序的脚本，我们需要修改： 可执行程序的路径； 程序执行结果存放的路径； 手工修改该脚本中5542个路径显然不可行，需要手工编写程序使其自动修改路径，生成新的脚本文件。 在实际情况中，仅仅获取被测程序的运行结果通过与否是不足够的，根据需求还应获取程序执行信息（这里我示范的是获取程序的函数调用关系图）。 我们还需要了解pvtrace工具的使用，这个工具可以获取程序的函数调用关系，通过Graphviz 可以将函数调用关系可视化展示，下面介绍下pvtrace和Graphviz的安装： 安装pvtrace： 12345678#进入fl文件目录下：wget http://www.mtjones.com/developerworks/pvtrace.zip#解压下载包，如果出现命令找不到，需下载压缩工具yum install -y unzip zip 或者 sudo apt-get install zipunzip pvtrace.zipcd pvtracemakesudo make install 安装Graphviz： 1yum install graphviz 这里给出pvtrace和Graphviz的使用介绍链接： http://www.voidcn.com/article/p-xlemghrq-xb.html https://www.ibm.com/developerworks/cn/linux/l-graphvis/ 如果需要获取函数调用关系，为了避免路径出错，我们直接将pvtrace路径下的instrument.c文件拷贝到跟源码文件同级目录下，在GCC编译代码文件时需要加入指定编译选项即可： 1gcc -g -finstrument-functions replace.c instrument.c -o replace.exe 简单获取函数动态调用关系图示例这里先简单介绍下，如何获取函数动态调用关系图： 将pvtrace路径下的instrument.c文件拷贝到source.alt / source.orig目录下，然后将源程序代码replace.c和instrument.c一起编译，命令如下： 12cd source.alt/source.origgcc -g -finstrument-functions replace.c instrument.c -o replace.exe 将scripts目录中的脚本进行修改（命名为runV1.sh），这里示例一个测试用例，后面写代码批量修改路径： 12replace.exe '-?' 'a&amp;' &lt; ../../inputs/temp-test/1.inp.1.1 &gt; ../../outputs/t1pvtrace replace.exe 执行脚本文件： 1source ./runV1.sh source.alt / source.orig目录下生成graph.dot文件，用graphviz将它可视化： 1dot -Tpng graph.dot -o graph.png 执行命令后会报错，打开graph.dot文件将第一行的graph.dot改为graph即可，再执行上面命令； 执行完后，目录下会生成一个graph.png的图，这个图就是程序replace.c在传入t1这个测试用例生成的函数调用关系图： 从上图还可以看到函数之间调用的次数，当然，我们如果需要数据处理的话，利用graph.dot文件就够了，这个文件里包含函数之间调用关系，调用顺序，调用次数，这些信息根据需要自己进行处理； 生成测试脚本下面我参考这篇博文根据范例脚本生成错误版本执行的脚本，脚本生成使用lua语言实现。 首先初始化，指定子套件名称”replace”，测试用例个数5542和错误版本程序个数32； 12345678910SUITE_NAME = \"replace\"CASE_NUM = 5542VERSION_NUM = 32 --should be 32 in replace--VARIABLES--buff = &#123;&#125;i = 0j = 0k = 0line_num = 0tmp = \"\" 接着我们要将范例给的的runall.sh 读入，以便在下一步的文本分析中可以按行进行文本匹配，下面的程序段完成了将范例给出的runall.sh 文本读入，并按行存储至一个缓冲字符串数组buff 中： 12345678--SAVE ORIG SCRIPT INTO BUFFER--file = io.open(\"runall.sh\", \"r\")for line in file:lines() do i = i + 1; buff[i] = lineendline_num = ifile:close() 最后就是将buff 数组中的每一行进行文本匹配，将”/source.alt/source.orig/”字段全部替换为”/../../versions.alt/versions.orig/vX/”(其中”X”为相应的错误版本号)，将”/inputs/”字段全部替换为”/../../inputs/”，将”/outputs/”字段全部替换为”/../../newoutputs/vX”(其中”X”为相应的错误版本号)，其余保持不变，实现代码如下： 12345678910111213141516171819--GENERATE RUN SCRIPT FOR VERSIONS--for i = 1, VERSION_NUM do k = 1 file = io.open(\"run_v\"..i..\".sh\", \"w\") for j = 1, line_num do tmp = buff[j] if string.find(tmp, \"/source.alt/source.orig/\") ~=nil then tmp = string.gsub(tmp,\"/source.alt/source.orig/\", \"/../../versions.alt/versions.orig/v\"..i..\"/\") --modefy paths-- tmp = string.gsub(tmp,\"/inputs/\", \"/../../inputs/\") tmp = string.gsub(tmp,\"/outputs/\", \"/../../newoutputs/v\"..i..\"/\") tmp = tmp..\"\\ncd ../../../versions.alt/versions.orig/v\"..i..\" &amp;&amp; pvtrace replace.exe\" tmp = tmp..\"\\nmv trace.txt ./tra\"..k.. \" &amp;&amp; mv graph.dot ./tra\"..k k = k + 1 end file:write(tmp..\"\\n\") tmp = \"\" end file:close()end 上面这段代码为每次错误版本都生成了一个名为run_vX.sh 的运行脚本，其中X为相应的错误版本号。并且在每个测试用例执行之后，进入错误版本目录下运行命令pvtrace replace.exe，生成函数调用关系trace.txt和graph.dot文件，因为每个测试用例运行生成的dot文件名都是graph、txt文件名都是trace，因此为了避免覆盖需要将各个版本的每个测试用例生成的dot和txt文件移入对应的文件夹（下面需要在每个版本文件夹下建立5542个名为traX的文件夹—X为相对应执行的测试用例）； 123456789101112#下面是用python代码在每个错误版本程序文件夹下生成5542个存放dot和txt的文件夹#make_dir.pyimport osimport shutildir = os.getcwd()for index1 in range(1, 33): if index1 &gt; 0: new_dir = dir + '/v'+ str(index1) for index2 in range(5543): if index2 &gt; 0: os.mkdir(new_dir + '/tra' + str(index2)) pass 执行命令：python make_dir.py即可生成文件夹； 接着在versions.alt/versions.orig目录下建立一个存放shell脚本的文件夹sh，并将范例脚本runall.sh拷贝至sh目录下； 最后我们就可以执行前面的lua程序了，完整代码链接如下： 链接：https://pan.baidu.com/s/1aEO52uidTEVSKNJuzg2_mg 提取码：kqyz 12#运行make_sh.lua程序lua make_sh.lua 运行完后，可以在sh目录下发现生成的错误版本相对应的32个sh脚本，如下图： 批量编译在执行错误版本的测试脚本之前，首先需要对错误版本的代码进行自动批量编译，在这里，我们使用makefile 进行自动编译，makefile的结构如下： 12replace: gcc -g -finstrument-functions replace.c instrument.c -o replace.exe 由于我对makefile还不熟悉，因此采用的笨办法，将这个makefile文件在每个错误版本文件夹下拷贝一份，然后再写代码自动编译（在编译之前需要修改程序源码使其编译通过，修改方式参考这篇博文。","comments":true,"tags":[{"name":"软件缺陷定位","slug":"软件缺陷定位","permalink":"http://yoursite.com/tags/软件缺陷定位/"}]},{"title":"软件缺陷定位西门子数据集介绍","date":"2019-04-08T01:25:03.000Z","path":"2019/04/08/软件缺陷定位西门子数据集介绍/","text":"Siemens suite 的下载及使用详细步骤 AboutSiemens suite是软件缺陷定位领域研究中最常用的测试套件，可从SIR（software infrastructurerepository）下载，这个测试套件被很多有关软件缺陷定位的文献中使用。 Siemens suite下载进入SIR网址，如下图： 此时需要注册经审核后才可以登录下载，点即Get Access进入登录注册界面： 点击Register进入注册界面，注册需要填写自己所在机构或公司（我填的是学校名称），还有关于自己研究方向的简短描述，填完基本信息后，经过审核就可以登录进行下载了。 登录后，可以点击Download Objects进行下载： 这里我把Siemens suite包含的7个测试集都下载好了，链接如下： 链接：https://github.com/xuexuehan/Siemens-suite Siemens suite使用首先看下Siemens suite包含的7个测试集主要信息： Program Description Lines of Code Faulty versions Test cases print_tokens lexical analyzer 565 7 4130 print_tokens2 lexical analyzer 510 10 4115 schedule priority scheduler 412 9 2650 schedule2 priority scheduler 307 10 2710 replace pattern replacement 563 32 5542 tcas altitude separation 173 41 1608 tot_info information measure 406 23 1052 这几个测试集的文件组织结构和使用方法基本雷同，只要掌握一个，其他也是一样的方法。接下来主要以replace测试集为例介绍下该套件的目录组织结构： 首先建立一个存放测试集的文件夹fl，将下载的replace测试集放在fl文件夹下，在此目录下解压： 1tar zxvf replace_2.1.tar.gz 解压完成后，会在解压目录下生成replace文件夹，打开文件夹可以看到其目录组织结构： 在这些目录中，我们需要用到的有inputs、newoutputs、outputs、scripts、source.alt、versions.alt，这里面source和versions文件夹是空的，可以忽略； 先看source.alt / source.orig里面有replace.c这个被测程序的代码文件，在执行测试程序以前，需要将其提前编译为replace.exe 的二进制文件以供测试程序调用。进入source.alt / source.orig目录下，利用Linux平台上 GCC编译器编译被测代码，使用命令： 1gcc -O2 replace.c -o replace.exe 注意：”-O2”中是大写字母”O”而不是数字”0”,表示使用2级优化，而后面的”-o”中是小写字母”o”,表示指定输出文件名。执行命令后可以看到： 可以看到编译器弹出警告，这是由于Siemens Suite 套件中，代码大多完成于90年代，而我们使用的GCC 编译器的版本较新。在此期间，C语言的国际标准发生了很大变化，在replace中，如果想要编译器编译通过，需要修改replace.c代码文件： 主要修改的还是将一些库函数加入到include中，把内置函数和关键字重命名： 首先将 ctype.h 和 stdlib.h 头文件加入到include中； 将函数名为getline的全部替换为get_line（因为getline函数在stdio.h中已经定义，重命名即可）； 将# define NULL 0 修改为 define NUL 0（因为NULL是关键字，提示重复定义）； 此时，修改完毕，再继续编译，即可通过，会在同目录下生成replace.exe； 这里放上我修改后的replace.c代码文件链接： 链接：https://pan.baidu.com/s/1c4mKAcqNegs7kMBa_abVdg 提取码：upkh 在编译其他测试套件代码文件时也会弹出警告，甚至报出错误无法编译，需要按照相应的提示修改代码文件； versions.alt / versions.orig 目录中保存了该被测程序的每个错误版本（在正确的程序之中，随机植入若干错误，产生的错误代码供大家测试），打开versions.alt / versions.orig 目录可以看到replace的32个错误版本文件夹（里面的replace.c里有植入错误，同理按照上面的步骤修改使其编译通过）： 在这32个错误版本中，错误产生的地方在代码文件中有注释标明； inputs / input 目录里保存了所有的测试用例的输入； outputs 目录用于保存被测程序的正确原型（即source.alt / source.orig 目录中的replace.c代码）对于每个测试用例给出的预期输出，在测试含有错误的版本时用于比较相同测试用例得到的执行结果是否相同。在未执行任何测试程序之前，outputs 目录暂时为空； newoutputs 目录用于保存被测程序的每个错误版本对于每个测试用例得到的实际输出，在测试含有错误的版本时用于比较相同测试用例得到的执行结果是否相同。在未执行任何测试程序之前，newoutputs 目录暂时为空； scripts 目录中保存了子测试套件给出的测试脚本范例，打开scripts 目录后可以看到该目录下有一个名为runall.sh 的shell 脚本文件，该脚本文件用于运行source.alt / source.orig目录中被测程序正确原型，将测试用例输入到被测程序正确原型中后，将执行结果输出到replace 中outputs 目录下，按每个测试用例组织文件，runall.sh 中共定义了5542 个测试用例（replace 子套件共有5542 个测试用例），在scripts 目录中输入命令 source ./runall.sh 即可运行该脚本文件，在运行该脚本之前，需要先将source.alt / source.orig 中的replace.c代码文件编译并且修改runall.sh脚本文件replace.exe存放的路径。因为现在新版的套件replace.c程序文件在source.alt / source.orig目录下而非source目录下，将脚本文件中所有的 ../source 替换为 ../source.alt/source.orig； 这里给出我修改后的runall.sh脚本文件链接： 链接：https://pan.baidu.com/s/1efga4E3dI5uh7tk2YFZJWA 提取码：6tan 当运行完runall.sh脚本后，在outputs目录下可以看到这5542个测试用例执行后的结果文件，下图是部分截图： 至此，西门子测试集的子套件目录结构介绍完毕。 参考博文：https://blog.csdn.net/mangoer_ys/article/details/25974067#commentBox （这个博主写的真详细，我基本就是参考这个博文了解的西门子测试集使用方法）","comments":true,"tags":[{"name":"软件缺陷定位","slug":"软件缺陷定位","permalink":"http://yoursite.com/tags/软件缺陷定位/"}]},{"title":"阿里云部署SpringBoot项目","date":"2019-04-07T09:07:25.000Z","path":"2019/04/07/阿里云部署SpringBoot项目/","text":"阿里云部署Spring Boot 项目详细步骤 购买云服务器首先需要在阿里云购买云服务器，进入链接后选择弹性计算，选择所需的类型购买（如果是学生党，完成学生认证后，有学生专享优惠，9.5/月，不能再划算了…），购买完成后，点击控制台就可看到自己购买云服务器的详情； 设置密码，这个密码就是用ssh连接云服务器的密码； 这里我使用了两个软件：SecureCRT（用来连接云服务器） 和 WinSCP（用来从本机给云服务器上传文件）； WinSCP图形化界面如下： 左边面板显示的是本机文件目录，右边是云服务器文件目录；（如果目录不显示压缩包的话，记得在传输选项里的配置里在面板选项去掉“默认目录是主目录”）； 这两个软件下载地址：https://pan.baidu.com/s/1zUnhqBffaqiDG3wYFM6dpg 提取码：1zxb 然后就开始在云服务器上安装配置MySQL和JDK； 安装配置MySQL这里安装配置需要细心，因为有挺多需要修改的配置文件，当然用docker安装配置更加方便，这里用的常规安装配置； 首先将MySQL安装包用WinSCP从本机上传至云服务器； 这里提供我安装MySQL所使用的版本： 链接：https://pan.baidu.com/s/1t8wBXQy89AF-XYxeN3Et1g提取码：az6k 具体安装配置步骤如下面链接文档所示（因为步骤有点多，直接提供文档，步骤很详细）： 链接：https://pan.baidu.com/s/1eLal9b3j5Aca_vcA0VCf0A 提取码：gfxy链接里的配置文档主要操作就是安装MySQ、添加用户组和用户、授权、配置环境变量、修改密码、关闭防火墙…，在修改了配置文件后需要flush privileges，最后就是需要在阿里云添加安全组规则，开放MySQL端口号3306； 安装配置JDK首先将JDK安装包用WinSCP从本机上传至云服务器，我上传到云服务器/opt目录里面； 这里提供我安装JDK所使用的版本： 链接：https://pan.baidu.com/s/1IyQqgMepQj4kQthiE9FITA 提取码：uizg 解压文件： 12cd /opttar -zxvf jdk的文件名 将jdk移动到/home目录：mv jdk1.8.0_171/ /home/ 配置环境变量： vim /etc/profile 在末尾行添加，打开后按 i 编辑, 按 ctrl+c 停止编辑，然后 :wq 保存退出 12export JAVA_HOME=/home/jdk1.8.0_171export PATH=$PATH:$JAVA_HOME/bin: 使更改的配置立即生效：source /etc/profile java -vsion查看JDK版本信息，如果显示出1.8.0证明成功 阿里云发布项目将打包后的项目用WinSCP从本机上传至云服务器，然后向mysql云服务器执行项目sql脚本，在阿里云添加安全组规则，开放端口号8080和80，进入上传项目的目录下执行命令： 12//后台进程执行项目nohup java -jar spring-boot-10-bill-0.0.1-SNAPSHOT.jar --serverport=80 &amp; 停止运行项目： 1234//查看进程ps -ef|grep java//找到项目的进程id，杀死该进程kill -9 进程id 至此，项目部署完毕，可以通过云服务器的ip地址访问项目。当然如果买了域名，挂到云服务器的ip地址下，就可以解析ip，直接通过域名访问。 MySQL中文乱码部署完项目，访问时可能会出现中文乱码问题，首先登录mysql； 12#查看数据库编码：show variables like '%char%'; 如果character_set_database 和 character_set_server显示字符编码为latin1,此时修改mysql配置文件/etc/my.cnf： 123456[mysqld]character-set-server=utf8 [client]default-character-set=utf8 [mysql]default-character-set=utf8 然后再重启，登录mysql，查看字符编码： 1show variables like '%char%'; 出现如上图字符编码为utf-8,则成功。 参考博客链接：https://blog.csdn.net/u012410733/article/details/61619656","comments":true,"tags":[{"name":"Spring-Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot基础总结","date":"2019-04-07T06:53:02.000Z","path":"2019/04/07/Spring-Boot基础总结/","text":"关于Spring Boot一些基础总结 About1、尽快启动和运行，使用“习惯优于配置”（项目中存在大量的配置，而 Spring Boot 内置一个习惯性的配置，让你无须手动进行配置）的理念让项目快速运行起来； 2、Spring Boot 优点 ： 快速构建独立运行的Spring项目； 无须依赖外部Servlet容器，应用无需打成WAR包；项目可以打成jar包独自运行； 提供一系列 starter pom 来简化 Maven 的依赖加载； 大量的自动配置，对主流开发框架的无配置集成； 无须配置XML，开箱即用，简化开发，同时也可以修改默认值来满足特定的需求； Spring Boot 并不是对 Spring 功能上的增强，而是提供了一种快速使用 Spring 的方式； 极大提高了开发、部署效率 ； 入门1、两种启动方式： 直接main； 打成jar包，在dos命令下java -jar 项目名称； 2、Spring Boot底层依赖： 123456789101112131415161718192021222324252627282930 /* spring-boot-starter-parent：是当前项目的父依赖 spring-boot-starter-parent继承spring-boot-dependencies spring-boot-dependencies里面定义了很多组件版本号，我们引用对应依赖时，不需要写&lt;version&gt; */&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; /* spring-boot-starter-web：构建web项目，比如：Tomcat、SpringMVC spring-boot-starter：它是SpringBoot的场景启动器，针对不同场景定义了很多不同的场景启动器 你的项目需要哪些场景启动器，则直接依赖对应的启动器就可以了 */ &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; //将当前项目打成一个jar包运行 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 3、Spring Boot底层源码： 1234567891011121314/** * @SpringBootApplication 用于标识为引导类,说明当前是一个SpringBoot项目 * @SpringBootConfiguration * @Configuration 它属于spring中的一个注解，定义配置类，等价于配置文件 * @Component 添加到spring容器中，表示是一个组件 * @EnableAutoConfiguration * @AutoConfigurationPackage 将引导类所在包及其子包下面所有的组件添加到spring容器中 * @Import(&#123;AutoConfigurationImportSelector.class&#125;) * 1、将所有组件以全类名的方式返回，并且添加到spring容器中 * 2、会给容器中导入非常多的自动配置类（*****AutoiConfiguration），就是导入并配置好很多当 前项目中所需要的组件 * 省去我们手动编写配置然后注入到组件中 * @ComponentScan 被该注解标识的类，会被spring容器进行管理 **/@SpringBootApplication//组合注解 核心配置1、spring boot全局配置： application.properts application.yml 2、YAML： YAML不是一个标记语言； 以数据为中心，配置数据的时候具有面向对象的特征；比json、xml更适合做配置文件； 3、YAML语法格式： YAML基本语法： key: value 表示一对键值对（冒号后面必须有空格）； 使用空格缩进表示层级关系； 左侧缩进的空格数目不重要，只要同一层级的元素左侧对齐即可 ； key 与 value大小写敏感； YMAL常用写法： 字面量： 数值，字符串，布尔，日期； 字符串默认不用加上引号： “ ” 使用双引号会转义特殊字符，特殊字符最终会转成本来想表示含义输出； ‘ ‘ 使用单引号不会转义特殊字符，特殊字符当作一个普通的字符串输出； 对象 &amp; Map ： key: value value存储对象，每个值换一行写，注意值要左对齐； 1234emp: lastName: xiaomeng age: 22 salary: 10000 行内写法： 1emp: &#123;lastName: xiaomeng, age: 22, salary: 10000&#125; 数组（List、Set）： 用 - 值表示数组中的一个元素： 1234fortes: - java - python - hadoop 行内写法： 1fortes: [java, python, hadoop] ​4、YAML全局配置文件注入值： 12345/** ConfigurationProperties: 告诉spring boot将配置文件中的对应属性值，映射到这个组件类中，进行一一绑定* prefix = \"emp\": 配置文件中的前缀名，配置了哪个前缀就会与下面的所有属性进行一一映射* @Component: 将当前组件作为springboot中的一个组件来使用，这样才会纳入容器中管理* */ 5、@Value注解获取注入值： 1234567/** * 类似于spring框架中使用配置文件中的数据注入方式 * &lt;bean class=\"Emp\"&gt; * &lt;property name=\"lastName\" value=\"字面量/#&#123;SpEL&#125; spring表达式/$&#123;key&#125;从配置文件获取\"&gt; &lt;/property&gt; * &lt;/bean&gt; * */ @Value(\"$&#123;emp.last-name&#125;\") 6、比较@Value和@ConfigurationProperties获取值： @ConfigurationProperties @Value 示例 实现功能 批量注入配置文件的属性值 一个一个指定 松散绑定（松散语法） 支持 不支持 last_name == lastNamelast-name == lastName SpEL 不支持 支持 #{10*2} 复杂类型封装 支持 不支持 ${emp.map} JSR303数据校验 支持 不支持 使用场景： 如果只是在某个业务逻辑中需要获取配置文件中的某个属性值，就使用 @Value； 如果专门使用javaBean和配置文件进行映射，就使用 @ConfigurationProperties； 7、加载局部配置文件： 1@PropertySource(value = &#123;\"classpath:emp.properties\"&#125;) 8、加载XML配置文件： 12//用于导入spring的配置文件，并将它加载到容器中@ImportResource(locations = &#123;\"classpath:spring01.xml\"&#125;) 9、自定义配置类： 123456789101112131415/***@Configuration: 它属于spring中的一个注解,用于标识当前类是一个配置类，来表示对应spring配置文件**/@Configurationpublic class EmpConfig &#123; /** * @Bean 标识的方法用于向容器中注入组件 * 1、返回值就是注入容器中组件对象 * 2、方法名就是这个组件的 id 值 * */ @Bean public EmpService empService2() &#123; System.out.println(\"EmpService 组件注入成功\"); return new EmpService(); &#125; 10、多环境项目配置支持： 12345678910111213141516171819//properties#激活profile文件spring.profiles.active=prod//ymlserver: port: 8081 #默认配置的端口号spring: profiles: active: dev #激活哪个profile---server: port: 8082spring: profiles: dev #指定属于哪个环境，dev环境使用---server: port: 8088spring: profiles: prod #指定属于哪个环境，prod环境使用 程序参数、命令行（jar包运行时）：–spring.profiles.active=prod； 虚拟机指定参数：-Dspring.profiles.active=prod； 11、配置文件加载位置： 配置文件位置 说明 file: ./config/ 当前项目的config目录下（最高级别） file: ./ 当前项目的根目录下（第三级别） classpath: /config/ 类路径的config目录下（第二级别） classpath: / 类路径的根目录下（最低级别） 按照优先级从低到高的顺序，将所有位置的配置文件全部加载，高优先级的配置内容会覆盖低优先级的配置内容； 日志配置1、日志框架： 日志抽象层 日志实现 jboss-logging（不适合企业项目开发使用）JCL（Jakarta Commons Logging）—2014年后不再维护SLF4j（Simple Logging Facade for Java）—与log4j、Logback同一个人开发 JUL（java.util.logging）—担心被抢市场，推出的Log4j（存在性能问题）Logback（Log4j同一个人开发的新框架，做了重大升级）Log4j2（apache开发的很强大，借了log4j的名，但当前很多框架未适配上） Spring Boot 采用了 slf4j+logback 的组合形式，Spring Boot也提供对JUL、log4j2、Logback提供了默认配置； 2、log五大日志级别：（由低到高） 12345678910111213//1、下面定义的都是日志级别，由低到高：trace &lt; debug &lt; info &lt; warn &lt; error//2、spring boot默认设定的是 info 级别日志（日志默认级别也称为root级别）//3、可以通过配置文件进行修改 日志级别，设置某一个级别后，就只打印这个级别及后面更高级别的日志信息，没有指定级别的就用springBoot默认规定的级别，root级别//跟踪运行信息logger.trace(\"这是 trace 日志信息\");//调试信息logger.debug(\"这是 debug 日志信息\");//自定义信息logger.info(\"这是 info 日志信息\");//警告信息logger.warn(\"这是 warn 日志信息\");//错误信息logger.error(\"这是 error 日志信息\"); 1234//调整指定包的日志级别logging.level.com.xx=debug//修改springboot的root级别（默认级别）logging.level.root=debug 3、修改日志默认配置： 修改日志文件生成路径： 1234//输出到当前项目根路径下的springboot.log文件中logging.file=springboot.log//输出到当前项目所在磁盘根路径下的/springboot/log目录中的spring.log文件中 E:\\springboot\\log\\spring.loglogging.path=/springboot/log 修改日志输出的格式： 1234567891011/**日志输出格式说明：* %d 输出日期时间，* %thread 输出当前线程名，* %-5level 输出日志级别，左对齐5个字符宽度# %logger&#123;50&#125; 输出全类名最长50个字符，超过按照句点分割# %msg 日志信息# %n 换行符 *///修改控制台输出的日志格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; == [%thread] %-5level %logger&#123;50&#125; - %msg%n//修改文件中输出的日志格式logging.pattern.file=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-5level &gt;&gt;&gt; %logger&#123;50&#125; - %msg%n 4、自定义日志配置： logback.xml ：是直接就被日志框架加载了； logback-spring.xml：配置项不会被日志框架直接加载，而是由 SpringBoot 解析日志配置文件，进而可以使用 SpringBoot 的 Profile 特殊配置 ； 使用日志profile特殊配置，可根据不同的环境激活不同的日志配置： 1234567891011&lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; //根据不同的环境要求进行配置不同的日志信息 &lt;springProfile name=\"dev\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; === [%thread] === %-5level === %logger&#123;50&#125; === %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-5level &gt;&gt;&gt; %logger&#123;50&#125; &gt;&gt;&gt; %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; 5、切换日志框架： 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; //采用log4j2的日志框架 //将spring-boot-starter-logging移除 &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; web开发1、springboot web启动器包括嵌入的Servlet容器和SpringMVC； 2、springboot对静态资源（webjars/静态文件）的映射： 123456789101112public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;if (!this.resourceProperties.isAddMappings()) &#123;logger.debug(\"Default resource handling disabled\");&#125; else &#123;Duration cachePeriod =this.resourceProperties.getCache().getPeriod();CacheControl cacheControl =this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123;//收到 /webjars/**请求后 ，会去classpath:/META-INF/resources/webjars/ 查找资源文件this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;\"/webjars/**\"&#125;).addResourceLocations(new String[]&#123;\"classpath:/METAINF/resources/webjars/\"&#125;).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); 访问 localhost:8080/webjars/jquery/3.3.1/jquery.js 会在下面路径中查找： 123456//引入jquery webjars&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt; 当接受到 /** 请求访问资源时, 会被映射到下面4个 类路径下的静态资源目录中查找 ： 1234classpath:/META-INF/resources/classpath:/resources/classpath:/static/classpath:/public/ 访问 localhost:8080/style.css 会在上面四个静态资源路径中查找文件 ； 3、欢迎页的映射： 会从 4个静态资源目录 + 根路径 / 中 查找 index.html 页面： 12345classpath:/META-INF/resources/classpath:/resources/classpath:/static/classpath:/public//: 当前项目根路径下 会在 静态资源目录下 与 根路径查找 (按该顺序) index.html页面； 收到 “/**” 请求映射； 访问 localhost:8080/ 会在上面5个目录中查找 index.html页面（因为/也属于/**）； 4、项目ico图标的映射： Spring Boot 会在静态资源目录下 与 根路径(按该顺序) 查找 faicon.ico 页面； 如果存在这样的文件，springboot会自动将其设置为应用图标； 5、Thymeleaf模板引擎： 嵌入式tomcat默认不支持jsp； Spring Boot 官方推荐使用 Thymeleaf 作为模板引擎， 因为 Thymeleaf 提供了完美的 SpringMVC 的支持； pom.xml 加入 Thymeleaf 启动器： 12345//thymeleaf 模板启动器&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 模板文件放在哪里 ? DEFAULT_PREFIX = “classpath:/templates/“； 将 HTML 页面放到 classpath:/templates/ 目录下， Thymeleaf 就能自动渲染； 在 html 页面加上以下名称空间, 使用 Thymeleaf 时就有语法提示 ： 1&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt; 6、Thymeleaf语法： 常用属性： 标准表达式语法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273一、Simple expressions（表达式语法） 1. Variable Expressions(变量表达式): $&#123;...&#125; （参考： 4.2 Variables） 1)、获取变量值；使用OGNL表达式； 2）、获取对象的属性, 调用方法 3）、使用内置的基本对象： #ctx : the context object.(当前上下文对象) #vars: the context variables.(当前上下文里的变量) #locale : the context locale. (当前上下文里的区域信息) 下面是Web环境下的隐式对象 #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. 示例: $&#123;session.foo&#125; (用法参考: 18 Appendix A: Expression Basic Objects) 4）、使用内置的工具对象：(用法参考: 19 Appendix B: Expression Utility Objects) #execInfo : information about the template being processed. #messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration) 2. Selection Variable Expressions(选择表达式): *&#123;...&#125; （参考：4.3 Expressions on selections） 1）、和$&#123;&#125;在功能上是一样， 额外新增：配合 th:object 使用 &lt;div th:object=\"$&#123;session.user&#125;\"&gt; 省得每次写$&#123;session.user.firstName&#125;, 直接取出对象，然后写对象名即可 &lt;p&gt;Name: &lt;span th:text=\"*&#123;firstName&#125;\"&gt;Sebastian&lt;/span&gt; &lt;/p&gt; &lt;p&gt;Email: &lt;span th:text=\"*&#123;email&#125;\"&gt;Saturn&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; 3. Message Expressions（获取国际化内容）: #&#123;...&#125; （参考：4.1 Messages） 4. Link URL Expressions（定义URL）: @&#123;...&#125; （参考：4.4 Link URLs） 5. Fragment Expressions（片段引用表达式）: ~&#123;...&#125; （参考：4.5 Fragments） &lt;div th:insert=\"~&#123;commons :: main&#125;\"&gt;...&lt;/div&gt;二、Literals（字面量） （参考： 4.6 Literals） 1. Text literals: 'one text' , 'Another one!' ,… 2. Number literals: 0 , 34 , 3.0 , 12.3 ,… 3. Boolean literals: true , false 4. Null literal: null 5. Literal tokens: one , sometext , main, ... 三、Text operations（文本操作） （参考： 4.7 Appending texts） 1. String concatenation: + 2. Literal substitutions: |The name is $&#123;name&#125;|四、Arithmetic operations（数学运算） （参考： 4.9 Arithmetic operations） 1. Binary operators: + , - , * , / , % 2. Minus sign (unary operator): -五、Boolean operations（布尔运算） 1. Binary operators: and , or 2. Boolean negation (unary operator): ! , not六、Comparisons and equality（比较运算） （参考： 4.10 Comparators and Equality） 1. Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) 2. Equality operators: == , != ( eq , ne )七、Conditional operators(条件表达式;三元运算符) （参考： 4.11 Conditional expressions） 1. If-then: (if) ? (then) 2. If-then-else: (if) ? (then) : (else) 3. Default: (value) ?: (defaultvalue)八、Special tokens（特殊操作） (参考： 4.13 The No-Operation token) 1. No-Operation: - 12345678&lt;!-- th:insert 和 th:replace的区别 th:insert和th:replace都可以引入片段，两者的区别在于 th:insert： 保留引入时使用的标签 th:replace：不保留引入时使用的标签, 将声明片段直接覆盖当前引用标签 --&gt; &lt;div th:replace=\"header :: #header_common_id\" class=\"success\"&gt;&lt;/div&gt; &lt;h2 th:insert=\"header :: #header_common_id\"&gt;&lt;/h2&gt; 17、迭代(th:each)： 12345678910111213141516171819202122 &lt;!--th:each作用在哪个标签上面，对应的就会根据它的值迭代多少次--&gt; &lt;!-- user : 第1个值,代表每次迭代出对象,名字任意取 iterStat : 第2个值,代表每次迭代器内置对象, 名字任意取, 并有如下属性: index : 当前迭代下标 0 开始 count : 当前迭代下标 1 开始 size : 获取总记录数 current : 当前迭代出的对象 even/odd : 当前迭代是偶数还是奇数 (1开始算,返回布尔值) first : 当前是否为第一个元素 last : 当前是否为最后一个元素 --&gt; &lt;tr th:each=\"user, iterStat: $&#123;userList&#125;\"&gt; &lt;td th:text=\"$&#123;iterStat.count&#125;\"&gt;000&lt;/td&gt; &lt;td th:text=\"$&#123;user.username&#125;\"&gt;xxx&lt;/td&gt; &lt;td th:text=\"$&#123;user.gender == 1 ? '男' : '女'&#125;\"&gt;1&lt;/td&gt; &lt;td th:text=\"$&#123;iterStat.size&#125;\"&gt;xxx&lt;/td&gt; &lt;td th:text=\"$&#123;iterStat.even&#125;? '偶数' : '奇数'\"&gt;xxx&lt;/td&gt; &lt;td th:text=\"$&#123;iterStat.first&#125;\"&gt;xxx&lt;/td&gt; &lt;td th:text=\"$&#123;iterStat.last&#125;\"&gt;xxx&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 8、条件判断： 1234567&lt;h3 th:if=\"not $&#123;#lists.isEmpty(userList)&#125;\"&gt;显示出来则userList集合不为空&lt;/h3&gt;&lt;h3 th:unless=\"$&#123;#lists.isEmpty(userList)&#125;\"&gt;显示出来则userList集合不为空&lt;/h3&gt;&lt;div th:switch=\"$&#123;sex&#125;\"&gt; &lt;p th:case=\"$&#123;man&#125;\"&gt;男&lt;/p&gt; &lt;p th:case=\"2\"&gt;女&lt;/p&gt; &lt;p th:case=\"*\"&gt;未知&lt;/p&gt;&lt;/div&gt; 9、显示标签体内容： 1234&lt;!--不转义字符--&gt;&lt;div th:text=\"$&#123;desc&#125;\"&gt;&lt;/div&gt;&lt;!--转义字符--&gt;&lt;div th:utext=\"$&#123;desc&#125;\"&gt;&lt;/div&gt; 显示对象： 12345&lt;div th:object=\"$&#123;session.user&#125;\"&gt; &lt;!--上面已经将对象获取出来，下面直接写属性值即可获取到值--&gt; &lt;p&gt;姓名：&lt;span th:text=\"*&#123;username&#125;\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;性别：&lt;span th:text=\"*&#123;gender&#125; == 1 ? '男' : '女'\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt; 10、springboot热部署： 12345678//开发环境建议关闭thymeleaf缓存spring.thymeleaf.cache=false//热部署依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;//Ctrl + F9 编译 11、扩展springmvc功能： 1234567891011121314151617/** * 1、创建一个WebMvcConfigurer类型的子类 * 2、类上用@Configuration标识它是一个配置类 * 3、不能@EnableWebMvc标识 * 原理： * 1、@Import(&#123;WebMvcAutoConfiguration.EnableWebMvcConfiguration.class&#125;) * 2、public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration * */@Configurationpublic class MySpringConfigurer implements WebMvcConfigurer &#123; //增加视图控制 @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //发送 /xuexue 请求来到 success.html registry.addViewController(\"/xuexue\").setViewName(\"success\"); &#125;&#125; 12、全面控制springmvc： 在自定义的Web配置类上添加 @Configuration 和 @EnableWebMvc 注解； 总结SpringMVC 配置： 在Spring Boot中自已配置组件的时候，先看容器中有没有公司自已配置的（@Bean、@Component）,如果 有就用公司自已配置的; 如果没有，才自动配置； 在Spring Boot中会有非常多的xxxConfigurer帮助我们进行扩展配置； 在Spring Boot中会有很多的xxxCustomizer帮助我们进行定制配置； Spring Boot Restful架构Restful架构：通过HTTP请求方式区别对资源CRUD操作，请求URI是/资源名称/资源标识； 普通CRUD RestfulCRUD 查询 getPrvider provider —GET 添加 addProvider?xxx provider —POST 修改 updateProvider?id=xxx provider /{id} —PUT 删除 deleteProvider?id=1 provider /{id} —DELETE springboot错误处理机制1、几种常见错误（状态码）： 浏览器发送一个不存在的请求时，会报404； 500； 2、timestamp：时间戳， status：状态码， error：错误提示， exception：异常对象， message：异常消息， errors：JSR303数据校验出现的错误； 嵌入式Sevlet容器自定义配置1、注册Servlet三大组件 Servlet/Filter/Listener： ServletRegistrationBean ：注册自定义Servlet ； FilterRegistrationBean：注册自定义Filter； ServletListenerRegistrarionBean：注册自定义Listener； 2、修改嵌入式servlet 容器配置： 123456//修改服务相关的配置server.port=8081//修改关于servlet的相关配置server.servlet.context-path=/servlet//修改tomcat相关配置server.tomcat.max-connections=8000 3、自定义定制器修改嵌入式servlet容器配置： 12345678910111213@Beanpublic WebServerFactoryCustomizer webServerFactoryCustomizer() &#123; return new WebServerFactoryCustomizer() &#123; @Override public void customize(WebServerFactory factory) &#123; ConfigurableServletWebServerFactory factory1 = (ConfigurableServletWebServerFactory)factory; //修改端口号，如果配置文件中与定制器中的配置冲突，默认采用定制器的配置 factory1.setPort(8082); factory1.setContextPath(\"/servlet2\"); &#125; &#125;;&#125; 事务管理123//默认创建表类型是MyISAM，是非事务安全的，所以无法实现事物回滚//指定如下方言: 创建的表类型是Innodb，才可以进行对事物的回滚database-platform: org.hibernate.dialect.MySQL57Dialect 事务管理步骤： 在启动类上 ，使用 @EnableTransactionManagement 开启注解方式事务支持； 在 Service层方法上添加 @Transactional 进行事务管理； 定时任务使用的注解： @EnableScheduling 启动类上开启基于注解的定时任务 ； @Scheduled 标识的方法会进行定时处理 ； 需要通过 cron 属性来指定 cron 表达式： 秒 分 时 日 月 星期几； 在线cron表达式生成器：http://cron.qqe2.com/ 附windows环境下Redis软件下载： https://pan.baidu.com/s/1TPsFnoVJ3e0UhUR5y4K2sw 提取码：qa25 Spring Boot参考文档： https://pan.baidu.com/s/1ai0azTuXtwGSOKEbefIOHw 提取码：hqlv Thymeleaf模板引擎参考文档： https://pan.baidu.com/s/1wymLJ8gbWzzWQG1SRH3NQw 提取码：j5pp ​","comments":true,"tags":[{"name":"Spring-Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"SQL必知必会","date":"2019-04-07T06:22:36.000Z","path":"2019/04/07/SQL必知必会/","text":"SQL必知必会总结 About1、数据库是一个以某种有组织的方式存储的数据集合；表是一种结构化的文件，可用来存储某种特定类型的数据；模式 ：关于数据库和表的布局及特性的信息 ； 2、主键（primary key）：一列（或一组列），其值能够唯一标识表中每一行 ； 任意两行都不具有相同的主键值 ； 每一行都必须具有一个主键值（主键列不允许NULL值）； 主键列中的值不允许修改或更新； 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）； ​ 主键通常定义在表的一列上，但并不是必需这么做，也可以一起使用多个列作为主键。在使用多列作为主键时，上述条件必须应用到所有列， 所有列值的组合必须是唯一的（但单个列的值可以不唯一）； 3、SQL是结构化查询语言（Structured Query Language）的缩写，SQL是一种专门用来与数据库沟通的语言； 检索数据1、SQL语句不区分大小写 ； 检索单个列 SELECT prod_name FROM Products; 检索多个列 SELECT prod_id, prod_name, prod_price FROM Products; 检索所有列 SELECT * FROM Products; 检索不同的值 （ DISTINCT） SELECT DISTINCT vend_id FROM Products; 限制结果（LIMIT） SELECT prod_name FROM Products LIMIT 5; LIMIT 5 OFFSET 5 SELECT prod_name FROM Products LIMIT 5 OFFSET 5; 2、总结： 一般而言，除非你确实需要表中的每一列，否则最好别使用*通配符。虽然使用通配符能让你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能； 不能部分使用DISTINCT ：DISTINCT关键字作用于所有的列，不仅仅是跟在其后的那一列； LIMIT 5指示MySQL等DBMS返回不超过5行的数据，LIMIT 5 OFFSET 5 （LIMIT 5, 5）指示MySQL等DBMS返回从第5行起的5行数据。第一个数字是指从哪儿开始，第二个数字是检索的行数。第一个被检索的行是第0行，而不是第1行 ； 排序检索数据1、ORDER BY子句，根据需要排序检索出的数据； 排序数据 SELECT prod_name FROM Products ORDER BY prod_name; 按多个列排序 SELECT prod_id, prod_price, prod_name FROM Products ORDER BY prod_price, prod_name; 按列位置排序 SELECT prod_id, prod_price, prod_name FROM Products ORDER BY 2, 3; 指定排序方向 SELECT prod_id, prod_price, prod_name FROM Products ORDER BY prod_price DESC; 2、总结： ORDER BY子句的位置 ：在指定一条ORDER BY子句时，应该保证它是SELECT语句中最后一条子句。如果它不是最后的子句，将会出现错误消息； 通过非选择列进行排序： 通常，ORDER BY子句中使用的列将是为显示而选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的； 按列位置排序：指定的是选择列的相对位置而不是列名 ； 数据排序不限于升序排序（从A到Z），这只是默认的排序顺序。还可以使用ORDER BY子句进行降序（从Z到A）排序。为了进行降序排序，必须指定DESC关键字； 在多个列上降序排序： 如果想在多个列上进行降序排序，必须对每一列指定DESC关键字；（DESC是DESCENDING的缩写，与DESC相对的是ASC（或ASCENDING），升序是默认的 ）； 过滤数据1、WHERE子句指定搜索条件 ； 检查单个值 SELECT prod_name, prod_price FROM Products WHERE prod_price = 3.49; 检查单个值 SELECT prod_name, prod_price FROM Products WHERE prod_price &lt; 10; 不匹配检查 SELECT vend_id, prod_name FROM Products WHERE vend_id ！= ‘DLL01’; 范围值检查 SELECT prod_name, prod_price FROM Products WHERE prod_price BETWEEN 5 AND 10; 空值检查 SELECT prod_name FROM Products WHERE prod_price IS NULL; 2、总结： WHERE子句的位置 ：在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后，否则将会产生错误； 在使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用AND关键字分隔。BETWEEN匹配范围 中所有的值，包括指定的开始值和结束值； NULL和非匹配 ：通过过滤选择不包含指定值的所有行时，你可能希望返回含NULL值的行。但是这做不到。因为未知（unknown）有特殊的含义，数据库不知道它们是否匹配，所以在进行匹配过滤或非匹配过滤时，不会返回这些结果； 高级数据过滤1、为了进行更强的过滤控制，SQL允许给出多个WHERE子句。这些子句有两种使用方式，即以AND子句或OR子句的方式使用 ； 2、求值顺序 ： SQL（像多数语言一样）在处理OR操作符前，优先处理AND操作符。在WHERE子句中使用圆括号 ：任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符 ； 3、IN操作符 ：用来指定条件范围，范围中的每个条件都可以进行匹配。IN取一组由逗号分隔、括在圆括号中的合法值； 12345SELECT prod_name, prod_priceFROM ProductsWHERE vend_id IN ( &apos;DLL01&apos;, &apos;BRS01&apos; )ORDER BY prod_name;#IN操作符完成了与OR相同的功能 IN操作符优点为 ： 在有很多合法选项时，IN操作符的语法更清楚，更直观 ； 在与其他AND和OR操作符组合使用IN时，求值顺序更容易管理； IN操作符一般比一组OR操作符执行得更快； IN的最大优点是可以包含其他SELECT语句，能够更动态地建立WHERE子句； 4、NOT操作符：否定其后所跟的任何条件； 1234SELECT prod_nameFROM ProductsWHERE NOT vend_id = &apos;DLL01&apos;ORDER BY prod_name; 用通配符进行过滤1、LIKE操作符 ：为在搜索子句中使用通配符，必须使用LIKE操作符（后跟的搜索模式利用通配符匹配而不是简单的相等匹配进行比较 ） ；利用通配符，可以创建比较特定数据的搜索模式； 通配符搜索只能用于文本字段（串），非文本数据类型字段不能使用通配符搜索； 百分号（%）通配符 ：%表示任何字符出现任意次数； 除了能匹配一个或多个字符外，%还能匹配0个字符。%代表搜索模式中给定位置的0个、1个或多个字符。 注意NULL ：通配符%看起来像是可以匹配任何东西，但有个例外，这就是NULL； 123SELECT prod_id, prod_nameFROM ProductsWHERE prod_name LIKE &apos;Fish%&apos;; 下划线（_）通配符：只匹配单个字符，而不是多个字符； 通配符搜索一般比前面讨论的其他搜索要耗费更长的处理时间 ； —不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符； —在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的； —仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据； 创建计算字段1、计算字段：计算字段并不实际存在于数据库表中，计算字段是运行时在SELECT语句内创建的； 2、拼接字段 ： 拼接（concatenate）：将值联结到一起（将一个值附加到另一个值）构成单个值—cncat()； 123SELECT CONCAT(TRIM(vend_name),&apos; (&apos;,TRIM(vend_country),&apos;)&apos;)#TRIM()---去掉左右两边空格FROM VendorsORDER BY vend_name; 别名（alias）是一个字段或值的替换名。别名用AS关键字赋予； 12345SELECT CONCAT(TRIM(vend_name),&apos; (&apos;,TRIM(vend_country),&apos;)&apos;)AS vend_titleFROM VendorsORDER BY vend_name; #计算字段之后跟了文本AS vend_title，它指示SQL创建一个包含指定计算结果的名为vend_title的计算字段，现在列名为vend_title，任何客户端应用都可以按名称引用这个列，就像它是一个实际的表列一样。 AS通常可选：AS关键字是可选的，不过最好使用它，这被视为一条最佳实践 ； 别名的其他用途：常见的用途包括在实际的表列名包含不合法的字符（如空格）时重新命名它，在原来的名字含混或容易误解时扩充它； 3、执行算术计算：计算字段的另一常见用途是对检索出的数据进行算术计算； 123SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_priceFROM OrderItemsWHERE order_num = 20008; 使用数据处理函数1、SQL也可以用函数来处理数据。函数一般是在数据上执行的，为数据的转换和处理提供了方便； 2、大多数SQL实现支持以下类型的函数： 用于处理文本字符串（如删除或填充值，转换值为大写或小写）的文本函数； 用于在数值数据上进行算术操作（如返回绝对值，进行代数运算）的数值函数； 用于处理日期和时间值并从这些值中提取特定成分（如返回两个日期之差，检查日期有效性）的日期和时间函数； 返回DBMS正使用的特殊信息（如返回用户登录信息）的系统函数； 文本处理函数 SELECT vend_name, UPPER(vend_name) AS vend_name_upcase 日期和时间处理函数 SELECT order_num FROM Orders WHERE YEAR(order_date) = 2012; 数值处理函数 SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法，SOUNDEX考虑了类似的发音字符和音节，使得能对字符串进行发音比较而不是字母比较 ； 123SELECT cust_name, cust_contactFROM CustomersWHERE SOUNDEX(cust_contact) = SOUNDEX(&apos;Michael Green&apos;) 汇总数据1、聚集函数：汇总数据而不用把它们实际检索出来，为此SQL提供了专门的函数。使用这些函数，SQL查询可用于检索数据，以便分析和报表生成； 聚集函数（aggregate function） 对某些行运行的函数，计算并返回一个值 ； AVG（）：返回某列的平均值—通过对表中行数计数并计算其列值之和，求得该列的平均值； 只用于单个列：AVG()只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个AVG()函数。 12SELECT AVG(prod_price) AS avg_priceFROM Products; COUNT（）：确定表中行的数目或符合特定条件的行的数目； COUNT()函数有两种使用方式： 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值； 使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值； 123456#利用COUNT(*)对所有行计数，不管行中各列有什么值SELECT COUNT(*) AS num_custFROM Customers;#COUNT(cust_email)对cust_email列中有值的行进行计数SELECT COUNT(cust_email) AS num_custFROM Customers; MAX（）：返回某列的最大值，要求指定列名 ； 123#MAX()函数忽略列值为NULL的行SELECT MAX(prod_price) AS max_priceFROM Products; MIN（）：返回某列的最小值，要求指定列名 ； 123#MIN()函数忽略列值为NULL的行SELECT MIN(prod_price) AS min_priceFROM Products; SUM（）：返回指定列值的和（总计）； 12345678#SUM()函数忽略列值为NULL的行SELECT SUM(quantity) AS items_orderedFROM OrderItemsWHERE order_num = 20005;#SUM()也可以用来合计计算值SELECT SUM(item_price*quantity) AS total_priceFROM OrderItemsWHERE order_num = 20005; 2、聚集不同值：只包含不同的值，指定DISTINCT参数； 1234SELECT AVG(DISTINCT prod_price) AS avg_priceFROM ProductsWHERE vend_id = &apos;DLL01&apos;;#DISTINCT不能用于COUNT(*)，DISTINCT必须使用列名 3、组合聚集函数： 12345SELECT COUNT(*) AS num_items,MIN(prod_price) AS price_min,MAX(prod_price) AS price_max,AVG(prod_price) AS price_avgFROM Products; 分组数据1、数据分组 ：使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算； 2、创建分组：使用SELECT语句的GROUP BY子句建立的； 123SELECT vend_id, COUNT(*) AS num_prodsFROM ProductsGROUP BY vend_id; GROUP BY子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组； 如果在GROUP BY子句中嵌套了分组，数据将在最后指定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）； GROUP BY子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子 句中指定相同的表达式。不能使用别名； 大多数SQL实现不允许GROUP BY列带有长度可变的数据类型（如文本或备注型字段）； 除聚集计算语句外，SELECT语句中的每一列都必须在GROUP BY子句中给出 ； 如果分组列中包含具有NULL值的行，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组； GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前 ； 3、过滤分组 ：HAVING子句 ，WHERE过滤行，而HAVING过滤分组； 1234SELECT cust_id, COUNT(*) AS ordersFROM OrdersGROUP BY cust_idHAVING COUNT(*) &gt;= 2; HAVING和WHERE的差别：WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤； 123456#第一行是使用了聚集函数的基本SELECT语句，WHERE子句过滤所有prod_price至少为4的行，然后按vend_id分组数据，HAVING子句过滤计数为2或2以上的分组。SELECT vend_id, COUNT(*) AS num_prodFROM ProductsWHERE prod_price &gt;= 4GROUP BY vend_idHAVING COUNT(*) &gt;= 2 使用HAVING和WHERE：HAVING与WHERE非常类似，如果不指定GROUP BY，则大多数DBMS会同等对待它们。不过，使用HAVING时应该结合GROUP BY子句，而WHERE子句用于标准的行级过滤； 4、分组和排序：GROUP BY和ORDER BY经常完成相同的工作，但它们非常不同； ORDER BY GROUP BY 对产生的输出排序 对行分组，但输出可能不是分组的顺序 任意列都可以使用（甚至非选择的列也可以使用） 只可能使用选择列u表达式列，而且必须使用每个选择列表达式 不一定需要 如果与聚集函数一起使用列（或表达式），则必须使用 不要忘记ORDER BY：一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据； 12345SELECT order_num, COUNT(*) AS itemsFROM OrderItemsGROUP BY order_numHAVING COUNT(*) &gt;= 3ORDER BY items, order_num; 5、SELECT子句顺序： 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BYYYYYYYYYYYYYYYYY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 使用子查询1、子查询：嵌套在其他查询中的查询； 2、利用子查询进行过滤： 1234567SELECT cust_name, cust_contactFROM CustomersWHERE cust_id IN (SELECT cust_idFROM OrdersWHERE order_num IN (SELECT order_numFROM OrderItemsWHERE prod_id = &apos;RGAN01&apos;)); 在WHERE子句中使用子查询能够编写出功能很强且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多的子查询； 只能是单列：作为子查询的SELECT语句只能查询单个列。企图检索多个列将返回错误； 子查询和性能：这里给出的代码有效，并且获得了所需的结果。但是，使用子查询并不总是执行这类数据检索的最有效方法； 3、作为计算字段使用子查询：使用子查询的另一方法是创建计算字段； 12345678#不是解决这种数据检索的最有效方法SELECT cust_name,cust_state,(SELECT COUNT(*)FROM OrdersWHERE Orders.cust_id = Customers.cust_id) AS ordersFROM CustomersORDER BY cust_name; 联结表1、联结：SQL最强大的功能之一就是能在数据查询的执行中联结（join）表。联结是利用SQL的SELECT能执行的最重要的操作； 关系表：相同的数据出现多次决不是一件好事，这是关系数据库设计的基础。关系表的设计就是要把信息分解成多个表，一类数据一个表。各表通过某些共同的值互相关联（所以才叫关系数据库）； 关系数据可以有效地存储，方便地处理。因此，关系数据库的可伸缩性远比非关系数据库要好。可伸缩（scale）： 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称为可伸缩性好（scale well）； 如果数据存储在多个表中，怎样用一条SELECT语句就检索出数据呢？（使用联结）； 联结是一种机制，用来在一条SELECT语句中关联表，因此称为联结。使用特殊的语法，可以联结多个表返回一组输 出，联结在运行时关联表中正确的行 ； 2、创建联结：指定要联结的所有表以及关联它们的方式即可 ； 123SELECT vend_name, prod_name, prod_priceFROM Vendors, ProductsWHERE Vendors.vend_id = Products.vend_id; 3、WHERE子句的重要性：在联结两个表时，实际要做的是将第一 个表中的每一行与第二个表中的每一行配对。WHERE子句作为过滤条件，只包含那些匹配给定条件（这里是联结条件）的行。没有WHERE子句， 第一个表中的每一行将与第二个表中的每一行配对，而不管它们逻辑上是否能配在一起； 笛卡儿积（cartesian product）：由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数； 123SELECT vend_name, prod_name, prod_priceFROM Vendors, Products;#要保证所有联结都有WHERE子句，否则DBMS将返回比想要的数据多得多的数据 内联结（inner join）：目前为止使用的联结称为等值联结（equijoin），它基于两个表之间的相等测试，这种联结也称为内联结； 123SELECT vend_name, prod_name, prod_priceFROM Vendors INNER JOIN ProductsON Vendors.vend_id = Products.vend_id; 4、联结多个表 ：SQL不限制一条SELECT语句中可以联结的表的数目。创建联结的基本规则也相同，首先列出所有表，然后定义表之间的关系； 12345SELECT prod_name, vend_name, prod_price, quantityFROM OrderItems, Products, VendorsWHERE Products.vend_id = Vendors.vend_idAND OrderItems.prod_id = Products.prod_idAND order_num = 20007; 性能考虑：DBMS在运行时关联指定的每个表，以处理联结。这种处理可能非常耗费资源，因此应该注意，不要联结不必要的表。联结的表越多，性能下降越厉害； 执行任一给定的SQL操作一般不止一种方法。很少有绝对正确或绝对错误的方法。性能可能会受操作类型、所使用的DBMS、表中数据量、是否存在索引或键等条件的影响。 创建高级联结1、使用表别名：SQL除了可以对列名和计算字段使用别名，还允许给表名起别名； 缩短SQL语句； 允许在一条SELECT语句中多次使用相同的表； 1234567#表别名不仅能用于WHERE子句，还可以用于SELECT的列表、ORDER BY子句以及其他语句部分#表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户端。SELECT cust_name, cust_contactFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id = O.cust_idAND OI.order_num = O.order_numAND prod_id = &apos;RGAN01&apos;; 2、使用不同类型的联结： 自联结： 12345#许多DBMS处理联结远比处理子查询快得多SELECT c1.cust_id, c1.cust_name, c1.cust_contactFROM Customers AS c1, Customers AS c2WHERE c1.cust_name = c2.cust_nameAND c2.cust_contact = &apos;Jim Jones&apos;; 自然联结：排除多次出现，使每一列只返回一次 ； 123456SELECT C.*, O.order_num, O.order_date,OI.prod_id, OI.quantity, OI.item_priceFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id = O.cust_idAND OI.order_num = O.order_numAND prod_id = &apos;RGAN01&apos;; 外联结：联结包含了那些在相关表中没有关联行的行； 1234#在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）SELECT Customers.cust_id, Orders.order_numFROM Customers LEFT OUTER JOIN OrdersON Customers.cust_id = Orders.cust_id; 3、 使用带聚集函数的联结 ： 1234567891011SELECT Customers.cust_id,COUNT(Orders.order_num) AS num_ordFROM Customers INNER JOIN OrdersON Customers.cust_id = Orders.cust_idGROUP BY Customers.cust_id;#使用左外部联结来包含所有顾客，甚至包含那些没有任何订单的顾客SELECT Customers.cust_id,COUNT(Orders.order_num) AS num_ordFROM Customers LEFT OUTER JOIN OrdersON Customers.cust_id = Orders.cust_idGROUP BY Customers.cust_id; 4、使用联结和联结条件：联结及其使用的要点； 注意所使用的联结类型。一般我们使用内联结，但使用外联结也有效； 保证使用正确的联结条件（不管采用哪种语法），否则会返回不正确的数据；。 应该总是提供联结条件，否则会得出笛卡儿积； 在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前分别测试每个联结。这会使故障排除更为简单； 组合查询1、组合查询：多数SQL查询只包含从一个或多个表中返回数据的单条SELECT语句。但是，SQL也允许执行多个查询（多条SELECT语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）； 主要有两种情况需要使用组合查询： 在一个查询中从不同的表返回结构数据； 对一个表执行多个查询，按一个查询返回数据； 2、创建组合查询：可用UNION操作符来组合数条SQL查询。利用UNION，可给出多条SELECT语句，将它们的结果组合成一个结果集； 使用UNION ：给出每条SELECT语句，在各条语句之间放上关键字UNION ； 1234567SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN (&apos;IL&apos;,&apos;IN&apos;,&apos;MI&apos;)UNIONSELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_name = &apos;Fun4All&apos;; UNION规则： UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合四条SELECT语句，将要使用三个UNION关键字）； UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）； 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）； 包含或取消重复的行：使用UNION时，重复的行会被自动取消；如果想返回所有的匹配行，可使用UNION ALL而不是UNION； 对组合查询结果排序：在用UNION组合查询时，只能使用一条ORDER BY子句，它必须位于最后一条SELECT语句之后； 12345678SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN (&apos;IL&apos;,&apos;IN&apos;,&apos;MI&apos;)UNIONSELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_name = &apos;Fun4All&apos;ORDER BY cust_name, cust_contact; 插入数据1、数据插入：INSERT用来将行插入（或添加）到数据库表，插入有几种方式 ； 插入完整的行； 1234567#各列必须以它们在表定义中出现的次序填充，不安全，应该尽量避免使用INSERT INTO CustomersVALUES(&apos;1000000006&apos;,&apos;Toy Land&apos;,&apos;123 Any Street&apos;,&apos;New York&apos;,&apos;NY&apos;,&apos;11111&apos;,&apos;USA&apos;,NULL,NULL); #安全INSERT INTO Customers(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country, cust_contact,cust_email)VALUES(&apos;1000000006&apos;,&apos;Toy Land&apos;,&apos;123 Any Street&apos;,&apos;New York&apos;,&apos;NY&apos;,&apos;11111&apos;,&apos;USA&apos;,NULL,NULL); 插入行的一部分：使用这种语法，还可以省略列，这表示可以只给某些列提供值，给其他列不提供值； 12INSERT INTO Customers(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)VALUES(&apos;1000000006&apos;,&apos;Toy Land&apos;,&apos;123 Any Street&apos;,&apos;New York&apos;,&apos;NY&apos;,&apos;11111&apos;,&apos;USA&apos;); 如果表的定义允许，则可以在INSERT操作中省略某些列。省略的列必须满足以下某个条件： 该列定义为允许NULL值（无值或空值）； 在表定义中给出默认值。这表示如果不给出值，将使用默认值 ； 插入检索出的数据：将SELECT语句的结果插入表中，这就是所谓的INSERT SELECT。顾名思义，它是由一条INSERT语句和一条SELECT语句组成的； 1234567#这条语句将插入多少行呢？这依赖于CustNew表有多少行INSERT INTO Customers( cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state, cust_zip,cust_country)SELECT cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state, cust_zip,cust_countryFROM CustNew; INSERT通常只插入一行。要插入多行，必须执行多个INSERT语句。INSERT SELECT是个例外，它可以用一条INSERT插入多行，不管SELECT语句返回多少行，都将被INSERT插入； 2、从一个表复制到另一个表 ：使用SELECT INTO语句。与INSERT SELECT将数据添加到一个已经存在的表不同，SELECT INTO将数据复制到一个新表（有的DBMS可以覆盖已经存在的表，这依赖于所使用的具体DBMS）； INSERT SELECT与SELECT INTO：它们之间的一个重要差别是前者导出数据，而后者导入数据 ； 123#这条语句创建一个名为CustCopy的新表，并把Customers表的整个内容复制到新表中。CREATE TABLE CustCopy ASSELECT * FROM Customers; 更新和删除数据1、更新数据：更新（修改）表中的数据，可以使用UPDATE语句。有两种使用UPDATE的方式； 基本的UPDATE语句由三部分组成：要更新的表 、列名和它们的新值、确定要更新哪些行的过滤条件； 更新表中的特定行； 123456UPDATE CustomersSET cust_contact = &apos;Sam Roberts&apos;,cust_email = &apos;sam@toyland.com&apos;WHERE cust_id = &apos;1000000006&apos;#要删除某个列的值，可设置它为NULL（假如表定义允许NULL值）#其中NULL用来去除cust_email列中的值。这与保存空字符串很不同（空字符串用&apos;&apos;表示，是一个值），而NULL表示没有值 更新表中的所有行；（不加where子句） 2、删除数据 ： 从一个表中删除（去掉）数据，使用DELETE语句。有两种使用DELETE的方式； 从表中删除特定的行； 123#DELETE不需要列名或通配符。DELETE删除整行而不是删除列DELETE FROM CustomersWHERE cust_id = &apos;1000000006&apos;; 删除表的内容而不是表：DELETE语句从表中删除行，甚至是删除表中所有行。但是，DELETE不删除表本身； 更快的删除：如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，而速度更快（因为不记录数据的变动）； 从表中删除所有行； 3、更新和删除的指导原则 ： 除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句 ； 保证每个表都有主键（如果忘记这个内容，请参阅第12课），尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）； 在UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确； 创建和操纵表1、创建表：使用SQL的CREATE TABLE语句 ； 表创建基础： 12345678CREATE TABLE Products(prod_id CHAR(10) NOT NULL,vend_id CHAR(10) NOT NULL,prod_name CHAR(254) NOT NULL,prod_price DECIMAL(8,2) NOT NULL,prod_desc VARCHAR(1000) NULL); 使用NULL值：主键和NULL值— 主键是其值唯一标识表中每一行的列。只有不允许NULL值的列可作为主键，允许NULL值的列不能作为唯一标识 ； 指定默认值：用关键字DEFAULT指定； 12345678CREATE TABLE OrderItems(order_num INTEGER NOT NULL,order_item INTEGER NOT NULL,prod_id CHAR(10) NOT NULL,quantity INTEGER NOT NULL DEFAULT 1,item_price DECIMAL(8,2) NOT NULL); 2、更新表：使用ALTER TABLE语句； 1234ALTER TABLE VendorsADD vend_phone CHAR(20);ALTER TABLE VendorsDROP COLUMN vend_phone; 3、删除表：使用DROP TABLE语句； 1DROP TABLE CustCopy; 4、重命名表 ：使用RENAME语句，要求指定旧表名和新表名； 使用视图1、视图：视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询； 视图的一些常见应用 ： 重用SQL语句； 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道其基本查询细节； 使用表的一部分而不是整个表； 保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限 ； 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据； 视图仅仅是用来查看存储在别处数据的一种设施。视图本身不包含数据，因此返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据； 视图的规则和限制： 与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）； 对于可以创建的视图数目没有限制； 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。所允许的嵌套层数在不同的DBMS中有所不同（嵌套视图可能会严重降低查询的性能，因此在产品环境中使用之前，应该对其进行全面测试）； 视图不能索引，也不能有关联的触发器或默认值； 2、 创建视图：用CREATE VIEW语句来创建 ，只能用于创建不存在的视图； ​ 删除视图，可以使用DROP语句，其语法为DROP VIEW viewname；覆盖（或更新）视图，必须先删除它，然后再重新创建； 利用视图简化复杂的联结 ： 123456#创建一个名为ProductCustomers的视图，它联结三个表CREATE VIEW ProductCustomers ASSELECT cust_name, cust_contact, prod_idFROM Customers, Orders, OrderItemsWHERE Customers.cust_id = Orders.cust_idAND OrderItems.order_num = Orders.order_num; 用视图重新格式化检索出的数据： 1234CREATE VIEW VendorLocations AS SELECT CONCAT(vend_name,&apos;(&apos;,RTRIM(vend_country),&apos;)&apos;) AS vend_titleFROM Vendors 用视图过滤不想要的数据 ： 1234CREATE VIEW CustomerEMailList ASSELECT cust_id, cust_name, cust_emailFROM CustomersWHERE cust_email IS NOT NULL; 使用视图与计算字段： 1234567CREATE VIEW OrderItemsExpanded ASSELECT order_num,prod_id,quantity,item_price,quantity*item_price AS expanded_priceFROM OrderItems; ​ 视图可极大地简化复杂数据的处理； 总结：视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种封装SELECT语句的层次，可用来简化数据处理，重新格式化或保护基础数据； 使用存储过程1、存储过程 ：存储过程就是为以后使用而保存的一条或多条SQL语句。可将其视为批文件，虽然它们的作用不仅限于批处理； 2、为什么要使用存储过程： 通过把处理封装在一个易用的单元中，可以简化复杂的操作； 由于不要求反复建立一系列处理步骤，因而保证了数据的一致性。如果所有开发人员和应用程序都使用同一存储过程，则所使用的代码都是相同的；（防止错误） 简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，那么只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化 ；（安全性） 3、执行存储过程 ：EXECUTE，EXECUTE接受存储过程名和需要传递给它的任何参数； 12345#执行一个名为AddNewProduct的存储过程，将一个新产品添加到Products表中EXECUTE AddNewProduct( &apos;JTS01&apos;,&apos;Stuffed Eiffel Tower&apos;,6.49,&apos;Plush stuffed toy with the text LaTour Eiffel in red white and blue&apos; ); 存储过程所完成的工作： 验证传递的数据，保证所有4个参数都有值 ； 生成用作主键的唯一ID； 将新产品插入Products表，在合适的列中存储生成的主键和传递的数据； 4、创建存储过程：CREATE PROCEDURE； 管理事务处理1、事务处理（transaction processing）：通过确保成批的SQL操作要么完全执行，要么完全不执行，来维护数据库的完整性； 事务处理是一种机制，用来管理必须成批执行的SQL操作，保证数据库不包含不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止，它们要么完全执行，要么完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表；如果发生错误，则进行回退（撤销），将数据库恢复到某个已知且安全的状态； 2、使用事务处理时，有几个反复出现的关键词： 事务（transaction）指一组SQL语句； 回退（rollback）指撤销指定SQL语句的过程； 提交（commit）指将未存储的SQL语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），可以对它发布回退（与回退整个事务处理不同）； 事务处理用来管理INSERT、UPDATE和DELETE语句。不能回退SELECT语句（回退SELECT语句也没有必要），也不能回退CREATE或DROP操作。事务处理中可以使用这些语句，但进行回退时，这些操作也不撤销； 3、控制事务处理：管理事务的关键在于将SQL语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退； 1START TRANSACTION COMMITT用于保存更改，ROLLBACK用于撤销； 使用ROLLBACK； 使用COMMIT； 使用保留点：要支持回退部分事务，必须在事务处理块中的合适位置放置占位符。这样，如果需要回退，可以回退到某个占位符。 在SQL中，这些占位符称为保留点； 创建占位符，可使用SAVEPOINT语句，SAVEPOINT delete1； 总结：保留点越多越好—可以在SQL代码中设置任意多的保留点，越多越好。为什么呢？因为保留点越多，你就越能灵活地进行回退； 使用游标1、游标（cursor）：有时，需要在检索出来的行中前进或后退一行或多行，这就是游标的用途所在； 游标（cursor）是一个存储在DBMS服务器上的数据库查询， 它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据； 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改； 2、使用游标： 在使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句和游标选项 ； 一旦声明，就必须打开游标以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来； 对于填有数据的游标，根据需要取出（检索）各行； 在结束游标使用时，必须关闭游标，可能的话，释放游标（有赖于具体的DBMS）； 3、创建游标 ：使用DECLARE语句创建游标； 1234DECLARE CustCursor CURSORFORSELECT * FROM CustomersWHERE cust_email IS NULL 4、使用游标：使用OPEN CURSOR语句打开游标 ； 1OPEN CURSOR CustCursor 在处理OPEN CURSOR语句时，执行查询，存储检索出的数据以供浏览和滚动； 现在可以用FETCH语句访问游标数据了。FETCH指出要检索哪些行，从何处检索它们以及将它们放于何处（如变量名）； 5、关闭游标：CLOSE CustCursor； 高级SQL特性1、高级数据处理特性：约束、索引和触发器； 2、约束（constraint）：管理如何插入或处理数据库数据的规则； 主键： 1234567CREATE TABLE Vendors(vend_id CHAR(10) NOT NULL PRIMARY KEY,vend_name CHAR(50) NOT NULL);ALTER TABLE VendorsADD CONSTRAINT PRIMARY KEY (vend_id); 外键 ： 12345678910#外键有助防止意外删除CREATE TABLE Orders(order_num INTEGER NOT NULL PRIMARY KEY,order_date DATETIME NOT NULL,cust_id CHAR(10) NOT NULL REFERENCES Customers(cust_id));ALTER TABLE OrdersADD CONSTRAINTFOREIGN KEY (cust_id) REFERENCES Customers (cust_id); 唯一约束（UNIQUE）：唯一约束用来保证一列（或一组列）中的数据是唯一的。它们类似于主键，但存在以下重要区别： 表可包含多个唯一约束，但每个表只允许一个主键； 唯一约束列可包含NULL值； 唯一约束列可修改或更新； 唯一约束列的值可重复使用； 与主键不一样，唯一约束不能用来定义外键； 检查约束：用来保证一列（或一组列）中的数据满足一组指定的条件； 1234567#对OrderItems表施加了检查约束，它保证所有物品的数量大于0CREATE TABLE OrderItems(prod_id CHAR(10) NOT NULL,quantity INTEGER NOT NULL CHECK (quantity &gt; 0)); ADD CONSTRAINT CHECK (gender LIKE &apos;[MF]&apos;) 3、索引： 用来排序数据以加快搜索和排序操作的速度，在一个或多个列上定义索引，使DBMS保存其内容的一个排过序的列表，在定义了索引后，DBMS以使用书的索引类似的方法使用它。DBMS搜索排过序的索引，找出匹配的位置，然后检索这些行 ； 索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。在执行这些操作时，DBMS必须动态地更新索引； 索引数据可能要占用大量的存储空间； 并非所有数据都适合做索引。取值不多的数据（如州）不如具有更多可能值的数据（如姓或名），能通过索引得到那么多的好处； 索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能适合做索引； 可以在索引中定义多个列（例如，州加上城市）。这样的索引仅在以州加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处； 索引用CREATE INDEX语句创建，索引必须唯一命名 ： 123#在Products表的产品名列上创建一个简单的索引CREATE INDEX prod_name_indON PRODUCTS (prod_name); 检查索引：索引的效率随表数据的增加或改变而变化。许多数据库管理员发现，过去创建的某个理想的索引经过几个月的数据处理后可能变得不再理想 了。最好定期检查索引，并根据需要对索引进行调整； 4、触发器：是特殊的存储过程，它在特定的数据库活动发生时自动执行。触发器可以与特定表上的INSERT、UPDATE和DELETE操作（或组合）相关联； 与存储过程不一样（存储过程只是简单的存储SQL语句），触发器与单个的表相关联。与Orders表上的INSERT操作相关联的触发器只在Orders表中插入行时执行。类似地，Customers表上的INSERT和UPDATE操作的触发器只在表上出现这些操作时执行； 触发器的一些常见用途： 保证数据一致。例如，在INSERT或UPDATE操作中将所有州名转换为大写； 基于某个表的变动在其他表上执行活动。例如，每当更新或删除一行时将审计跟踪记录写入某个日志表； 进行额外的验证并根据需要回退数据。例如，保证某个顾客的可用资金不超限定，如果已经超出，则阻塞插入； 计算计算列的值或更新时间戳； 123456789#创建一个触发器，它对所有INSERT和UPDATE操作，将Customers表中的cust_state列转换为大写CREATE TRIGGER customer_stateAFTER INSERT OR UPDATEFOR EACH ROWBEGINUPDATE CustomersSET cust_state = Upper(cust_state)WHERE Customers.cust_id = :OLD.cust_idEND; 约束比触发器更快：一般来说，约束的处理比触发器快，因此在可能的时候，应该尽量使用约束； 5、数据库安全：任何安全系统的基础都是用户授权和身份确认。这是一种处理，通过这种处理对用户进行确认，保证他是有权用户，允许执行他要执行的操 作。有的DBMS为此结合使用了操作系统的安全措施，而有的维护自己的用户及密码列表，还有一些结合使用外部目录服务服务器； 一般说来，需要保护的操作有： 对数据库管理功能（创建表、更改或删除已存在的表等）的访问； 对特定数据库或表的访问； 访问的类型（只读、对特定列的访问等）； 仅通过视图或存储过程对表进行访问； 创建多层次的安全措施，从而允许多种基于登录的访问和控制 ； 限制管理用户账号的能力； 安全性使用SQL的GRANT和REVOKE语句来管理，不过，大多数DBMS提供了交互式的管理实用程序，这些实用程序在内部使用GRANT和REVOKE语句 ； 总结：约束是实施引用完整性的重要部分，索引可改善数据检索的性能，触发器可以用来执行运行前后的处理，安全选项可用来管理数据访问。 ​ ​ ​ ​ ​ ​","comments":true,"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"设计模式-观察者模式","date":"2019-03-18T02:08:53.000Z","path":"2019/03/18/设计模式-观察者模式/","text":"简单的说模式就是一种惯性的思维方式，用于解决同一类问题。 About模式：我们处理大量问题时，在很多不同的问题中重复出现的一种性质，它使得我们可以使用一种方法来描述问题实质并用本质上相同，但细节永不会重复的方法去解决，这种性质就叫模式。简单的说模式就是一种惯性的思维方式，用于解决同一类问题； 观察者模式（Observer）：何谓观察者模式？观察者模式定义了对象之间的一对多依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。 在这里，发生改变的对象称之为观察目标，而被通知的对象称之为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，所以么可以根据需要增加和删除观察者，使得系统更易于扩展。 所以观察者提供了一种对象设计，让主题和观察者之间以松耦合的方式结合。 简单例子观察者模式具备：事件的源、事件对象、事件处理对象； 以西游记为例，唐僧就是事件源，孙悟空、猪八戒、沙僧都是事件处理对象，事件对象包含有关事件和事件的源信息（就是记录唐僧发生事件的信息）； 先写事件对象类： TangEvent（记录唐僧发生事件的信息）： 1234567891011public class TangEvent &#123; private String eventStr; public TangEvent() &#123; &#125; public TangEvent(String eventStr) &#123; this.eventStr = eventStr; &#125; public String getEventStr() &#123; return eventStr; &#125;&#125; 接着写可以处理唐僧发生事件的接口类（Apprentice），只要是唐僧的徒弟就可以处理唐僧发生的事件，徒弟的功能就是观察唐僧看是否有事件需要处理： 123public interface Apprentice &#123; public void lookTS(TangEvent e);&#125; 再写可以处理事件的具体徒弟类，实现徒弟接口： 孙悟空实现类： 12345678910public class SunApprentice implements Apprentice &#123; @Override public void lookTS(TangEvent e) &#123; if(\"白骨精\".equals(e.getEventStr())) &#123; System.out.println(\"三打白骨精!\"); &#125; else if(\"女儿国王\".equals(e.getEventStr())) &#123; System.out.println(\"全凭师父定力！\"); &#125; &#125;&#125; 猪八戒实现类： 12345678910public class ZhuApprentice implements Apprentice &#123; @Override public void lookTS(TangEvent e) &#123; if(\"白骨精\".equals(e.getEventStr())) &#123; System.out.println(\"白骨精不是妖怪!\"); &#125; else if(\"女儿国王\".equals(e.getEventStr())) &#123; System.out.println(\"将师父留在女儿国吧！\"); &#125; &#125;&#125; 沙僧实现类： 12345678910public class ShaApprentice implements Apprentice &#123; @Override public void lookTS(TangEvent e) &#123; if(\"白骨精\".equals(e.getEventStr())) &#123; System.out.println(\"千万别误伤好人!\"); &#125; else if(\"女儿国王\".equals(e.getEventStr())) &#123; System.out.println(\"担心师父在女儿国王那有事！\"); &#125; &#125;&#125; 写事件源类（三要素：私有的监听者列表，公有的向监听者列表添加监听者的方法，公有的发生事情的方法）： 12345678910111213public class Tang &#123; private List&lt;Apprentice&gt; list = new ArrayList&lt;Apprentice&gt;();//私有的监听者列表 public void addTangListener(Apprentice apprentice) &#123;//公有的向监听者列表添加监听者的方法 this.list.add(apprentice); &#125; public void tangAction(String s) &#123;//公有的发生事情的方法 TangEvent tangEvent = new TangEvent(s); for(int i = 0; i &lt; this.list.size(); i++) &#123; Apprentice apprentice = this.list.get(i); apprentice.lookTS(tangEvent); &#125; &#125;&#125; 最后写一个Run类，事件源添加监听者实现类的实例： 1234567891011121314public class Run &#123; public static void main(String[] args) &#123; Tang tang = new Tang(); SunApprentice sun = new SunApprentice(); ZhuApprentice zhu = new ZhuApprentice(); ShaApprentice sha = new ShaApprentice(); //事件源加监听者实现类的实例 tang.addTangListener(sun); tang.addTangListener(zhu); tang.addTangListener(sha); tang.tangAction(\"白骨精\"); tang.tangAction(\"女儿国王\"); &#125;&#125; 至此，一个简单的观察者模式小例子完成。其实，在java中，我们不必像上面那样全都需要自己手动写，最后那个Run才需要我们自己完成。 事件源添加监听者接口实例四种方法： 1、自己加自己 2、自己加别人（实现接口） 3、自己加别人（适配器） 4、参数匿名类（适配器） 以Java Swing为例，先看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class MyFrame extends JFrame implements MouseListener &#123; private JPanel bodyPanel = null; private JButton b1 = null; private JButton b2 = null; private JButton b3 = null; private JButton b4 = null; private void init() &#123; this.bodyPanel = (JPanel)this.getContentPane(); this.bodyPanel.setLayout(new GridLayout(2, 2)); this.b1 = new JButton(\"b1\"); this.b1.addMouseListener(this);//自己加自己 this.bodyPanel.add(this.b1); this.b2 = new JButton(\"b2\"); MyListener1 myListener1 = new MyListener1(); this.b2.addMouseListener(myListener1);//自己加别人（实现接口） this.bodyPanel.add(this.b2); this.b3 = new JButton(\"b3\"); this.b3.addMouseListener(new MyListener2());//自己加别人（适配器） this.bodyPanel.add(this.b3); this.b4 = new JButton(\"b4\"); this.b4.addMouseListener(new MouseAdapter() &#123;//参数匿名类（适配器） public void mouseEntered(MouseEvent e) &#123; b4.setBackground(Color.BLACK); &#125; @Override public void mouseExited(MouseEvent e) &#123; b4.setBackground(Color.ORANGE); &#125; &#125;); this.bodyPanel.add(this.b4); this.setBounds(10, 10, 400, 400); this.setTitle(\"监听者模式\"); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public MyFrame() &#123; this.init(); &#125; public static void main(String[] args) &#123; MyFrame frame = new MyFrame(); frame.setVisible(true); &#125; @Override public void mouseClicked(MouseEvent e) &#123; &#125; @Override public void mousePressed(MouseEvent e) &#123; &#125; @Override public void mouseReleased(MouseEvent e) &#123; &#125; @Override public void mouseEntered(MouseEvent e) &#123; if(e.getSource() == this.b1) &#123; this.b1.setBackground(Color.RED); this.b4.setBackground(Color.BLUE); &#125; &#125; @Override public void mouseExited(MouseEvent e) &#123; if(e.getSource() == this.b1) &#123; this.b1.setBackground(Color.BLUE); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728public class MyListener1 implements MouseListener &#123; @Override public void mouseClicked(MouseEvent e) &#123; &#125; @Override public void mousePressed(MouseEvent e) &#123; &#125; @Override public void mouseReleased(MouseEvent e) &#123; &#125; @Override public void mouseEntered(MouseEvent e) &#123; JButton b2 = (JButton)e.getSource(); b2.setBackground(Color.BLUE); &#125; @Override public void mouseExited(MouseEvent e) &#123; JButton b2 = (JButton)e.getSource(); b2.setBackground(Color.GREEN); &#125;&#125; 12345678910111213public class MyListener2 extends MouseAdapter &#123; @Override public void mouseEntered(MouseEvent e) &#123; JButton b3 = (JButton)e.getSource(); b3.setBackground(Color.YELLOW); &#125; @Override public void mouseExited(MouseEvent e) &#123; JButton b3 = (JButton)e.getSource(); b3.setBackground(Color.PINK); &#125;&#125; 从代码也可以看出，适配器里面其实是一些空实现的方法，可以避免代码出现过多的空方法。 参考文章：http://cmsblogs.com/?p=3396#7Observer","comments":true,"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"零基础入门C语言","date":"2019-03-09T02:31:51.000Z","path":"2019/03/09/C语言入门/","text":"轻松入门C语言，通俗易懂的小例子理解C语言的三大结构 About面向对象和面向过程 面向过程就是人看待事物的眼光和思想，关注于步骤； 面向对象是一种对现实世界理解和抽象的方法； 面向过程—&gt;怎么做、面向对象—&gt;谁在做； 学习C语言的方法（其他语言类似） 入门：先了解背景、市场占有率、这门语言主要用途、前景如何、哪个公司发明； 最小单元：常量、变量、数据类型； 次小单元：运算符、表达式； 结构：业务逻辑（顺序结构、分支结构、循环结构）； 高级部分：数组、函数； 特征（语言所特有部分）：指针； 基础部分程序的入门 程序：做一件事情的过程，作用：计算机模拟现实生活，从而达到降低成本，提高效率的效果； 计算机中的程序：为了让计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合； 算法就是对解决问题的方法的描述，算法是描述、程序是执行； 算法固性：有穷性（步骤有限）、确定性（步骤清晰不模糊） 、交互性（具有输入输出）、有效性（步骤有效）； 如何表示算法：自然语言（需求分析）、流程图（概要设计-避免歧义）、伪代码（详细设计）、程序语言（出差：需求、部署）； C语言：面向过程的结构化语言，三种基本结构：顺序结构、分支选择结构、循环结构； 基础知识 低级语言：（汇编）机器语言，可以直接操作计算机硬件；中级语言（C），指针可操作计算机硬件，人类语言；高级语言：（Java）人类语言，经过编译变成机器语言，机器才能执行； 编译：语法查错、转成机器语言（转译）； C语言优点：既能开发系统程序，又能开发应用程序； C语言：面向过程，结构化的（顺序，分支，循环），函数语言； 学习方法：wwwh（why, what, when, how），程序 = 数据结构 + 算法； 最小单元变量和常量 最小的盛放数据单元； 常量：值不能改变的量，一般常量和符号常量（用#define定义，一改全改）； 变量：值可以改变的量，变量的本质是一片连续的内存空间，变量是一个容器，用来存放数据； C语言规定：变量必须先声明，再赋值，后使用；所有变量定义在函数首部，有了执行语句，就不能再有定义语句； 变量命名规则（三条）: ​ —必须以数字，字母，下划线组成，以字母或下划线开头； ​ —见名知义，首字母小写； ​ —变量不能和关键字重名，区分大小写； 基本数据类型 基本数据类型：运算法则、约束内存空间大小的单位； 数值：整型（int，short int，long int）和非整型（float，double），非数值：char； 1个字节 = 8位 、一个中文字符 = 2个字节 、一个英文字符 = 1个字节； C语言中没有字符串变量，用字符数组模拟字符串变量（难用）； ASCII码：0~9（48~57），A~Z（65~90），a~z（97~122）， C语言中char和int完全兼容； 类型转换: ​ —&gt;自动类型转换：把范围小的类型的值转换为范围大的类型的值：（ short, int, long, float, double）； ​ —&gt;强制类型转换：(类型名)变量或数值； 转义字符：转为其他的意思（\\t， \\n等）； C语言的输入输出：getchar() ，putchar()，输入输出字符； scanf() ，printf()输入输出任何东西，（sacnf和printf中的f是format的意思，即格式化输入和输出）； 次小单元运算符&amp;表达式 表达式：操作数 + 运算符； 数学表达式、赋值表达式、关系表达式、逻辑表达式； 算数运算符：+、-、* 、/、%（二目）， /：两边都是整数取整，/：两边至少一边为实型求精确值，%：要求两边都是整型，求余； 12345678910111213141516171819202122232425262728//算数运算符练习：回文数：void main() &#123; int ge, shi, qian, wan, x; printf(\"请输入一个五位数：\"); scanf(\"%d\", &amp;x); wan = x / 10000; qian = x % 10000 / 1000; shi = x % 100 / 10; ge = x % 10; if(wan == ge &amp;&amp; qian == shi) &#123; printf(\"%d是回文数\\n\", x); &#125; else &#123; printf(\"%d不是回文数\\n\", x); &#125;&#125;//水仙花数：void main() &#123; int n, ge, shi, bai; for(n = 100; n &lt;= 999; n++) &#123; ge = n % 10; shi = n % 100 / 10; bai = n / 100; if(ge * ge * ge + shi * shi * shi + bai * bai * bai == n) &#123; printf(\"%d\\n\", n); &#125; &#125;&#125; ++、–（一目），单个语句时a++和++a效果一样，参与运算时a++和++a效果不一样； 123456789//自增自减练习：void main() &#123; int a = 1, b = 2, c = 3, d, e, f; d = ++a; e = a + b; f = (b--) + c; printf(\"%d %d %d %d %d %d\\n\", a, b, c, d, e, f);&#125; 运行结果：2 1 3 2 4 5 赋值：变量 = 表达式； 关系运算符：&gt;、&gt;=、！=、==、&lt;、&lt;=； 逻辑运算符（与、或、非）：&amp;&amp;、||、！； C语言中：用0代表假，非零代表真；sizeof：可以获得数据类型占用内存空间的大小 ；sizeof(type_name) 结果以字节为单位显示； 三种结构顺序结构分支选择结构 if：（布尔常量， 布尔变量， 比较表达式， 逻辑表达式）； 多分支（否定式： 多重if-else、 switch-case）； 123456789101112131415161718192021222324252627282930313233343536//多重if-elsevoid main() &#123; int f; printf(\"请问你送几朵花：\"); scanf(\"%d\", &amp;f); if(f &gt;= 9 &amp;&amp; f &lt; 99) &#123; printf(\"笑一笑\"); &#125; else if(f &gt;= 99 &amp;&amp; f &lt; 999) &#123; printf(\"拉拉手\"); &#125; else if(f &gt;= 999) &#123; printf(\"抱一抱\"); &#125; else &#123; printf(\"不高兴\"); &#125; &#125;解释：程序能进入到下一个elseif语句块，说明前面if里的条件不成立//switch-casevoid main() &#123; int f; printf(\"请问你送几朵花：\"); scanf(\"%d\", &amp;f); switch(f) &#123; case 9: printf(\"笑一下\"); break; case 99: printf(\"拉拉手\"); break; case 999: printf(\"抱一下\"); break; default: printf(\"不高兴\"); &#125; &#125;解释：程序能进入到下一个case语句块，说明前面case里的条件不成立，每个case后应该有break语句，否则程序会执行当前case条件满足后的所有语句，不符逻辑。 （肯定式：If嵌套）； 1234567891011121314151617181920void main() &#123; int work, house, car; printf(\"请输入你的资源：\"); scanf(\"%d %d %d\", &amp;work, &amp;house, &amp;car); if(work) &#123; if(house) &#123; if(car) &#123; printf(\"赶紧结婚\"); &#125; else &#123; printf(\"买了车就结婚\"); &#125; &#125; else &#123; printf(\"无房不嫁女\"); &#125; &#125; else &#123; printf(\"先好好提升自己\"); &#125;&#125;解释：当进入下一个if条件判断时，说明满足之前if的判断条件。 switch-case：switch()里可以是整型常量，整型变量，整型表达式；case后面必须是整型常量，case最后一句跟break；case后面不能跟相同的值，case可以随意倒顺序； 条件运算符：a &gt; b ? c : d —-如果a &gt; b成立，则结果为C，否则为d； 循环结构 循环的本质：有规律的重复的做一件事； 循环分类：（小括号—规律，花括号—重复），规律：已知循环次数（循环变量i）和未知循环次数（循环的开关）；循环体：当型、直到型； 当型（while-未知循环次数、for-已知循环次数），直到型：do-while（已知循环次数和未知循环次数）； 12345678910111213141516171819202122232425262728293031323334353637383940414243//whilevoid main() &#123; int i = 0, j = 0; while(i &lt; 10) &#123; printf(\"第%d个同学演节目开始！\", (i + 1)); while(j &lt; 3) &#123; printf(\"第%d个节目!\", (j + 1)); j++; &#125; j = 0; printf(\"第%d个同学演节目结束！\\n\", (i + 1)); i++; &#125;&#125;//forvoid main() &#123; int i, j; for(i = 0; i &lt; 10; i++) &#123; printf(\"第%d个同学演节目开始！\", (i + 1)); for(j = 0; j &lt; 3; j++) &#123; printf(\"第%d个节目！\", (j + 1)); &#125; printf(\"第%d个同学演节目结束！\\n\", (i + 1)); &#125;&#125;//do-while（猜数字）void main() &#123; int flag = 1; int num = 8, guess; printf(\"请输入一个1~10之间的数！\"); do &#123; printf(\"请输入：\"); scanf(\"%d\", &amp;guess); if(guess &lt; num) &#123; printf(\"小了！\"); &#125; else if(guess &gt; num) &#123; printf(\"大了！\"); &#125; else &#123; flag = 0; &#125; &#125; while(flag); printf(\"恭喜你答对了！\");&#125; 已知循环次数：循环变量在外面定义并初始化，循环变量在循环体里进行自增或自减； 循环的嵌套：外层一趟，内层一遍； for循环：for（表达式1；表达式2；表达式3）， ​ 表达式1：循环变量赋初值； ​ 表达式2：循环条件； ​ 表达式3：更新循环变量值； break与continue：break，终止，在多层循环中，一个break语句只向外跳一层循环；continue：中止，只能用在循环里，跳过循环体中剩余的语句而执行下一次；对于while和do-while循环（continue语句执行之后的动作是条件判断），对于for循环，随后的动作是变量更新； 一般情况下，这几种循环体用的概率：for（60%）、while（25%）、do-while（15%）； 高级部分数组 why？数据带上结构：贴近现实生活，操作、维护方便； 主要内容：数组名、数组大小、数组下标、数组容器的样子、数组类型； 变量&amp;数组比较： ​ 变量：值可变的量、一片连续的内存空间、小容器； ​ 数组：一组数放在一起、一片连续的有序的类型相同的空间、大容器； 种类：一维、二维、多维； 一维数组声明： 1datatype arrayName[size]; //（size：整型常量） 静态定义（三种）： 123int num[5] = &#123;1, 2, 3, 4, 5&#125;;int n1[] = &#123;1, 2, 3&#125;;int n2[5] = &#123;1, 2, 3&#125; 动态定义（循环初始化）； 字符数组模拟字符串变量： 1char c[2] = \"ok\"； 输入输出字符串：gets(),puts()—可输入空格； 二维数组声明： 静态定义（两种）： 12int num[2][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;;int num[][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; 动态定义（使用for循环初始化）； 1234567891011121314151617//找数字：void main() &#123; int n = 8, i; int num[10]; for(i = 0; i &lt; 10; i++) &#123; scanf(\"%d\", &amp;num[i]); &#125; for(i = 0; i &lt; 10; i++) &#123; if(n == num[i]) &#123; printf(\"找到了：%d, 位置：%d\", num[i], i + 1); break; &#125; &#125; if(i == 10) &#123; printf(\"对不起，没找到！\"); &#125;&#125; 函数 使用函数四个优点： ​ 让主调函数更简短清晰； ​ 提高代码维护效率； ​ 提高代码开发效率； ​ 提高代码复用率； 函数类型： ​ 内置函数—函数原型，功能，在哪个工具箱（头文件）放着； ​ 自定义函数； rand（）：伪随机函数； 12srand((unsigned)time(NULL))---作种函数（每次出来的随机数不一样）；//没有这句，程序运行每次随机数一样 自定义函数：返回值类型 函数名（[参数的数据类型 参数名],…），函数一次性只能返回一个值； 一个函数只做一件事；（高内聚） 函数原型说明：int add(int a, int b)或int add(int, int)； 函数的参数：函数定义中声明的参数是形参，函数调用时传入的参数就是实参； 函数参数的传递：值传递（将实参拷贝一份赋值给形参），址传递（让形参和实参共享一片内存空间，即内存地址相同）； 12345678910111213141516171819202122//值拷贝传递void add(int x, int y) &#123; x++; y++;&#125;void main() &#123; int a = 1, b = 2; add(a, b); printf(\"%d %d\", a, b);&#125;运行结果：1 2//址传递void add(int n[2]) &#123; n[0]++; n[1]++;&#125;void main() &#123; int a[2] = &#123;1, 2&#125;; add(a); printf(\"%d %d\", a[0], a[1]);&#125;运行结果：2 3 变量作用域： 变量的有效范围 —&gt; 全局、局部； 123456789101112131415161718192021222324252627//简单彩票机void main() &#123; int i = 0, j, m; int lottery[7]; srand((unsigned)time(NULL)); printf(\"请问您是否要购买彩票？\"); printf(\"请选择：1-是，0-否\\n\"); scanf(\"%d\", &amp;m); if(m) &#123; do&#123; lottery[i] = (rand() % 33) + 1; for(j = 0; j &lt; i; j++) &#123; if(lottery[j] == lottery[i]) &#123; break; &#125; &#125; if(!(j &lt; i)) &#123; i++; &#125; &#125; while(i &lt; 7); for(i = 0; i &lt; 7; i++) &#123; printf(\"%d \", lottery[i]); &#125; &#125; else &#123; return 0; &#125;&#125; 特征指针 指针：就是内存地址，一个变量只有一个指针； 指针变量：用来存放地址的变量，变量的指针：变量的地址； 关键的运算符：&amp; 取地址符、* 指针运算符； int p== (int )p； n[i - 1] = (n + (i - 1)) = (p + (i - 1))；","comments":true,"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C语言/"}]}]