[{"title":"计算机网络总结","date":"2019-04-09T08:26:10.000Z","path":"2019/04/09/计算机网络总结/","text":"计算机网络基础总结 计算机网络体系结构 1、五层协议： 应用层（用户对用户） 任务：提供系统与用户的接口功能：文件传输、访问和管理、电子邮件服务协议：FTP、SMTP、POP3、HTTP、DNS 传输层（应用对应用、进程对进程） 传输单位：报文段（TCP）或用户数据报（UDP）任务：负责主机中两个进程之间的通信功能：为端到端连接提供可靠的传输服务；为端到端连接提供流量控制、差错控制、服务质量等管理服务协议：TCP、UDP 网络层（主机对主机） 传输单位：数据报所实现的硬件：路由器任务：将传输层传下来的报文段封装成分组；选择适当的路由，使传输层传下来的分组能够交付到目的主机协议：ICMP、ARP、RARP、IP、IGMP 数据链路层 传输单位 ：帧所实现的硬件：交换机、网桥任务：将网络层交下来的IP数据报组装成帧功能：链路连接的建立拆除、分离；帧定界和帧同步；差错检测 物理层 传输单位：比特所实现的硬件：集线器、中继器任务：透明地传输比特流功能：为数据端设备提供传送数据通路 2、OSI： 表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题； 会话层 ：建立及管理会话； 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理； 3、TCP/IP： 将五层协议中数据链路层和物理层合并为网络接口层； TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层； 物理层1、物理层的作用：实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异； 2、透明传送比特流：表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的； 3、数据传输方式： 电路交换：通信之前要在通信双方之间建立一条被双方独占的物理通路； 报文交换：采用存储转发的传输方式； 分组交换：采用存储转发的传输方式，可能出现失序、丢失或重复分组现象； 数据链路层1、数据链路层（链路层）：两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧； 2、数据链路层：封装成帧、透明传输、差错检测； 2、封装成帧：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束； 3、透明传输：当两个主机互相传送信息时，网络层的分组必须封装成帧，并以帧的格式进行传送； 帧定界：将一段数据的前后分别添加首部和尾部，就构成了帧，首部和尾部中含有很多控制信息，这些信息的重要作用之一是确定帧的界限； 4、差错检测：目前数据链路层广泛使用循环冗余检验（CRC）来检查比特差错； 5、信道复用技术： 频分复用：所有主机在相同的时间占用不同的频率带宽资源； 时分复用：所有主机在不同的时间占用相同的频率带宽资源； 统计时分复用：是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送； 波分复用：光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波； 码分复用：为每个用户分配 m bit 的码片，并且所有的码片正交； 6、CSMA/CD（载波监听多路访问 / 冲突检测）协议：每个站在发送数据报之前要先检测一下总线上是否有其他计算机在发送数据，若有，则暂时不发送数据，以免发生冲突；若没有，则发送数据。计算机在发送数据的同时检测信道上是否有冲突发生，若有，则采用截断二进制指数类型退避算法来等待一段随机时间后再次重发。（先听后发、边听边发、冲突停发、随机重发）； 7、PPP点对点协议：互联网用户通常需要连接到某个 ISP （互联网服务提供商）之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议； 8、MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）； 9、局域网：局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限； 10、广域网：由一些结点交换机以及连接这些交换机的链路组成； 11、以太网：采用总线拓扑结构，所有计算机共享一条总线，信息以广播方式发送； 12、交换机（多端口的网桥）：具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射，由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容； 网络层1、网络层：负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫IP数据报，简称数据报； 2、网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络； 3、与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protocol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） 4、IP数据报格式： 5、IP地址编址方式： 分类：由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的； IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 子网划分：从主机号借用若干个比特作为子网号（子网号绝不能全1和全0），而主机号也就相应减少了若干个比特，网络号不变，把两级 IP 地址划分为三级 IP 地址； IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 子网掩码：1对应于IP地址中的网络号和子网号，0对应于主机号，子网掩码与IP地址逐位“与”可得到网络地址； 无分类编址（CIDR）：为解决IP地址耗尽，使用各种长度的“网络前缀”来代替分类编址中的网络号和子网号； IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} 6、地址解析协议ARP：将IP地址转为物理（MAC）地址，每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表； 7、网际控制报文协议ICMP：检测出错误的路由器或主机都能把这些错误报告通过一些控制消息告诉发送数据的主机，ICMP分为两种：ICMP差错报告报文和ICMP询问报文； 8、路由器：从功能上可以划分为：路由选择和分组转发，分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口； 9、路由选择协议： 自治系统内部的路由选择：RIP 和 OSPF； RIP（UDP） 是一种基于距离向量的路由选择协议。距离是指跳数（范围限制在15跳之内），超过 15 表示不可达； 三要素： 仅和相邻路由器交换信息；交换的信息是当前本路由器所知道的全部信息，即自己的路由表；按固定的时间间隔交换路由信息； OSPF（IP）：链路状态协议； 三要素： 向本自治系统中所有路由器发送信息；发送的信息是否是与本路由器相邻的所有路由器的链路状态；只有当链路状态发生变化时，路由器才用洪犯法向所有路由器发送此信息； 自治系统间的路由选择：BGP（TCP），路径-向量路由选择协议； 总结： 主要特点 RIP OSPF BGP 网关协议 内部 内部 外部 路由表内容 目的网络，下一跳，距离 目的网络，下一跳，距离 目的网络，完整路径 最优通路依据 跳数 费用 的多种有关策略 算法 距离–向量协议 链路状态协议 路径-向量协议 传送方式 UDP IP数据报 TCP 10、NAT：将专用网内部使用的本地IP地址转换为有效的外部全球IP地址； 运输层1、运输层：负责向两台主机进程之间的通信提供通用的数据传输服务； 2、网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道； 3、UDP（一般用于即时通信，比如QQ语音 、QQ视频 、直播）主要特点： UDP是无连接的； UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）； UDP是面向报文的； UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）； UDP支持一对一、一对多、多对一和多对多的交互通信； UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短； 4、TCP（一般用于文件传输、发送和接收邮件、远程登录等场景）主要特点： TCP是面向连接的；（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）； 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）； TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达； TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据； 面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流； 5、TCP三次握手： 为什么要三次握手？ 三次握手的目的是建立可靠的通信信道，防止报文段在传输连接建立过程中出现差错； 6、TCP四次挥手： 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接； 7、TCP协议保证可靠传输： 超时重传： 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段； 利用滑动窗口实现流量控制的机制：发送窗口里面的序号表示允许发送的序号。如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收； 拥塞控制：在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载； 流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度； TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复； 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口； 慢开始（呈指数增长）：当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍； 拥塞避免（线性增长）：让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1； 快重传与快恢复：在TCP/IP中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有FRR，如果数据包丢失了，TCP将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作； 应用层1、应用层：通过应用进程间的交互来完成特定网络应用； 2、域名系统（DNS）：DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。这里的分布式数据库是指，每个站点只保留它自己的那部分数据； 3、文件传送协议：FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件； 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答； 数据连接：用来传送一个文件数据； 4、电子邮件协议： 一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议； 邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP； SMTP：SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则； POP3：只要用户从服务器上读取了邮件，就把该邮件删除，但是目前改进的 POP3 已经全面支持下载而不删除原邮件。 它的另一个主要特点是：无论你在客户端做了任何操作（如移动、标记），都不会反映到服务器上，也就是只能单方面地从服务器“读取”； IMAP：客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被自动删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 同时它与 POP3 的本质区别在于，在客户端的操作（包括删除）都会反映到服务器上，是一个双向的通信； 5、常用端口： 6、HTTP协议：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法； 7、浏览器输入url地址，显示主页的过程： 8、各种协议与HTTP协议之间的关系： 9、HTTP长连接、短连接： 在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话； 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码： 1Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接； 10、状态码： 11、HTTP和HTTPS的基本概念： HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少； HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL； HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性； 12、HTTP和HTTPS的区别： https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用； http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议； http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443； http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全； 参考博文链接：这篇和这篇～ 附图TCP、UDP互联网协议： TCP 三次握手和四次挥手： 从浏览器 URL 输入到页面显示经历过程： HTTPS与HTTP的区别，以及HTTP2： 附图来源： https://github.com/Joe19970619/Learning-materials/tree/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84","comments":true,"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"利用西门子数据集获取函数调用序列","date":"2019-04-08T08:07:10.000Z","path":"2019/04/08/利用西门子数据集获取函数调用序列/","text":"利用pvtrace工具获取测试集 replace 的函数调用关系图 About西门子数据集的目录结构参见此篇博文，本篇博文主要介绍根据需求编写测试脚本，利用pvtrace工具动态的将测试用例传入程序并获取函数调用关系图。由于在西门子的7个子测试集中，replace测试集含有的函数最多，因此本篇博文选用replace测试集作为例子，其他数据集也一样操作。 测试脚本范例理解上篇博文已经介绍replace数据集给我们提供了范例脚本，存储在scripts目录中，该脚本用于运行source.alt / source.orig 目录中被测程序的正确原型，但是研究软件缺陷定位不可能只运行正确的程序，将测试用例动态传入错误版本的程序并分析其运行结果更为重要，下面我们介绍如何利用套件中已经给出的范例脚本修改得到自己需要的运行脚本。 打开scripts目录下的runall.sh脚本，部分截图如下： 可以看出，该脚本的功能： 遍历inputs文件夹下的所有测试用例（replace测试集的inputs文件夹下包含3个子文件夹，里面的测试用例共计5542个）； 将每个测试用例依次传入被测程序中，并指定输出结果存放的路径； 如果想要将该脚本修改为执行错误版本程序的脚本，我们需要修改： 可执行程序的路径； 程序执行结果存放的路径； 手工修改该脚本中5542个路径显然不可行，需要手工编写程序使其自动修改路径，生成新的脚本文件。 在实际情况中，仅仅获取被测程序的运行结果通过与否是不足够的，根据需求还应获取程序执行信息（这里我示范的是获取程序的函数调用关系图）。 我们还需要了解pvtrace工具的使用，这个工具可以获取程序的函数调用关系，通过Graphviz 可以将函数调用关系可视化展示，下面介绍下pvtrace和Graphviz的安装： 安装pvtrace： 12345678#进入fl文件目录下：wget http://www.mtjones.com/developerworks/pvtrace.zip#解压下载包，如果出现命令找不到，需下载压缩工具yum install -y unzip zip 或者 sudo apt-get install zipunzip pvtrace.zipcd pvtracemakesudo make install 安装Graphviz： 1yum install graphviz 这里给出pvtrace和Graphviz的使用介绍链接： http://www.voidcn.com/article/p-xlemghrq-xb.html https://www.ibm.com/developerworks/cn/linux/l-graphvis/ 如果需要获取函数调用关系，为了避免路径出错，我们直接将pvtrace路径下的instrument.c文件拷贝到跟源码文件同级目录下，在GCC编译代码文件时需要加入指定编译选项即可： 1gcc -g -finstrument-functions replace.c instrument.c -o replace.exe 简单获取函数动态调用关系图示例这里先简单介绍下，如何获取函数动态调用关系图： 将pvtrace路径下的instrument.c文件拷贝到source.alt / source.orig目录下，然后将源程序代码replace.c和instrument.c一起编译，命令如下： 12cd source.alt/source.origgcc -g -finstrument-functions replace.c instrument.c -o replace.exe 将scripts目录中的脚本进行修改（命名为runV1.sh），这里示例一个测试用例，后面写代码批量修改路径： 12replace.exe '-?' 'a&amp;' &lt; ../../inputs/temp-test/1.inp.1.1 &gt; ../../outputs/t1pvtrace replace.exe 执行脚本文件： 1source ./runV1.sh source.alt / source.orig目录下生成graph.dot文件，用graphviz将它可视化： 1dot -Tpng graph.dot -o graph.png 执行命令后会报错，打开graph.dot文件将第一行的graph.dot改为graph即可，再执行上面命令； 执行完后，目录下会生成一个graph.png的图，这个图就是程序replace.c在传入t1这个测试用例生成的函数调用关系图： 从上图还可以看到函数之间调用的次数，当然，我们如果需要数据处理的话，利用graph.dot文件就够了，这个文件里包含函数之间调用关系，调用顺序，调用次数，这些信息根据需要自己进行处理； 生成测试脚本下面我参考这篇博文根据范例脚本生成错误版本执行的脚本，脚本生成使用lua语言实现。 首先初始化，指定子套件名称”replace”，测试用例个数5542和错误版本程序个数32； 12345678910SUITE_NAME = \"replace\"CASE_NUM = 5542VERSION_NUM = 32 --should be 32 in replace--VARIABLES--buff = &#123;&#125;i = 0j = 0k = 0line_num = 0tmp = \"\" 接着我们要将范例给的的runall.sh 读入，以便在下一步的文本分析中可以按行进行文本匹配，下面的程序段完成了将范例给出的runall.sh 文本读入，并按行存储至一个缓冲字符串数组buff 中： 12345678--SAVE ORIG SCRIPT INTO BUFFER--file = io.open(\"runall.sh\", \"r\")for line in file:lines() do i = i + 1; buff[i] = lineendline_num = ifile:close() 最后就是将buff 数组中的每一行进行文本匹配，将”/source.alt/source.orig/”字段全部替换为”/../../versions.alt/versions.orig/vX/”(其中”X”为相应的错误版本号)，将”/inputs/”字段全部替换为”/../../inputs/”，将”/outputs/”字段全部替换为”/../../newoutputs/vX”(其中”X”为相应的错误版本号)，其余保持不变，实现代码如下： 12345678910111213141516171819--GENERATE RUN SCRIPT FOR VERSIONS--for i = 1, VERSION_NUM do k = 1 file = io.open(\"run_v\"..i..\".sh\", \"w\") for j = 1, line_num do tmp = buff[j] if string.find(tmp, \"/source.alt/source.orig/\") ~=nil then tmp = string.gsub(tmp,\"/source.alt/source.orig/\", \"/../../versions.alt/versions.orig/v\"..i..\"/\") --modefy paths-- tmp = string.gsub(tmp,\"/inputs/\", \"/../../inputs/\") tmp = string.gsub(tmp,\"/outputs/\", \"/../../newoutputs/v\"..i..\"/\") tmp = tmp..\"\\ncd ../../../versions.alt/versions.orig/v\"..i..\" &amp;&amp; pvtrace replace.exe\" tmp = tmp..\"\\nmv trace.txt ./tra\"..k.. \" &amp;&amp; mv graph.dot ./tra\"..k k = k + 1 end file:write(tmp..\"\\n\") tmp = \"\" end file:close()end 上面这段代码为每次错误版本都生成了一个名为run_vX.sh 的运行脚本，其中X为相应的错误版本号。并且在每个测试用例执行之后，进入错误版本目录下运行命令pvtrace replace.exe，生成函数调用关系trace.txt和graph.dot文件，因为每个测试用例运行生成的dot文件名都是graph、txt文件名都是trace，因此为了避免覆盖需要将各个版本的每个测试用例生成的dot和txt文件移入对应的文件夹（下面需要在每个版本文件夹下建立5542个名为traX的文件夹—X为相对应执行的测试用例）； 123456789101112#下面是用python代码在每个错误版本程序文件夹下生成5542个存放dot和txt的文件夹#make_dir.pyimport osimport shutildir = os.getcwd()for index1 in range(1, 33): if index1 &gt; 0: new_dir = dir + '/v'+ str(index1) for index2 in range(5543): if index2 &gt; 0: os.mkdir(new_dir + '/tra' + str(index2)) pass 执行命令：python make_dir.py即可生成文件夹； 接着在versions.alt/versions.orig目录下建立一个存放shell脚本的文件夹sh，并将范例脚本runall.sh拷贝至sh目录下； 最后我们就可以执行前面的lua程序了，完整代码链接如下： 链接：https://pan.baidu.com/s/1aEO52uidTEVSKNJuzg2_mg 提取码：kqyz 12#运行make_sh.lua程序lua make_sh.lua 运行完后，可以在sh目录下发现生成的错误版本相对应的32个sh脚本，如下图： 批量编译在执行错误版本的测试脚本之前，首先需要对错误版本的代码进行自动批量编译，在这里，我们使用makefile 进行自动编译，makefile的结构如下： 12replace: gcc -g -finstrument-functions replace.c instrument.c -o replace.exe 由于我对makefile还不熟悉，因此采用的笨办法，将这个makefile文件在每个错误版本文件夹下拷贝一份，然后再写代码自动编译（在编译之前需要修改程序源码使其编译通过，修改方式参考这篇博文。","comments":true,"tags":[{"name":"软件缺陷定位","slug":"软件缺陷定位","permalink":"http://yoursite.com/tags/软件缺陷定位/"}]},{"title":"软件缺陷定位西门子数据集介绍","date":"2019-04-08T01:25:03.000Z","path":"2019/04/08/软件缺陷定位西门子数据集介绍/","text":"Siemens suite 的下载及使用详细步骤 AboutSiemens suite是软件缺陷定位领域研究中最常用的测试套件，可从SIR（software infrastructurerepository）下载，这个测试套件被很多有关软件缺陷定位的文献中使用。 Siemens suite下载进入SIR网址，如下图： 此时需要注册经审核后才可以登录下载，点即Get Access进入登录注册界面： 点击Register进入注册界面，注册需要填写自己所在机构或公司（我填的是学校名称），还有关于自己研究方向的简短描述，填完基本信息后，经过审核就可以登录进行下载了。 登录后，可以点击Download Objects进行下载： 这里我把Siemens suite包含的7个测试集都下载好了，链接如下： 链接：https://github.com/xuexuehan/Siemens-suite Siemens suite使用首先看下Siemens suite包含的7个测试集主要信息： Program Description Lines of Code Faulty versions Test cases print_tokens lexical analyzer 565 7 4130 print_tokens2 lexical analyzer 510 10 4115 schedule priority scheduler 412 9 2650 schedule2 priority scheduler 307 10 2710 replace pattern replacement 563 32 5542 tcas altitude separation 173 41 1608 tot_info information measure 406 23 1052 这几个测试集的文件组织结构和使用方法基本雷同，只要掌握一个，其他也是一样的方法。接下来主要以replace测试集为例介绍下该套件的目录组织结构： 首先建立一个存放测试集的文件夹fl，将下载的replace测试集放在fl文件夹下，在此目录下解压： 1tar zxvf replace_2.1.tar.gz 解压完成后，会在解压目录下生成replace文件夹，打开文件夹可以看到其目录组织结构： 在这些目录中，我们需要用到的有inputs、newoutputs、outputs、scripts、source.alt、versions.alt，这里面source和versions文件夹是空的，可以忽略； 先看source.alt / source.orig里面有replace.c这个被测程序的代码文件，在执行测试程序以前，需要将其提前编译为replace.exe 的二进制文件以供测试程序调用。进入source.alt / source.orig目录下，利用Linux平台上 GCC编译器编译被测代码，使用命令： 1gcc -O2 replace.c -o replace.exe 注意：”-O2”中是大写字母”O”而不是数字”0”,表示使用2级优化，而后面的”-o”中是小写字母”o”,表示指定输出文件名。执行命令后可以看到： 可以看到编译器弹出警告，这是由于Siemens Suite 套件中，代码大多完成于90年代，而我们使用的GCC 编译器的版本较新。在此期间，C语言的国际标准发生了很大变化，在replace中，如果想要编译器编译通过，需要修改replace.c代码文件： 主要修改的还是将一些库函数加入到include中，把内置函数和关键字重命名： 首先将 ctype.h 和 stdlib.h 头文件加入到include中； 将函数名为getline的全部替换为get_line（因为getline函数在stdio.h中已经定义，重命名即可）； 将# define NULL 0 修改为 define NUL 0（因为NULL是关键字，提示重复定义）； 此时，修改完毕，再继续编译，即可通过，会在同目录下生成replace.exe； 这里放上我修改后的replace.c代码文件链接： 链接：https://pan.baidu.com/s/1c4mKAcqNegs7kMBa_abVdg 提取码：upkh 在编译其他测试套件代码文件时也会弹出警告，甚至报出错误无法编译，需要按照相应的提示修改代码文件； versions.alt / versions.orig 目录中保存了该被测程序的每个错误版本（在正确的程序之中，随机植入若干错误，产生的错误代码供大家测试），打开versions.alt / versions.orig 目录可以看到replace的32个错误版本文件夹（里面的replace.c里有植入错误，同理按照上面的步骤修改使其编译通过）： 在这32个错误版本中，错误产生的地方在代码文件中有注释标明； inputs / input 目录里保存了所有的测试用例的输入； outputs 目录用于保存被测程序的正确原型（即source.alt / source.orig 目录中的replace.c代码）对于每个测试用例给出的预期输出，在测试含有错误的版本时用于比较相同测试用例得到的执行结果是否相同。在未执行任何测试程序之前，outputs 目录暂时为空； newoutputs 目录用于保存被测程序的每个错误版本对于每个测试用例得到的实际输出，在测试含有错误的版本时用于比较相同测试用例得到的执行结果是否相同。在未执行任何测试程序之前，newoutputs 目录暂时为空； scripts 目录中保存了子测试套件给出的测试脚本范例，打开scripts 目录后可以看到该目录下有一个名为runall.sh 的shell 脚本文件，该脚本文件用于运行source.alt / source.orig目录中被测程序正确原型，将测试用例输入到被测程序正确原型中后，将执行结果输出到replace 中outputs 目录下，按每个测试用例组织文件，runall.sh 中共定义了5542 个测试用例（replace 子套件共有5542 个测试用例），在scripts 目录中输入命令 source ./runall.sh 即可运行该脚本文件，在运行该脚本之前，需要先将source.alt / source.orig 中的replace.c代码文件编译并且修改runall.sh脚本文件replace.exe存放的路径。因为现在新版的套件replace.c程序文件在source.alt / source.orig目录下而非source目录下，将脚本文件中所有的 ../source 替换为 ../source.alt/source.orig； 这里给出我修改后的runall.sh脚本文件链接： 链接：https://pan.baidu.com/s/1efga4E3dI5uh7tk2YFZJWA 提取码：6tan 当运行完runall.sh脚本后，在outputs目录下可以看到这5542个测试用例执行后的结果文件，下图是部分截图： 至此，西门子测试集的子套件目录结构介绍完毕。 参考博文：https://blog.csdn.net/mangoer_ys/article/details/25974067#commentBox （这个博主写的真详细，我基本就是参考这个博文了解的西门子测试集使用方法）","comments":true,"tags":[{"name":"软件缺陷定位","slug":"软件缺陷定位","permalink":"http://yoursite.com/tags/软件缺陷定位/"}]},{"title":"阿里云部署SpringBoot项目","date":"2019-04-07T09:07:25.000Z","path":"2019/04/07/阿里云部署SpringBoot项目/","text":"阿里云部署Spring Boot 项目详细步骤 购买云服务器首先需要在阿里云购买云服务器，进入链接后选择弹性计算，选择所需的类型购买（如果是学生党，完成学生认证后，有学生专享优惠，9.5/月，不能再划算了…），购买完成后，点击控制台就可看到自己购买云服务器的详情； 设置密码，这个密码就是用ssh连接云服务器的密码； 这里我使用了两个软件：SecureCRT（用来连接云服务器） 和 WinSCP（用来从本机给云服务器上传文件）； WinSCP图形化界面如下： 左边面板显示的是本机文件目录，右边是云服务器文件目录；（如果目录不显示压缩包的话，记得在传输选项里的配置里在面板选项去掉“默认目录是主目录”）； 这两个软件下载地址：https://pan.baidu.com/s/1zUnhqBffaqiDG3wYFM6dpg 提取码：1zxb 然后就开始在云服务器上安装配置MySQL和JDK； 安装配置MySQL这里安装配置需要细心，因为有挺多需要修改的配置文件，当然用docker安装配置更加方便，这里用的常规安装配置； 首先将MySQL安装包用WinSCP从本机上传至云服务器； 这里提供我安装MySQL所使用的版本： 链接：https://pan.baidu.com/s/1t8wBXQy89AF-XYxeN3Et1g提取码：az6k 具体安装配置步骤如下面链接文档所示（因为步骤有点多，直接提供文档，步骤很详细）： 链接：https://pan.baidu.com/s/1eLal9b3j5Aca_vcA0VCf0A 提取码：gfxy链接里的配置文档主要操作就是安装MySQ、添加用户组和用户、授权、配置环境变量、修改密码、关闭防火墙…，在修改了配置文件后需要flush privileges，最后就是需要在阿里云添加安全组规则，开放MySQL端口号3306； 安装配置JDK首先将JDK安装包用WinSCP从本机上传至云服务器，我上传到云服务器/opt目录里面； 这里提供我安装JDK所使用的版本： 链接：https://pan.baidu.com/s/1IyQqgMepQj4kQthiE9FITA 提取码：uizg 解压文件： 12cd /opttar -zxvf jdk的文件名 将jdk移动到/home目录：mv jdk1.8.0_171/ /home/ 配置环境变量： vim /etc/profile 在末尾行添加，打开后按 i 编辑, 按 ctrl+c 停止编辑，然后 :wq 保存退出 12export JAVA_HOME=/home/jdk1.8.0_171export PATH=$PATH:$JAVA_HOME/bin: 使更改的配置立即生效：source /etc/profile java -vsion查看JDK版本信息，如果显示出1.8.0证明成功 阿里云发布项目将打包后的项目用WinSCP从本机上传至云服务器，然后向mysql云服务器执行项目sql脚本，在阿里云添加安全组规则，开放端口号8080和80，进入上传项目的目录下执行命令： 12//后台进程执行项目nohup java -jar spring-boot-10-bill-0.0.1-SNAPSHOT.jar --serverport=80 &amp; 停止运行项目： 1234//查看进程ps -ef|grep java//找到项目的进程id，杀死该进程kill -9 进程id 至此，项目部署完毕，可以通过云服务器的ip地址访问项目。当然如果买了域名，挂到云服务器的ip地址下，就可以解析ip，直接通过域名访问。 MySQL中文乱码部署完项目，访问时可能会出现中文乱码问题，首先登录mysql； 12#查看数据库编码：show variables like '%char%'; 如果character_set_database 和 character_set_server显示字符编码为latin1,此时修改mysql配置文件/etc/my.cnf： 123456[mysqld]character-set-server=utf8 [client]default-character-set=utf8 [mysql]default-character-set=utf8 然后再重启，登录mysql，查看字符编码： 1show variables like '%char%'; 出现如上图字符编码为utf-8,则成功。 参考博客链接：https://blog.csdn.net/u012410733/article/details/61619656","comments":true,"tags":[{"name":"Spring-Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot基础总结","date":"2019-04-07T06:53:02.000Z","path":"2019/04/07/Spring-Boot基础总结/","text":"关于Spring Boot一些基础总结 About1、尽快启动和运行，使用“习惯优于配置”（项目中存在大量的配置，而 Spring Boot 内置一个习惯性的配置，让你无须手动进行配置）的理念让项目快速运行起来； 2、Spring Boot 优点 ： 快速构建独立运行的Spring项目； 无须依赖外部Servlet容器，应用无需打成WAR包；项目可以打成jar包独自运行； 提供一系列 starter pom 来简化 Maven 的依赖加载； 大量的自动配置，对主流开发框架的无配置集成； 无须配置XML，开箱即用，简化开发，同时也可以修改默认值来满足特定的需求； Spring Boot 并不是对 Spring 功能上的增强，而是提供了一种快速使用 Spring 的方式； 极大提高了开发、部署效率 ； 入门1、两种启动方式： 直接main； 打成jar包，在dos命令下java -jar 项目名称； 2、Spring Boot底层依赖： 123456789101112131415161718192021222324252627282930 /* spring-boot-starter-parent：是当前项目的父依赖 spring-boot-starter-parent继承spring-boot-dependencies spring-boot-dependencies里面定义了很多组件版本号，我们引用对应依赖时，不需要写&lt;version&gt; */&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; /* spring-boot-starter-web：构建web项目，比如：Tomcat、SpringMVC spring-boot-starter：它是SpringBoot的场景启动器，针对不同场景定义了很多不同的场景启动器 你的项目需要哪些场景启动器，则直接依赖对应的启动器就可以了 */ &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; //将当前项目打成一个jar包运行 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 3、Spring Boot底层源码： 1234567891011121314/** * @SpringBootApplication 用于标识为引导类,说明当前是一个SpringBoot项目 * @SpringBootConfiguration * @Configuration 它属于spring中的一个注解，定义配置类，等价于配置文件 * @Component 添加到spring容器中，表示是一个组件 * @EnableAutoConfiguration * @AutoConfigurationPackage 将引导类所在包及其子包下面所有的组件添加到spring容器中 * @Import(&#123;AutoConfigurationImportSelector.class&#125;) * 1、将所有组件以全类名的方式返回，并且添加到spring容器中 * 2、会给容器中导入非常多的自动配置类（*****AutoiConfiguration），就是导入并配置好很多当 前项目中所需要的组件 * 省去我们手动编写配置然后注入到组件中 * @ComponentScan 被该注解标识的类，会被spring容器进行管理 **/@SpringBootApplication//组合注解 核心配置1、spring boot全局配置： application.properts application.yml 2、YAML： YAML不是一个标记语言； 以数据为中心，配置数据的时候具有面向对象的特征；比json、xml更适合做配置文件； 3、YAML语法格式： YAML基本语法： key: value 表示一对键值对（冒号后面必须有空格）； 使用空格缩进表示层级关系； 左侧缩进的空格数目不重要，只要同一层级的元素左侧对齐即可 ； key 与 value大小写敏感； YMAL常用写法： 字面量： 数值，字符串，布尔，日期； 字符串默认不用加上引号： “ ” 使用双引号会转义特殊字符，特殊字符最终会转成本来想表示含义输出； ‘ ‘ 使用单引号不会转义特殊字符，特殊字符当作一个普通的字符串输出； 对象 &amp; Map ： key: value value存储对象，每个值换一行写，注意值要左对齐； 1234emp: lastName: xiaomeng age: 22 salary: 10000 行内写法： 1emp: &#123;lastName: xiaomeng, age: 22, salary: 10000&#125; 数组（List、Set）： 用 - 值表示数组中的一个元素： 1234fortes: - java - python - hadoop 行内写法： 1fortes: [java, python, hadoop] ​4、YAML全局配置文件注入值： 12345/** ConfigurationProperties: 告诉spring boot将配置文件中的对应属性值，映射到这个组件类中，进行一一绑定* prefix = \"emp\": 配置文件中的前缀名，配置了哪个前缀就会与下面的所有属性进行一一映射* @Component: 将当前组件作为springboot中的一个组件来使用，这样才会纳入容器中管理* */ 5、@Value注解获取注入值： 1234567/** * 类似于spring框架中使用配置文件中的数据注入方式 * &lt;bean class=\"Emp\"&gt; * &lt;property name=\"lastName\" value=\"字面量/#&#123;SpEL&#125; spring表达式/$&#123;key&#125;从配置文件获取\"&gt; &lt;/property&gt; * &lt;/bean&gt; * */ @Value(\"$&#123;emp.last-name&#125;\") 6、比较@Value和@ConfigurationProperties获取值： @ConfigurationProperties @Value 示例 实现功能 批量注入配置文件的属性值 一个一个指定 松散绑定（松散语法） 支持 不支持 last_name == lastNamelast-name == lastName SpEL 不支持 支持 #{10*2} 复杂类型封装 支持 不支持 ${emp.map} JSR303数据校验 支持 不支持 使用场景： 如果只是在某个业务逻辑中需要获取配置文件中的某个属性值，就使用 @Value； 如果专门使用javaBean和配置文件进行映射，就使用 @ConfigurationProperties； 7、加载局部配置文件： 1@PropertySource(value = &#123;\"classpath:emp.properties\"&#125;) 8、加载XML配置文件： 12//用于导入spring的配置文件，并将它加载到容器中@ImportResource(locations = &#123;\"classpath:spring01.xml\"&#125;) 9、自定义配置类： 123456789101112131415/***@Configuration: 它属于spring中的一个注解,用于标识当前类是一个配置类，来表示对应spring配置文件**/@Configurationpublic class EmpConfig &#123; /** * @Bean 标识的方法用于向容器中注入组件 * 1、返回值就是注入容器中组件对象 * 2、方法名就是这个组件的 id 值 * */ @Bean public EmpService empService2() &#123; System.out.println(\"EmpService 组件注入成功\"); return new EmpService(); &#125; 10、多环境项目配置支持： 12345678910111213141516171819//properties#激活profile文件spring.profiles.active=prod//ymlserver: port: 8081 #默认配置的端口号spring: profiles: active: dev #激活哪个profile---server: port: 8082spring: profiles: dev #指定属于哪个环境，dev环境使用---server: port: 8088spring: profiles: prod #指定属于哪个环境，prod环境使用 程序参数、命令行（jar包运行时）：–spring.profiles.active=prod； 虚拟机指定参数：-Dspring.profiles.active=prod； 11、配置文件加载位置： 配置文件位置 说明 file: ./config/ 当前项目的config目录下（最高级别） file: ./ 当前项目的根目录下（第三级别） classpath: /config/ 类路径的config目录下（第二级别） classpath: / 类路径的根目录下（最低级别） 按照优先级从低到高的顺序，将所有位置的配置文件全部加载，高优先级的配置内容会覆盖低优先级的配置内容； 日志配置1、日志框架： 日志抽象层 日志实现 jboss-logging（不适合企业项目开发使用）JCL（Jakarta Commons Logging）—2014年后不再维护SLF4j（Simple Logging Facade for Java）—与log4j、Logback同一个人开发 JUL（java.util.logging）—担心被抢市场，推出的Log4j（存在性能问题）Logback（Log4j同一个人开发的新框架，做了重大升级）Log4j2（apache开发的很强大，借了log4j的名，但当前很多框架未适配上） Spring Boot 采用了 slf4j+logback 的组合形式，Spring Boot也提供对JUL、log4j2、Logback提供了默认配置； 2、log五大日志级别：（由低到高） 12345678910111213//1、下面定义的都是日志级别，由低到高：trace &lt; debug &lt; info &lt; warn &lt; error//2、spring boot默认设定的是 info 级别日志（日志默认级别也称为root级别）//3、可以通过配置文件进行修改 日志级别，设置某一个级别后，就只打印这个级别及后面更高级别的日志信息，没有指定级别的就用springBoot默认规定的级别，root级别//跟踪运行信息logger.trace(\"这是 trace 日志信息\");//调试信息logger.debug(\"这是 debug 日志信息\");//自定义信息logger.info(\"这是 info 日志信息\");//警告信息logger.warn(\"这是 warn 日志信息\");//错误信息logger.error(\"这是 error 日志信息\"); 1234//调整指定包的日志级别logging.level.com.xx=debug//修改springboot的root级别（默认级别）logging.level.root=debug 3、修改日志默认配置： 修改日志文件生成路径： 1234//输出到当前项目根路径下的springboot.log文件中logging.file=springboot.log//输出到当前项目所在磁盘根路径下的/springboot/log目录中的spring.log文件中 E:\\springboot\\log\\spring.loglogging.path=/springboot/log 修改日志输出的格式： 1234567891011/**日志输出格式说明：* %d 输出日期时间，* %thread 输出当前线程名，* %-5level 输出日志级别，左对齐5个字符宽度# %logger&#123;50&#125; 输出全类名最长50个字符，超过按照句点分割# %msg 日志信息# %n 换行符 *///修改控制台输出的日志格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; == [%thread] %-5level %logger&#123;50&#125; - %msg%n//修改文件中输出的日志格式logging.pattern.file=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-5level &gt;&gt;&gt; %logger&#123;50&#125; - %msg%n 4、自定义日志配置： logback.xml ：是直接就被日志框架加载了； logback-spring.xml：配置项不会被日志框架直接加载，而是由 SpringBoot 解析日志配置文件，进而可以使用 SpringBoot 的 Profile 特殊配置 ； 使用日志profile特殊配置，可根据不同的环境激活不同的日志配置： 1234567891011&lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; //根据不同的环境要求进行配置不同的日志信息 &lt;springProfile name=\"dev\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; === [%thread] === %-5level === %logger&#123;50&#125; === %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-5level &gt;&gt;&gt; %logger&#123;50&#125; &gt;&gt;&gt; %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; 5、切换日志框架： 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; //采用log4j2的日志框架 //将spring-boot-starter-logging移除 &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; web开发1、springboot web启动器包括嵌入的Servlet容器和SpringMVC； 2、springboot对静态资源（webjars/静态文件）的映射： 123456789101112public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;if (!this.resourceProperties.isAddMappings()) &#123;logger.debug(\"Default resource handling disabled\");&#125; else &#123;Duration cachePeriod =this.resourceProperties.getCache().getPeriod();CacheControl cacheControl =this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123;//收到 /webjars/**请求后 ，会去classpath:/META-INF/resources/webjars/ 查找资源文件this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;\"/webjars/**\"&#125;).addResourceLocations(new String[]&#123;\"classpath:/METAINF/resources/webjars/\"&#125;).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); 访问 localhost:8080/webjars/jquery/3.3.1/jquery.js 会在下面路径中查找： 123456//引入jquery webjars&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt; 当接受到 /** 请求访问资源时, 会被映射到下面4个 类路径下的静态资源目录中查找 ： 1234classpath:/META-INF/resources/classpath:/resources/classpath:/static/classpath:/public/ 访问 localhost:8080/style.css 会在上面四个静态资源路径中查找文件 ； 3、欢迎页的映射： 会从 4个静态资源目录 + 根路径 / 中 查找 index.html 页面： 12345classpath:/META-INF/resources/classpath:/resources/classpath:/static/classpath:/public//: 当前项目根路径下 会在 静态资源目录下 与 根路径查找 (按该顺序) index.html页面； 收到 “/**” 请求映射； 访问 localhost:8080/ 会在上面5个目录中查找 index.html页面（因为/也属于/**）； 4、项目ico图标的映射： Spring Boot 会在静态资源目录下 与 根路径(按该顺序) 查找 faicon.ico 页面； 如果存在这样的文件，springboot会自动将其设置为应用图标； 5、Thymeleaf模板引擎： 嵌入式tomcat默认不支持jsp； Spring Boot 官方推荐使用 Thymeleaf 作为模板引擎， 因为 Thymeleaf 提供了完美的 SpringMVC 的支持； pom.xml 加入 Thymeleaf 启动器： 12345//thymeleaf 模板启动器&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 模板文件放在哪里 ? DEFAULT_PREFIX = “classpath:/templates/“； 将 HTML 页面放到 classpath:/templates/ 目录下， Thymeleaf 就能自动渲染； 在 html 页面加上以下名称空间, 使用 Thymeleaf 时就有语法提示 ： 1&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt; 6、Thymeleaf语法： 常用属性： 标准表达式语法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273一、Simple expressions（表达式语法） 1. Variable Expressions(变量表达式): $&#123;...&#125; （参考： 4.2 Variables） 1)、获取变量值；使用OGNL表达式； 2）、获取对象的属性, 调用方法 3）、使用内置的基本对象： #ctx : the context object.(当前上下文对象) #vars: the context variables.(当前上下文里的变量) #locale : the context locale. (当前上下文里的区域信息) 下面是Web环境下的隐式对象 #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. 示例: $&#123;session.foo&#125; (用法参考: 18 Appendix A: Expression Basic Objects) 4）、使用内置的工具对象：(用法参考: 19 Appendix B: Expression Utility Objects) #execInfo : information about the template being processed. #messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration) 2. Selection Variable Expressions(选择表达式): *&#123;...&#125; （参考：4.3 Expressions on selections） 1）、和$&#123;&#125;在功能上是一样， 额外新增：配合 th:object 使用 &lt;div th:object=\"$&#123;session.user&#125;\"&gt; 省得每次写$&#123;session.user.firstName&#125;, 直接取出对象，然后写对象名即可 &lt;p&gt;Name: &lt;span th:text=\"*&#123;firstName&#125;\"&gt;Sebastian&lt;/span&gt; &lt;/p&gt; &lt;p&gt;Email: &lt;span th:text=\"*&#123;email&#125;\"&gt;Saturn&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; 3. Message Expressions（获取国际化内容）: #&#123;...&#125; （参考：4.1 Messages） 4. Link URL Expressions（定义URL）: @&#123;...&#125; （参考：4.4 Link URLs） 5. Fragment Expressions（片段引用表达式）: ~&#123;...&#125; （参考：4.5 Fragments） &lt;div th:insert=\"~&#123;commons :: main&#125;\"&gt;...&lt;/div&gt;二、Literals（字面量） （参考： 4.6 Literals） 1. Text literals: 'one text' , 'Another one!' ,… 2. Number literals: 0 , 34 , 3.0 , 12.3 ,… 3. Boolean literals: true , false 4. Null literal: null 5. Literal tokens: one , sometext , main, ... 三、Text operations（文本操作） （参考： 4.7 Appending texts） 1. String concatenation: + 2. Literal substitutions: |The name is $&#123;name&#125;|四、Arithmetic operations（数学运算） （参考： 4.9 Arithmetic operations） 1. Binary operators: + , - , * , / , % 2. Minus sign (unary operator): -五、Boolean operations（布尔运算） 1. Binary operators: and , or 2. Boolean negation (unary operator): ! , not六、Comparisons and equality（比较运算） （参考： 4.10 Comparators and Equality） 1. Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) 2. Equality operators: == , != ( eq , ne )七、Conditional operators(条件表达式;三元运算符) （参考： 4.11 Conditional expressions） 1. If-then: (if) ? (then) 2. If-then-else: (if) ? (then) : (else) 3. Default: (value) ?: (defaultvalue)八、Special tokens（特殊操作） (参考： 4.13 The No-Operation token) 1. No-Operation: - 12345678&lt;!-- th:insert 和 th:replace的区别 th:insert和th:replace都可以引入片段，两者的区别在于 th:insert： 保留引入时使用的标签 th:replace：不保留引入时使用的标签, 将声明片段直接覆盖当前引用标签 --&gt; &lt;div th:replace=\"header :: #header_common_id\" class=\"success\"&gt;&lt;/div&gt; &lt;h2 th:insert=\"header :: #header_common_id\"&gt;&lt;/h2&gt; 17、迭代(th:each)： 12345678910111213141516171819202122 &lt;!--th:each作用在哪个标签上面，对应的就会根据它的值迭代多少次--&gt; &lt;!-- user : 第1个值,代表每次迭代出对象,名字任意取 iterStat : 第2个值,代表每次迭代器内置对象, 名字任意取, 并有如下属性: index : 当前迭代下标 0 开始 count : 当前迭代下标 1 开始 size : 获取总记录数 current : 当前迭代出的对象 even/odd : 当前迭代是偶数还是奇数 (1开始算,返回布尔值) first : 当前是否为第一个元素 last : 当前是否为最后一个元素 --&gt; &lt;tr th:each=\"user, iterStat: $&#123;userList&#125;\"&gt; &lt;td th:text=\"$&#123;iterStat.count&#125;\"&gt;000&lt;/td&gt; &lt;td th:text=\"$&#123;user.username&#125;\"&gt;xxx&lt;/td&gt; &lt;td th:text=\"$&#123;user.gender == 1 ? '男' : '女'&#125;\"&gt;1&lt;/td&gt; &lt;td th:text=\"$&#123;iterStat.size&#125;\"&gt;xxx&lt;/td&gt; &lt;td th:text=\"$&#123;iterStat.even&#125;? '偶数' : '奇数'\"&gt;xxx&lt;/td&gt; &lt;td th:text=\"$&#123;iterStat.first&#125;\"&gt;xxx&lt;/td&gt; &lt;td th:text=\"$&#123;iterStat.last&#125;\"&gt;xxx&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 8、条件判断： 1234567&lt;h3 th:if=\"not $&#123;#lists.isEmpty(userList)&#125;\"&gt;显示出来则userList集合不为空&lt;/h3&gt;&lt;h3 th:unless=\"$&#123;#lists.isEmpty(userList)&#125;\"&gt;显示出来则userList集合不为空&lt;/h3&gt;&lt;div th:switch=\"$&#123;sex&#125;\"&gt; &lt;p th:case=\"$&#123;man&#125;\"&gt;男&lt;/p&gt; &lt;p th:case=\"2\"&gt;女&lt;/p&gt; &lt;p th:case=\"*\"&gt;未知&lt;/p&gt;&lt;/div&gt; 9、显示标签体内容： 1234&lt;!--不转义字符--&gt;&lt;div th:text=\"$&#123;desc&#125;\"&gt;&lt;/div&gt;&lt;!--转义字符--&gt;&lt;div th:utext=\"$&#123;desc&#125;\"&gt;&lt;/div&gt; 显示对象： 12345&lt;div th:object=\"$&#123;session.user&#125;\"&gt; &lt;!--上面已经将对象获取出来，下面直接写属性值即可获取到值--&gt; &lt;p&gt;姓名：&lt;span th:text=\"*&#123;username&#125;\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;性别：&lt;span th:text=\"*&#123;gender&#125; == 1 ? '男' : '女'\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt; 10、springboot热部署： 12345678//开发环境建议关闭thymeleaf缓存spring.thymeleaf.cache=false//热部署依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;//Ctrl + F9 编译 11、扩展springmvc功能： 1234567891011121314151617/** * 1、创建一个WebMvcConfigurer类型的子类 * 2、类上用@Configuration标识它是一个配置类 * 3、不能@EnableWebMvc标识 * 原理： * 1、@Import(&#123;WebMvcAutoConfiguration.EnableWebMvcConfiguration.class&#125;) * 2、public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration * */@Configurationpublic class MySpringConfigurer implements WebMvcConfigurer &#123; //增加视图控制 @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //发送 /xuexue 请求来到 success.html registry.addViewController(\"/xuexue\").setViewName(\"success\"); &#125;&#125; 12、全面控制springmvc： 在自定义的Web配置类上添加 @Configuration 和 @EnableWebMvc 注解； 总结SpringMVC 配置： 在Spring Boot中自已配置组件的时候，先看容器中有没有公司自已配置的（@Bean、@Component）,如果 有就用公司自已配置的; 如果没有，才自动配置； 在Spring Boot中会有非常多的xxxConfigurer帮助我们进行扩展配置； 在Spring Boot中会有很多的xxxCustomizer帮助我们进行定制配置； Spring Boot Restful架构Restful架构：通过HTTP请求方式区别对资源CRUD操作，请求URI是/资源名称/资源标识； 普通CRUD RestfulCRUD 查询 getPrvider provider —GET 添加 addProvider?xxx provider —POST 修改 updateProvider?id=xxx provider /{id} —PUT 删除 deleteProvider?id=1 provider /{id} —DELETE springboot错误处理机制1、几种常见错误（状态码）： 浏览器发送一个不存在的请求时，会报404； 500； 2、timestamp：时间戳， status：状态码， error：错误提示， exception：异常对象， message：异常消息， errors：JSR303数据校验出现的错误； 嵌入式Sevlet容器自定义配置1、注册Servlet三大组件 Servlet/Filter/Listener： ServletRegistrationBean ：注册自定义Servlet ； FilterRegistrationBean：注册自定义Filter； ServletListenerRegistrarionBean：注册自定义Listener； 2、修改嵌入式servlet 容器配置： 123456//修改服务相关的配置server.port=8081//修改关于servlet的相关配置server.servlet.context-path=/servlet//修改tomcat相关配置server.tomcat.max-connections=8000 3、自定义定制器修改嵌入式servlet容器配置： 12345678910111213@Beanpublic WebServerFactoryCustomizer webServerFactoryCustomizer() &#123; return new WebServerFactoryCustomizer() &#123; @Override public void customize(WebServerFactory factory) &#123; ConfigurableServletWebServerFactory factory1 = (ConfigurableServletWebServerFactory)factory; //修改端口号，如果配置文件中与定制器中的配置冲突，默认采用定制器的配置 factory1.setPort(8082); factory1.setContextPath(\"/servlet2\"); &#125; &#125;;&#125; 事务管理123//默认创建表类型是MyISAM，是非事务安全的，所以无法实现事物回滚//指定如下方言: 创建的表类型是Innodb，才可以进行对事物的回滚database-platform: org.hibernate.dialect.MySQL57Dialect 事务管理步骤： 在启动类上 ，使用 @EnableTransactionManagement 开启注解方式事务支持； 在 Service层方法上添加 @Transactional 进行事务管理； 定时任务使用的注解： @EnableScheduling 启动类上开启基于注解的定时任务 ； @Scheduled 标识的方法会进行定时处理 ； 需要通过 cron 属性来指定 cron 表达式： 秒 分 时 日 月 星期几； 在线cron表达式生成器：http://cron.qqe2.com/ 附windows环境下Redis软件下载： https://pan.baidu.com/s/1TPsFnoVJ3e0UhUR5y4K2sw 提取码：qa25 Spring Boot参考文档： https://pan.baidu.com/s/1ai0azTuXtwGSOKEbefIOHw 提取码：hqlv Thymeleaf模板引擎参考文档： https://pan.baidu.com/s/1wymLJ8gbWzzWQG1SRH3NQw 提取码：j5pp ​","comments":true,"tags":[{"name":"Spring-Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Python基础","date":"2019-03-23T05:52:00.000Z","path":"2019/03/23/Python基础/","text":"Python一些基础语法概念 About1、实践、练习 ​ 实践、认识、再实践、再认识 2、实践、实践、实践 基本语法1、程序设计基本方法： 计算机与程序设计：计算机发展按照摩尔定律发展； 编译和解释： 编译：将源代码一次性转为目标代码； 解释：将源代码逐条转成目标代码同时逐条运行的过程； 程序的基本编写方法：IPO（input、process、output）； 2、编程解决问题的步骤： 分析问题：分析问题的计算部分，想清楚； 划分边界：划分问题的功能边界，规划IPO； 设计算法：设计问题的求解算法，关注算法； 编写程序：编写问题的计算程序，编程序； 调试测试：调试程序使正确运行，运行调试； 升级维护：适应问题的升级维护，更新完善； 3、程序语法元素： 注释：单行#，多行’‘’ ‘’‘ 命名（大小写敏感）与保留字（python有33个保留字）；数据类型：字符串（编号索引从0开始）–正向递增序号和反向递减序号、数字类型（整数、浮点数）、列表（有序序列）–使用in判断一个元素是否在列表中； 字符串的使用：使用[]获取字符串中一个或多个字符； 索引：返回字符串中单个字符； 切片：返回字符串中一段字符子串； 语句与函数：赋值语句、分支语句、eval()评估函数–去掉参数最外侧引号并执行余下语句的函数； python程序的输入输出：输入（input—从控制台获取用户输入）、输出（print—以字符形式向控制台输出结果）； 基本图形绘制1、编程语言的多样初心（600多种）： c语言：（指针、内存、数据类型）；语言本质：理解计算机系统结构；解决问题：性能； java：（对象、跨平台、运行时）；语言本质：理解主客体关系；解决问题：跨平台； c++：（对象、多态、继承）；语言本质：理解主客体关系；解决问题：大规模程序； VB：（对象、按钮、文本框）；语言本质：理解交互逻辑；解决问题：桌面应用； python：（编程逻辑、第三方库）；语言本质：理解问题求解；解决问题：各类问题； 2、python语言特点：（通用、脚本、开源、跨平台、多模型）： 特点与优势：强制可读性、较少的底层语法元素、多种编程方式、支持中文字符、（语法简洁）， &gt;13万第三方库、快速增长的计算生态、避免重复造轮子、开放共享、跨操作系统平台、（生态高产） 3、turtle库的使用： turtle（海龟）库基本介绍：python语言的标准库之一，入门级的函数绘制库； python计算生态 = 标准库 + 第三方库 标准库：随解释器直接安装到操作系统中的功能模块 第三方库：需要经过安装才能使用的功能模块 库Library、包Package、模块Module，统称模块 turtle绘图窗体布局：最小单位是像素； 1turtle.setup(width, height, startx, starty) turtle空间坐标体系： 1turtle.goto(x, y) turtle角度坐标体系： 1turtle.seth(angle)#seth()只改变方向但不行进 RGB色彩体系： 1turtle.colormde(mode) 基本数据类型1、数字类型及操作：（整数类型、浮点数类型、复数类型、数值运算操作符、数值运算函数） 整数类型：可正可负，无取值范围限制；pow（x， y）-&gt;计算x的y次方；表示形式（十进制、二进制、八进制、十六进制）； 浮点数类型：带有小数点及小数的数字；浮点数间运算存在不确定尾数，不是bug；round（x， d）-&gt;对x四舍五入，d是小数截取位数；可采用科学计数法表示-&gt;使用字母e或E作为幂的符号； 复数类型：z.real获得实部；z.imag获得虚部； 数值运算操作符：+、-、*、/、//（整数除）； 数值运算函数： 2、天天向上的力量：（GRIT：perseverance and passion for long-term goals） pow(1.01, 365) = 37.78 pow(1.019, 365) = 962.89 GRIT，坚毅，对长期目标的持续激情及持久耐力； 3、字符串类型及操作; 字符串类型的表示：由一对单引号或一对双引号表示； 字符串是字符的有序序列，可以对其中的字符进行索引；字符串两个重要操作：索引（返回字符串中单个字符）和切片（返回字符串中一段字符子串）； 12#使用[M:N:K]根据步长对字符串切片“o一二三四五六七八九十” [::-1] “十九八七六五四三二一o” 转义符（\\）：表达特定字符的本意；转义符形成一些组合，表达一些不可打印的含义； 字符串（由0个或多个字符组成的有序字符序列）操作符： 字符串处理函数： 字符串处理方法： 123\"A, B, C\".split(\",\") #['A', 'B', 'C']\"= python= \".strip(\" =np\") #\"ytho\"\",\".join(\"12345\") #\"1, 2, 3, 4, 5\" 字符串类型的格式化：使用.format()方法 12#字符串中槽&#123;&#125;的默认顺序 = format()中参数的顺序\"&#123;&#125;:计算机&#123;&#125;的CPU占有率为&#123;&#125;%\".format(\"2018-10-10\", \"C\", 10) 4、time库（python中处理时间的标准库）的使用： 时间获取：time（）、ctime（）、gmtime（）； 时间格式化：strftime（）、strptime（）； %Y：年份，%m：月份，%B：月份名称，%b：月份名称缩写，%d：日期，%A：星期，%a：星期缩写， %H：小时（24h制），%h：小时（12h制），%p：上/下午，%M：分钟，%S：秒 程序计时：sleep（）、perf_counter（）； 程序控制结构1、程序的分支结构： 单分支结构：if 二分支结构：if-else（紧凑形式：&lt;表达式1&gt; if &lt;条件&gt; else &lt;表达式2&gt;） 多分支结构：if-elif-else 条件判断及组合：判断（&lt;、&lt;=、&gt;=、&gt;、==、！=），组合（and, or, not） 程序的异常处理：try-except-else-finally 2、程序的循环结构： 遍历循环（遍历某个结构形成的循环运行方式）：for &lt;循环变量&gt; in &lt;遍历结构&gt;: ​ &lt;语句块&gt; 从遍历结构中逐一提取元素，放在循环变量中；由保留字for和in组成，完整遍历所有元素后结束；每次循环，所获得元素放入循环变量，并执行一次语句块；应用：计数循环、字符串遍历循环、文件遍历循环； 无限循环（由条件控制的循环运行方式）： while &lt;条件&gt;： ​ &lt;语句块&gt; 反复执行语句块，直到条件不满足时结束； 循环控制保留字： break：跳出并结束当前整个循环，执行循环后的语句（仅跳出当前最内层循环）； continue：结束当次循环，继续执行后续次数循环； 循环的高级用法（与break有关）：循环与else 当循环没有被break语句退出时，执行else语句块； else语句块作为“正常”完成循环的奖励； 这里else的用法与异常处理中else用法相似； 3、random库（使用随机数的python标准库）的使用： 4、程序运行有80%的时间花在不到10%的代码上（二八法则）； 理解方法思维： 数学思维：找到公式，利用公式求解； 计算思维：抽象一种过程，用计算机自动化求解； 函数和代码复用1、函数的定义与使用： 函数的理解和定义： 函数是一段具有特定功能的、可重用的语句组； 函数是一种功能的抽象，一般函数表达特定功能； 两个作用：降低编程难度、代码复用； 函数是一段代码的表示：def &lt;函数名&gt;(&lt;参数（0个或多个）&gt;): ​ &lt;函数体&gt; ​ return &lt;返回值&gt; —函数定义时，所指定的参数是一种占位符； —函数定义后，如果不经过调用，不会被执行； —函数定义时，参数是输入、函数体是处理、结果是输出（IPO）； 函数的使用及调用过程： 调用是运行函数代码的方式：调用时要给出实际参数；实际参数替换定义中的参数；函数调用后得到返回值； 函数的参数传递： 参数个数：函数可以有参数，也可以没有，但必须保留括号； 可选参数传递：函数定义时可以为某些参数指定默认值，构成可选参数； def &lt;函数名&gt;(&lt;非可选参数&gt;, &lt;可选参数&gt;)： ​ &lt;函数体&gt; return &lt;返回值&gt; 可变参数传递：函数定义时可以设计可变数量参数，既不确定参数总数量； def &lt;函数名&gt;(&lt;参数&gt;, *b)： ​ &lt;函数体&gt; return &lt;返回值&gt; 参数传递的两种方式 ：函数调用时，参数可以按照位置或名称方式传递； 函数的返回值：（函数可以返回0个或多个结果） return保留字用来传递返回值； 函数可以有返回值，也可以没有，可以有return，也可以没有； return可以传递0个返回值，也可以传递任意多个返回值； 局部变量和全局变量：局部变量和全局变量是不同变量； —局部变量是函数内部的占位符，与全局变量可能重名但不同； —函数运算结束后，局部变量被释放； —可以使用global保留字在函数内部使用全局变量； 局部变量为组合数据类型且未创建，等同于全局变量；使用规则： —基本数据类型，无论是否重名，局部变量与全局变量不同； —可以通过global保留字在函数内部声明全局变量； —组合数据类型，如果局部变量未真实创建，则是全局变量； lambda函数（返回函数名作为结果）：lambda函数是一种匿名函数，即没有名字的函数；—使用lambda保留字定义，函数名是返回结果；—lambda函数用于定义简单的、能够在一行内表示的函数； &lt;函数名&gt; = lambda &lt;参数&gt; : &lt;表达式&gt; 等价于 def &lt;函数名&gt; (&lt;参数&gt;) : ​ &lt;函数体&gt; ​ return &lt;返回值&gt; 谨慎使用lambda函数： —lambda函数主要用作一些特定函数或方法的参数； —lambda函数有一些固定使用方式，建议逐步掌握； —一般情况，建议使用def定义的普通函数； 2、理解方法思维： 模块化思维：确定模块接口，封装功能； 规则化思维：抽象过程为规则，计算机自动执行； 化繁为简：将大功能变为小功能组合，分而治之； 3、代码复用与函数递归： 代码复用与模块化设计： 代码复用（把代码当成资源进行抽象）： —代码资源化：程序代码是一种用来表达计算的“资源”； —代码抽象化：使用函数等方法对代码赋予更高级别的定义； —代码复用：用一份代码在需要时可以被重复使用； 函数和对象是代码复用的两种主要形式； 模块化设计（分而治之）： —通过函数或对象封装将程序划分为模块及模块间的表达； —具体包括：主程序、子程序和子程序间关系； —分而治之：一种分而治之、分层抽象、体系化的设计思想； 模块内部紧耦合、模块之间松耦合； 函数递归（函数定义中调用自身的方式）：类似数学归纳法1） 递归是数学归纳法编程的一种体现； 两个关键特征：链条（计算过程存在递归链条）、基例（存在一个或多个不需要再次递归的基例）； 函数递归的调用过程： 递归的实现：函数 + 分支语句 —递归本身是一个函数，需要函数定义方式描述； —函数内部，采用分支语句对输入参数进行判断； —基例和链条，分别编写对应代码； 函数递归实例解析：字符串反转：s[::-1]，斐波那契数列，汉诺塔； 4、PyInstaller库（将.py源代码转换成无需源代码的可执行文件）使用：pyinstaller -F &lt;文件名.py&gt; 组合数据类型1、集合类型及操作： 集合类型定义：集合是多个元素的无序组合；—集合类型与数学中的集合概念一致；—集合元素之间无序，每个元素唯一，不存在相同元素；—集合元素不可更改，不能是可变数据类型；—集合用大括号{}表示，元素间用逗号分隔；—建立集合类型用{}或set();—建立空集合类型，必须使用set(); 集合操作符：6个操作符： 4 个增强操作符： 集合处理方法： 集合类型应用场景：包含关系比较、数据去重（集合类型所有元素无重复）； 2、序列类型及操作： 序列类型定义：序列是具有先后关系的一组元素；—序列是一维元素向量，元素类型可以不同；—类似数学元素序列：s0， S1, … , Sn-1;—元素间由序号引导，通过下标访问序列的特定元素；序列是一个基类类型（字符串类型、元组类型、列表类型）； 序列处理函数及方法：6个操作符： 5个函数和方法： 元组类型及操作：元组是序列类型的一种扩展；—元组是一种序列类型，一旦创建就不能被修改；—使用小括号（）或tuple（）创建，元素间用逗号，分隔；—可以使用或不使用小括号；元组继承序列类型的全部通用操作；元组因为创建后不能修改，因此没有特殊操作；使用或不使用小括号； 列表类型及操作：列表是序列类型的一种扩展，十分常用；—列表是一种序列类型，创建后可以随意被修改；—使用方括号[]或list（）创建，元素间用逗号，分隔；—可以使用或不使用小括号；方括号[]真正创建一个列表，赋值仅传递引用；列表类型操作函数和方法：序列类型应用场景： 元组用于元素不改变的应用场景，更多用于固定搭配场景（数据保护：如果不希望数据被程序所改变，转换成元组类型）； 列表更加灵活，它是常见的序列类型； 最主要作用：表示一组有序数据，进而操作它们； 3、字典类型及操作： 字典类型定义：理解”映射“：映射是一种键（索引）和值（数据）的对应；—字典类型是“映射”的体现；—键值对：键是数据索引的扩展；—字典是键值对的集合，键值对之间无序；—采用大括号{}和dict（）创建，键值对用冒号：表示；{&lt;键1&gt; : &lt;值1&gt;, &lt;键2&gt; : &lt;值2&gt;, …, &lt;键n&gt; : &lt;值ni&gt;}在字典变量中，通过键获得值：&lt;字典变量&gt; = {&lt;键1&gt; : &lt;值1&gt;, … , &lt;键n&gt; : &lt;值n&gt;}&lt;值&gt; = &lt;字典变量&gt; [&lt;键&gt;] &lt;字典变量&gt; [&lt;键&gt;] = &lt;值&gt;[] 用来向字典变量中索引或增加元素； 字典处理函数及方法： 字典类型应用场景：—映射无处不在，键值对无处不在；—例如：统计数据出现的次数，数据是键，次数是值；—最主要作用：表达键值对数据，进而操作它们； 4、jieba库（优秀的中文分词第三方库）的使用： jieba分词依靠中文词库：利用一个中文词库，确定汉字之间的关联概率；汉字间概率大的组成词组，形成分词结果；除了分词，用户还可以添加自定义的词组； 使用说明：精确模式（把文本精确的切分开，不存在冗余单词）；全模式（把文本中所有可能的词语都扫描出来，有冗余）；搜索引擎模式（在精确模式基础上，对长词再次切分）； 文件和数据格式化1、文件操作基础： 文件是数据的抽象和集合（展现形态：文本文件和二进制文件）； 文本文件：由单一特定编码组成的文件（txt、.py）； 二进制文件：直接由0和1组成，无统一的字符编码（.png、视频等）； 文件的打开关闭：打开-操作-关闭； 123#文件的打开 &lt;变量名&gt; = open(&lt;文件名&gt;, &lt;打开模式&gt;)#打开模式：只读（‘r’）、覆盖写（’w‘）、创建写（’x‘）、追加写（‘a’）、二进制文件模式（‘b’）、文本文件模式（‘t’）、与r/w/x/a一同使用，在原有功能基础上增加同时读写功能（‘+’）#文件的关闭 &lt;变量名&gt;.close() 文件的读取： 文件的写入： 2、自动化思维（数据和功能分离，数据驱动的自动进行）、接口化设计（格式化设计接口，清晰明了）； 3、一维数据格式化： 一维数据（由对等关系的有序或无序数据构成，采用线性方式组织）-对应列表、数组和集合等概念；二维数据（由多个一维数据构成，是一维数据的组合形式）-表格是典型的二维数据； 数据的操作周期：存储（存储格式）-表示（数据类型）-操作（操作方式）； 一维数据的表示： 如果数据间有序：使用列表类型； 如果数据间无序：使用集合类型； 一维数据的存储： 空格分隔（数据中不能存在空格）； 逗号分隔； 其他方式（使用其他符号或符号组合分隔，建议采用特殊符号）； 一维数据的处理： 将存储的数据读入程序 将程序表示的数据写入文件； 4、二维数据格式化： 二维数据的表示： 列表类型可以表达二维数据； 使用二维列表； CSV格式与二维数据的存储：CSV（Comma-Separated Values）数据存储格式： 每行一个一维数据，采用逗号分隔，无空行； 如果某个元素缺失，逗号仍要保留； 逗号为英文半角逗号，逗号与数据之间无额外空格； 二维数据的存储： 按行存或者按列存都可以，具体由程序决定； 一般索引习惯，先行后列； 二维数据的处理：for循环 + .split() 和 .join() 5、wordcloud库：是优秀的词云展示第三方库； 词云以词语为基本单位，更加直观和艺术的展示文本； 库基本使用： wordcloud.WordCloud()代表一个文本对应的词云； 可以根据文本中词语出现的频率等参数绘制词云； 绘制词云的形状、尺寸和颜色都可以设定； 配置参数、加载文本、输出文件； python的wordcloud默认字体不支持中文； 程序设计方法学 1、自顶向下的设计思维：分而治之；自底向上的执行思维：模块化集成； 2、计算思维：抽象问题的计算过程，利用计算机自动化求解； 3、用户体验：进度展示、异常处理等； 4、os库的基本使用： 123os.path.abspath(path)#返回path在当前系统中的绝对路径；os.getcwd()#返回程序的当前路径； 总结python基础语法： 基本数据类型：整数、浮点数、复数、字符串； 程序的控制结构：分支结构与异常处理、遍历循环、无限循环； 函数和代码复用：函数定义和使用、函数递归； 组合数据类型：集合类型、序列类型（元组和列表）、字典类型； 文件和数据格式化：文件的使用、一二维数据的表示存储和处理。 参考：MOOC大学北京理工大学嵩天老师课程笔记","comments":true,"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"SQL必知必会","date":"2019-03-22T06:22:36.000Z","path":"2019/03/22/SQL必知必会/","text":"SQL必知必会总结 About1、数据库是一个以某种有组织的方式存储的数据集合；表是一种结构化的文件，可用来存储某种特定类型的数据；模式 ：关于数据库和表的布局及特性的信息 ； 2、主键（primary key）：一列（或一组列），其值能够唯一标识表中每一行 ； 任意两行都不具有相同的主键值 ； 每一行都必须具有一个主键值（主键列不允许NULL值）； 主键列中的值不允许修改或更新； 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）； ​ 主键通常定义在表的一列上，但并不是必需这么做，也可以一起使用多个列作为主键。在使用多列作为主键时，上述条件必须应用到所有列， 所有列值的组合必须是唯一的（但单个列的值可以不唯一）； 3、SQL是结构化查询语言（Structured Query Language）的缩写，SQL是一种专门用来与数据库沟通的语言； 检索数据1、SQL语句不区分大小写 ； 检索单个列 SELECT prod_name FROM Products; 检索多个列 SELECT prod_id, prod_name, prod_price FROM Products; 检索所有列 SELECT * FROM Products; 检索不同的值 （ DISTINCT） SELECT DISTINCT vend_id FROM Products; 限制结果（LIMIT） SELECT prod_name FROM Products LIMIT 5; LIMIT 5 OFFSET 5 SELECT prod_name FROM Products LIMIT 5 OFFSET 5; 2、总结： 一般而言，除非你确实需要表中的每一列，否则最好别使用*通配符。虽然使用通配符能让你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能； 不能部分使用DISTINCT ：DISTINCT关键字作用于所有的列，不仅仅是跟在其后的那一列； LIMIT 5指示MySQL等DBMS返回不超过5行的数据，LIMIT 5 OFFSET 5 （LIMIT 5, 5）指示MySQL等DBMS返回从第5行起的5行数据。第一个数字是指从哪儿开始，第二个数字是检索的行数。第一个被检索的行是第0行，而不是第1行 ； 排序检索数据1、ORDER BY子句，根据需要排序检索出的数据； 排序数据 SELECT prod_name FROM Products ORDER BY prod_name; 按多个列排序 SELECT prod_id, prod_price, prod_name FROM Products ORDER BY prod_price, prod_name; 按列位置排序 SELECT prod_id, prod_price, prod_name FROM Products ORDER BY 2, 3; 指定排序方向 SELECT prod_id, prod_price, prod_name FROM Products ORDER BY prod_price DESC; 2、总结： ORDER BY子句的位置 ：在指定一条ORDER BY子句时，应该保证它是SELECT语句中最后一条子句。如果它不是最后的子句，将会出现错误消息； 通过非选择列进行排序： 通常，ORDER BY子句中使用的列将是为显示而选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的； 按列位置排序：指定的是选择列的相对位置而不是列名 ； 数据排序不限于升序排序（从A到Z），这只是默认的排序顺序。还可以使用ORDER BY子句进行降序（从Z到A）排序。为了进行降序排序，必须指定DESC关键字； 在多个列上降序排序： 如果想在多个列上进行降序排序，必须对每一列指定DESC关键字；（DESC是DESCENDING的缩写，与DESC相对的是ASC（或ASCENDING），升序是默认的 ）； 过滤数据1、WHERE子句指定搜索条件 ； 检查单个值 SELECT prod_name, prod_price FROM Products WHERE prod_price = 3.49; 检查单个值 SELECT prod_name, prod_price FROM Products WHERE prod_price &lt; 10; 不匹配检查 SELECT vend_id, prod_name FROM Products WHERE vend_id ！= ‘DLL01’; 范围值检查 SELECT prod_name, prod_price FROM Products WHERE prod_price BETWEEN 5 AND 10; 空值检查 SELECT prod_name FROM Products WHERE prod_price IS NULL; 2、总结： WHERE子句的位置 ：在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后，否则将会产生错误； 在使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用AND关键字分隔。BETWEEN匹配范围 中所有的值，包括指定的开始值和结束值； NULL和非匹配 ：通过过滤选择不包含指定值的所有行时，你可能希望返回含NULL值的行。但是这做不到。因为未知（unknown）有特殊的含义，数据库不知道它们是否匹配，所以在进行匹配过滤或非匹配过滤时，不会返回这些结果； 高级数据过滤1、为了进行更强的过滤控制，SQL允许给出多个WHERE子句。这些子句有两种使用方式，即以AND子句或OR子句的方式使用 ； 2、求值顺序 ： SQL（像多数语言一样）在处理OR操作符前，优先处理AND操作符。在WHERE子句中使用圆括号 ：任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符 ； 3、IN操作符 ：用来指定条件范围，范围中的每个条件都可以进行匹配。IN取一组由逗号分隔、括在圆括号中的合法值； 12345SELECT prod_name, prod_priceFROM ProductsWHERE vend_id IN ( &apos;DLL01&apos;, &apos;BRS01&apos; )ORDER BY prod_name;#IN操作符完成了与OR相同的功能 IN操作符优点为 ： 在有很多合法选项时，IN操作符的语法更清楚，更直观 ； 在与其他AND和OR操作符组合使用IN时，求值顺序更容易管理； IN操作符一般比一组OR操作符执行得更快； IN的最大优点是可以包含其他SELECT语句，能够更动态地建立WHERE子句； 4、NOT操作符：否定其后所跟的任何条件； 1234SELECT prod_nameFROM ProductsWHERE NOT vend_id = &apos;DLL01&apos;ORDER BY prod_name; 用通配符进行过滤1、LIKE操作符 ：为在搜索子句中使用通配符，必须使用LIKE操作符（后跟的搜索模式利用通配符匹配而不是简单的相等匹配进行比较 ） ；利用通配符，可以创建比较特定数据的搜索模式； 通配符搜索只能用于文本字段（串），非文本数据类型字段不能使用通配符搜索； 百分号（%）通配符 ：%表示任何字符出现任意次数； 除了能匹配一个或多个字符外，%还能匹配0个字符。%代表搜索模式中给定位置的0个、1个或多个字符。 注意NULL ：通配符%看起来像是可以匹配任何东西，但有个例外，这就是NULL； 123SELECT prod_id, prod_nameFROM ProductsWHERE prod_name LIKE &apos;Fish%&apos;; 下划线（_）通配符：只匹配单个字符，而不是多个字符； 通配符搜索一般比前面讨论的其他搜索要耗费更长的处理时间 ； —不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符； —在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的； —仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据； 创建计算字段1、计算字段：计算字段并不实际存在于数据库表中，计算字段是运行时在SELECT语句内创建的； 2、拼接字段 ： 拼接（concatenate）：将值联结到一起（将一个值附加到另一个值）构成单个值—concat()； 123SELECT CONCAT(TRIM(vend_name),&apos; (&apos;,TRIM(vend_country),&apos;)&apos;)#TRIM()---去掉左右两边空格FROM VendorsORDER BY vend_name; 别名（alias）是一个字段或值的替换名。别名用AS关键字赋予； 12345SELECT CONCAT(TRIM(vend_name),&apos; (&apos;,TRIM(vend_country),&apos;)&apos;)AS vend_titleFROM VendorsORDER BY vend_name; #计算字段之后跟了文本AS vend_title，它指示SQL创建一个包含指定计算结果的名为vend_title的计算字段，现在列名为vend_title，任何客户端应用都可以按名称引用这个列，就像它是一个实际的表列一样。 AS通常可选：AS关键字是可选的，不过最好使用它，这被视为一条最佳实践 ； 别名的其他用途：常见的用途包括在实际的表列名包含不合法的字符（如空格）时重新命名它，在原来的名字含混或容易误解时扩充它； 3、执行算术计算：计算字段的另一常见用途是对检索出的数据进行算术计算； 123SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_priceFROM OrderItemsWHERE order_num = 20008; 使用数据处理函数1、SQL也可以用函数来处理数据。函数一般是在数据上执行的，为数据的转换和处理提供了方便； 2、大多数SQL实现支持以下类型的函数： 用于处理文本字符串（如删除或填充值，转换值为大写或小写）的文本函数； 用于在数值数据上进行算术操作（如返回绝对值，进行代数运算）的数值函数； 用于处理日期和时间值并从这些值中提取特定成分（如返回两个日期之差，检查日期有效性）的日期和时间函数； 返回DBMS正使用的特殊信息（如返回用户登录信息）的系统函数； 文本处理函数 SELECT vend_name, UPPER(vend_name) AS vend_name_upcase 日期和时间处理函数 SELECT order_num FROM Orders WHERE YEAR(order_date) = 2012; 数值处理函数 SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法，SOUNDEX考虑了类似的发音字符和音节，使得能对字符串进行发音比较而不是字母比较 ； 123SELECT cust_name, cust_contactFROM CustomersWHERE SOUNDEX(cust_contact) = SOUNDEX(&apos;Michael Green&apos;) 汇总数据1、聚集函数：汇总数据而不用把它们实际检索出来，为此SQL提供了专门的函数。使用这些函数，SQL查询可用于检索数据，以便分析和报表生成； 聚集函数（aggregate function） 对某些行运行的函数，计算并返回一个值 ； AVG（）：返回某列的平均值—通过对表中行数计数并计算其列值之和，求得该列的平均值； 只用于单个列：AVG()只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个AVG()函数。 12SELECT AVG(prod_price) AS avg_priceFROM Products; COUNT（）：确定表中行的数目或符合特定条件的行的数目； COUNT()函数有两种使用方式： 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值； 使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值； 123456#利用COUNT(*)对所有行计数，不管行中各列有什么值SELECT COUNT(*) AS num_custFROM Customers;#COUNT(cust_email)对cust_email列中有值的行进行计数SELECT COUNT(cust_email) AS num_custFROM Customers; MAX（）：返回某列的最大值，要求指定列名 ； 123#MAX()函数忽略列值为NULL的行SELECT MAX(prod_price) AS max_priceFROM Products; MIN（）：返回某列的最小值，要求指定列名 ； 123#MIN()函数忽略列值为NULL的行SELECT MIN(prod_price) AS min_priceFROM Products; SUM（）：返回指定列值的和（总计）； 12345678#SUM()函数忽略列值为NULL的行SELECT SUM(quantity) AS items_orderedFROM OrderItemsWHERE order_num = 20005;#SUM()也可以用来合计计算值SELECT SUM(item_price*quantity) AS total_priceFROM OrderItemsWHERE order_num = 20005; 2、聚集不同值：只包含不同的值，指定DISTINCT参数； 1234SELECT AVG(DISTINCT prod_price) AS avg_priceFROM ProductsWHERE vend_id = &apos;DLL01&apos;;#DISTINCT不能用于COUNT(*)，DISTINCT必须使用列名 3、组合聚集函数： 12345SELECT COUNT(*) AS num_items,MIN(prod_price) AS price_min,MAX(prod_price) AS price_max,AVG(prod_price) AS price_avgFROM Products; 分组数据1、数据分组 ：使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算； 2、创建分组：使用SELECT语句的GROUP BY子句建立的； 123SELECT vend_id, COUNT(*) AS num_prodsFROM ProductsGROUP BY vend_id; GROUP BY子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组； 如果在GROUP BY子句中嵌套了分组，数据将在最后指定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）； GROUP BY子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子 句中指定相同的表达式。不能使用别名； 大多数SQL实现不允许GROUP BY列带有长度可变的数据类型（如文本或备注型字段）； 除聚集计算语句外，SELECT语句中的每一列都必须在GROUP BY子句中给出 ； 如果分组列中包含具有NULL值的行，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组； GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前 ； 3、过滤分组 ：HAVING子句 ，WHERE过滤行，而HAVING过滤分组； 1234SELECT cust_id, COUNT(*) AS ordersFROM OrdersGROUP BY cust_idHAVING COUNT(*) &gt;= 2; HAVING和WHERE的差别：WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤； 123456#第一行是使用了聚集函数的基本SELECT语句，WHERE子句过滤所有prod_price至少为4的行，然后按vend_id分组数据，HAVING子句过滤计数为2或2以上的分组。SELECT vend_id, COUNT(*) AS num_prodFROM ProductsWHERE prod_price &gt;= 4GROUP BY vend_idHAVING COUNT(*) &gt;= 2 使用HAVING和WHERE：HAVING与WHERE非常类似，如果不指定GROUP BY，则大多数DBMS会同等对待它们。不过，使用HAVING时应该结合GROUP BY子句，而WHERE子句用于标准的行级过滤； 4、分组和排序：GROUP BY和ORDER BY经常完成相同的工作，但它们非常不同； ORDER BY GROUP BY 对产生的输出排序 对行分组，但输出可能不是分组的顺序 任意列都可以使用（甚至非选择的列也可以使用） 只可能使用选择列表达式，而且必须使用每个选择列表达式 不一定需要 如果与聚集函数一起使用列（或表达式），则必须使用 不要忘记ORDER BY：一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据； 12345SELECT order_num, COUNT(*) AS itemsFROM OrderItemsGROUP BY order_numHAVING COUNT(*) &gt;= 3ORDER BY items, order_num; 5、SELECT子句顺序： 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 使用子查询1、子查询：嵌套在其他查询中的查询； 2、利用子查询进行过滤： 1234567SELECT cust_name, cust_contactFROM CustomersWHERE cust_id IN (SELECT cust_idFROM OrdersWHERE order_num IN (SELECT order_numFROM OrderItemsWHERE prod_id = &apos;RGAN01&apos;)); 在WHERE子句中使用子查询能够编写出功能很强且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多的子查询； 只能是单列：作为子查询的SELECT语句只能查询单个列。企图检索多个列将返回错误； 子查询和性能：这里给出的代码有效，并且获得了所需的结果。但是，使用子查询并不总是执行这类数据检索的最有效方法； 3、作为计算字段使用子查询：使用子查询的另一方法是创建计算字段； 12345678#不是解决这种数据检索的最有效方法SELECT cust_name,cust_state,(SELECT COUNT(*)FROM OrdersWHERE Orders.cust_id = Customers.cust_id) AS ordersFROM CustomersORDER BY cust_name; 联结表1、联结：SQL最强大的功能之一就是能在数据查询的执行中联结（join）表。联结是利用SQL的SELECT能执行的最重要的操作； 关系表：相同的数据出现多次决不是一件好事，这是关系数据库设计的基础。关系表的设计就是要把信息分解成多个表，一类数据一个表。各表通过某些共同的值互相关联（所以才叫关系数据库）； 关系数据可以有效地存储，方便地处理。因此，关系数据库的可伸缩性远比非关系数据库要好。可伸缩（scale）： 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称为可伸缩性好（scale well）； 如果数据存储在多个表中，怎样用一条SELECT语句就检索出数据呢？（使用联结）； 联结是一种机制，用来在一条SELECT语句中关联表，因此称为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行 ； 2、创建联结：指定要联结的所有表以及关联它们的方式即可 ； 123SELECT vend_name, prod_name, prod_priceFROM Vendors, ProductsWHERE Vendors.vend_id = Products.vend_id; 3、WHERE子句的重要性：在联结两个表时，实际要做的是将第一个表中的每一行与第二个表中的每一行配对。WHERE子句作为过滤条件，只包含那些匹配给定条件（这里是联结条件）的行。没有WHERE子句， 第一个表中的每一行将与第二个表中的每一行配对，而不管它们逻辑上是否能配在一起； 笛卡儿积（cartesian product）：由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数； 123SELECT vend_name, prod_name, prod_priceFROM Vendors, Products;#要保证所有联结都有WHERE子句，否则DBMS将返回比想要的数据多得多的数据 内联结（inner join）：目前为止使用的联结称为等值联结（equijoin），它基于两个表之间的相等测试，这种联结也称为内联结； 123SELECT vend_name, prod_name, prod_priceFROM Vendors INNER JOIN ProductsON Vendors.vend_id = Products.vend_id; 4、联结多个表 ：SQL不限制一条SELECT语句中可以联结的表的数目。创建联结的基本规则也相同，首先列出所有表，然后定义表之间的关系； 12345SELECT prod_name, vend_name, prod_price, quantityFROM OrderItems, Products, VendorsWHERE Products.vend_id = Vendors.vend_idAND OrderItems.prod_id = Products.prod_idAND order_num = 20007; 性能考虑：DBMS在运行时关联指定的每个表，以处理联结。这种处理可能非常耗费资源，因此应该注意，不要联结不必要的表。联结的表越多，性能下降越厉害； 执行任一给定的SQL操作一般不止一种方法。很少有绝对正确或绝对错误的方法。性能可能会受操作类型、所使用的DBMS、表中数据量、是否存在索引或键等条件的影响。 创建高级联结1、使用表别名：SQL除了可以对列名和计算字段使用别名，还允许给表名起别名； 缩短SQL语句； 允许在一条SELECT语句中多次使用相同的表； 1234567#表别名不仅能用于WHERE子句，还可以用于SELECT的列表、ORDER BY子句以及其他语句部分#表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户端。SELECT cust_name, cust_contactFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id = O.cust_idAND OI.order_num = O.order_numAND prod_id = &apos;RGAN01&apos;; 2、使用不同类型的联结： 自联结： 12345#许多DBMS处理联结远比处理子查询快得多SELECT c1.cust_id, c1.cust_name, c1.cust_contactFROM Customers AS c1, Customers AS c2WHERE c1.cust_name = c2.cust_nameAND c2.cust_contact = &apos;Jim Jones&apos;; 自然联结：排除多次出现，使每一列只返回一次 ； 123456SELECT C.*, O.order_num, O.order_date,OI.prod_id, OI.quantity, OI.item_priceFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id = O.cust_idAND OI.order_num = O.order_numAND prod_id = &apos;RGAN01&apos;; 外联结：联结包含了那些在相关表中没有关联行的行； 1234#在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）SELECT Customers.cust_id, Orders.order_numFROM Customers LEFT OUTER JOIN OrdersON Customers.cust_id = Orders.cust_id; 3、 使用带聚集函数的联结 ： 1234567891011SELECT Customers.cust_id,COUNT(Orders.order_num) AS num_ordFROM Customers INNER JOIN OrdersON Customers.cust_id = Orders.cust_idGROUP BY Customers.cust_id;#使用左外部联结来包含所有顾客，甚至包含那些没有任何订单的顾客SELECT Customers.cust_id,COUNT(Orders.order_num) AS num_ordFROM Customers LEFT OUTER JOIN OrdersON Customers.cust_id = Orders.cust_idGROUP BY Customers.cust_id; 4、使用联结和联结条件：联结及其使用的要点； 注意所使用的联结类型。一般我们使用内联结，但使用外联结也有效； 保证使用正确的联结条件（不管采用哪种语法），否则会返回不正确的数据；。 应该总是提供联结条件，否则会得出笛卡儿积； 在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前分别测试每个联结。这会使故障排除更为简单； 组合查询1、组合查询：多数SQL查询只包含从一个或多个表中返回数据的单条SELECT语句。但是，SQL也允许执行多个查询（多条SELECT语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）； 主要有两种情况需要使用组合查询： 在一个查询中从不同的表返回结构数据； 对一个表执行多个查询，按一个查询返回数据； 2、创建组合查询：可用UNION操作符来组合数条SQL查询。利用UNION，可给出多条SELECT语句，将它们的结果组合成一个结果集； 使用UNION ：给出每条SELECT语句，在各条语句之间放上关键字UNION ； 1234567SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN (&apos;IL&apos;,&apos;IN&apos;,&apos;MI&apos;)UNIONSELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_name = &apos;Fun4All&apos;; UNION规则： UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合四条SELECT语句，将要使用三个UNION关键字）； UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）； 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）； 包含或取消重复的行：使用UNION时，重复的行会被自动取消；如果想返回所有的匹配行，可使用UNION ALL而不是UNION； 对组合查询结果排序：在用UNION组合查询时，只能使用一条ORDER BY子句，它必须位于最后一条SELECT语句之后； 12345678SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN (&apos;IL&apos;,&apos;IN&apos;,&apos;MI&apos;)UNIONSELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_name = &apos;Fun4All&apos;ORDER BY cust_name, cust_contact; 插入数据1、数据插入：INSERT用来将行插入（或添加）到数据库表，插入有几种方式 ； 插入完整的行； 1234567#各列必须以它们在表定义中出现的次序填充，不安全，应该尽量避免使用INSERT INTO CustomersVALUES(&apos;1000000006&apos;,&apos;Toy Land&apos;,&apos;123 Any Street&apos;,&apos;New York&apos;,&apos;NY&apos;,&apos;11111&apos;,&apos;USA&apos;,NULL,NULL); #安全INSERT INTO Customers(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country, cust_contact,cust_email)VALUES(&apos;1000000006&apos;,&apos;Toy Land&apos;,&apos;123 Any Street&apos;,&apos;New York&apos;,&apos;NY&apos;,&apos;11111&apos;,&apos;USA&apos;,NULL,NULL); 插入行的一部分：使用这种语法，还可以省略列，这表示可以只给某些列提供值，给其他列不提供值； 12INSERT INTO Customers(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)VALUES(&apos;1000000006&apos;,&apos;Toy Land&apos;,&apos;123 Any Street&apos;,&apos;New York&apos;,&apos;NY&apos;,&apos;11111&apos;,&apos;USA&apos;); 如果表的定义允许，则可以在INSERT操作中省略某些列。省略的列必须满足以下某个条件： 该列定义为允许NULL值（无值或空值）； 在表定义中给出默认值。这表示如果不给出值，将使用默认值 ； 插入检索出的数据：将SELECT语句的结果插入表中，这就是所谓的INSERT SELECT。顾名思义，它是由一条INSERT语句和一条SELECT语句组成的； 1234567#这条语句将插入多少行呢？这依赖于CustNew表有多少行INSERT INTO Customers( cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state, cust_zip,cust_country)SELECT cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state, cust_zip,cust_countryFROM CustNew; INSERT通常只插入一行。要插入多行，必须执行多个INSERT语句。INSERT SELECT是个例外，它可以用一条INSERT插入多行，不管SELECT语句返回多少行，都将被INSERT插入； 2、从一个表复制到另一个表 ：使用SELECT INTO语句。与INSERT SELECT将数据添加到一个已经存在的表不同，SELECT INTO将数据复制到一个新表（有的DBMS可以覆盖已经存在的表，这依赖于所使用的具体DBMS）； INSERT SELECT与SELECT INTO：它们之间的一个重要差别是前者导出数据，而后者导入数据 ； 123#这条语句创建一个名为CustCopy的新表，并把Customers表的整个内容复制到新表中。CREATE TABLE CustCopy ASSELECT * FROM Customers; 更新和删除数据1、更新数据：更新（修改）表中的数据，可以使用UPDATE语句。有两种使用UPDATE的方式； 基本的UPDATE语句由三部分组成：要更新的表 、列名和它们的新值、确定要更新哪些行的过滤条件； 更新表中的特定行； 123456UPDATE CustomersSET cust_contact = &apos;Sam Roberts&apos;,cust_email = &apos;sam@toyland.com&apos;WHERE cust_id = &apos;1000000006&apos;#要删除某个列的值，可设置它为NULL（假如表定义允许NULL值）#其中NULL用来去除cust_email列中的值。这与保存空字符串很不同（空字符串用&apos;&apos;表示，是一个值），而NULL表示没有值 更新表中的所有行；（不加where子句） 2、删除数据 ： 从一个表中删除（去掉）数据，使用DELETE语句。有两种使用DELETE的方式； 从表中删除特定的行； 123#DELETE不需要列名或通配符。DELETE删除整行而不是删除列DELETE FROM CustomersWHERE cust_id = &apos;1000000006&apos;; 删除表的内容而不是表：DELETE语句从表中删除行，甚至是删除表中所有行。但是，DELETE不删除表本身； 更快的删除：如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，而速度更快（因为不记录数据的变动）； 从表中删除所有行； 3、更新和删除的指导原则 ： 除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句 ； 保证每个表都有主键（如果忘记这个内容，请参阅第12课），尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）； 在UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确； 创建和操纵表1、创建表：使用SQL的CREATE TABLE语句 ； 表创建基础： 12345678CREATE TABLE Products(prod_id CHAR(10) NOT NULL,vend_id CHAR(10) NOT NULL,prod_name CHAR(254) NOT NULL,prod_price DECIMAL(8,2) NOT NULL,prod_desc VARCHAR(1000) NULL); 使用NULL值：主键和NULL值— 主键是其值唯一标识表中每一行的列。只有不允许NULL值的列可作为主键，允许NULL值的列不能作为唯一标识 ； 指定默认值：用关键字DEFAULT指定； 12345678CREATE TABLE OrderItems(order_num INTEGER NOT NULL,order_item INTEGER NOT NULL,prod_id CHAR(10) NOT NULL,quantity INTEGER NOT NULL DEFAULT 1,item_price DECIMAL(8,2) NOT NULL); 2、更新表：使用ALTER TABLE语句； 1234ALTER TABLE VendorsADD vend_phone CHAR(20);ALTER TABLE VendorsDROP COLUMN vend_phone; 3、删除表：使用DROP TABLE语句； 1DROP TABLE CustCopy; 4、重命名表 ：使用RENAME语句，要求指定旧表名和新表名； 使用视图1、视图：视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询； 视图的一些常见应用 ： 重用SQL语句； 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道其基本查询细节； 使用表的一部分而不是整个表； 保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限 ； 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据； 视图仅仅是用来查看存储在别处数据的一种设施。视图本身不包含数据，因此返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据； 视图的规则和限制： 与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）； 对于可以创建的视图数目没有限制； 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。所允许的嵌套层数在不同的DBMS中有所不同（嵌套视图可能会严重降低查询的性能，因此在产品环境中使用之前，应该对其进行全面测试）； 视图不能索引，也不能有关联的触发器或默认值； 2、 创建视图：用CREATE VIEW语句来创建 ，只能用于创建不存在的视图； ​ 删除视图，可以使用DROP语句，其语法为DROP VIEW viewname；覆盖（或更新）视图，必须先删除它，然后再重新创建； 利用视图简化复杂的联结 ： 123456#创建一个名为ProductCustomers的视图，它联结三个表CREATE VIEW ProductCustomers ASSELECT cust_name, cust_contact, prod_idFROM Customers, Orders, OrderItemsWHERE Customers.cust_id = Orders.cust_idAND OrderItems.order_num = Orders.order_num; 用视图重新格式化检索出的数据： 1234CREATE VIEW VendorLocations AS SELECT CONCAT(vend_name,&apos;(&apos;,RTRIM(vend_country),&apos;)&apos;) AS vend_titleFROM Vendors 用视图过滤不想要的数据 ： 1234CREATE VIEW CustomerEMailList ASSELECT cust_id, cust_name, cust_emailFROM CustomersWHERE cust_email IS NOT NULL; 使用视图与计算字段： 1234567CREATE VIEW OrderItemsExpanded ASSELECT order_num,prod_id,quantity,item_price,quantity*item_price AS expanded_priceFROM OrderItems; ​ 视图可极大地简化复杂数据的处理； 总结：视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种封装SELECT语句的层次，可用来简化数据处理，重新格式化或保护基础数据； 使用存储过程1、存储过程 ：存储过程就是为以后使用而保存的一条或多条SQL语句。可将其视为批文件，虽然它们的作用不仅限于批处理； 2、为什么要使用存储过程： 通过把处理封装在一个易用的单元中，可以简化复杂的操作； 由于不要求反复建立一系列处理步骤，因而保证了数据的一致性。如果所有开发人员和应用程序都使用同一存储过程，则所使用的代码都是相同的；（防止错误） 简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，那么只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化 ；（安全性） 3、执行存储过程 ：EXECUTE，EXECUTE接受存储过程名和需要传递给它的任何参数； 12345#执行一个名为AddNewProduct的存储过程，将一个新产品添加到Products表中EXECUTE AddNewProduct( &apos;JTS01&apos;,&apos;Stuffed Eiffel Tower&apos;,6.49,&apos;Plush stuffed toy with the text LaTour Eiffel in red white and blue&apos; ); 存储过程所完成的工作： 验证传递的数据，保证所有4个参数都有值 ； 生成用作主键的唯一ID； 将新产品插入Products表，在合适的列中存储生成的主键和传递的数据； 4、创建存储过程：CREATE PROCEDURE； 管理事务处理1、事务处理（transaction processing）：通过确保成批的SQL操作要么完全执行，要么完全不执行，来维护数据库的完整性； 事务处理是一种机制，用来管理必须成批执行的SQL操作，保证数据库不包含不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止，它们要么完全执行，要么完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表；如果发生错误，则进行回退（撤销），将数据库恢复到某个已知且安全的状态； 2、使用事务处理时，有几个反复出现的关键词： 事务（transaction）指一组SQL语句； 回退（rollback）指撤销指定SQL语句的过程； 提交（commit）指将未存储的SQL语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），可以对它发布回退（与回退整个事务处理不同）； 事务处理用来管理INSERT、UPDATE和DELETE语句。不能回退SELECT语句（回退SELECT语句也没有必要），也不能回退CREATE或DROP操作。事务处理中可以使用这些语句，但进行回退时，这些操作也不撤销； 3、控制事务处理：管理事务的关键在于将SQL语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退； 1START TRANSACTION COMMITT用于保存更改，ROLLBACK用于撤销； 使用ROLLBACK； 使用COMMIT； 使用保留点：要支持回退部分事务，必须在事务处理块中的合适位置放置占位符。这样，如果需要回退，可以回退到某个占位符。 在SQL中，这些占位符称为保留点； 创建占位符，可使用SAVEPOINT语句，SAVEPOINT delete1； 总结：保留点越多越好—可以在SQL代码中设置任意多的保留点，越多越好。为什么呢？因为保留点越多，你就越能灵活地进行回退； 使用游标1、游标（cursor）：有时，需要在检索出来的行中前进或后退一行或多行，这就是游标的用途所在； 游标（cursor）是一个存储在DBMS服务器上的数据库查询， 它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据； 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改； 2、使用游标： 在使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句和游标选项 ； 一旦声明，就必须打开游标以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来； 对于填有数据的游标，根据需要取出（检索）各行； 在结束游标使用时，必须关闭游标，可能的话，释放游标（依赖于具体的DBMS）； 3、创建游标 ：使用DECLARE语句创建游标； 1234DECLARE CustCursor CURSORFORSELECT * FROM CustomersWHERE cust_email IS NULL 4、使用游标：使用OPEN CURSOR语句打开游标 ； 1OPEN CURSOR CustCursor 在处理OPEN CURSOR语句时，执行查询，存储检索出的数据以供浏览和滚动； 现在可以用FETCH语句访问游标数据了。FETCH指出要检索哪些行，从何处检索它们以及将它们放于何处（如变量名）； 5、关闭游标：CLOSE CustCursor； 高级SQL特性1、高级数据处理特性：约束、索引和触发器； 2、约束（constraint）：管理如何插入或处理数据库数据的规则； 主键： 1234567CREATE TABLE Vendors(vend_id CHAR(10) NOT NULL PRIMARY KEY,vend_name CHAR(50) NOT NULL);ALTER TABLE VendorsADD CONSTRAINT PRIMARY KEY (vend_id); 外键 ： 12345678910#外键有助防止意外删除CREATE TABLE Orders(order_num INTEGER NOT NULL PRIMARY KEY,order_date DATETIME NOT NULL,cust_id CHAR(10) NOT NULL REFERENCES Customers(cust_id));ALTER TABLE OrdersADD CONSTRAINTFOREIGN KEY (cust_id) REFERENCES Customers (cust_id); 唯一约束（UNIQUE）：唯一约束用来保证一列（或一组列）中的数据是唯一的。它们类似于主键，但存在以下重要区别： 表可包含多个唯一约束，但每个表只允许一个主键； 唯一约束列可包含NULL值； 唯一约束列可修改或更新； 唯一约束列的值可重复使用； 与主键不一样，唯一约束不能用来定义外键； 检查约束：用来保证一列（或一组列）中的数据满足一组指定的条件； 1234567#对OrderItems表施加了检查约束，它保证所有物品的数量大于0CREATE TABLE OrderItems(prod_id CHAR(10) NOT NULL,quantity INTEGER NOT NULL CHECK (quantity &gt; 0)); ADD CONSTRAINT CHECK (gender LIKE &apos;[MF]&apos;) 3、索引： 用来排序数据以加快搜索和排序操作的速度，在一个或多个列上定义索引，使DBMS保存其内容的一个排过序的列表，在定义了索引后，DBMS以使用书的索引类似的方法使用它。DBMS搜索排过序的索引，找出匹配的位置，然后检索这些行 ； 索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。在执行这些操作时，DBMS必须动态地更新索引； 索引数据可能要占用大量的存储空间； 并非所有数据都适合做索引。取值不多的数据（如州）不如具有更多可能值的数据（如姓或名），能通过索引得到那么多的好处； 索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能适合做索引； 可以在索引中定义多个列（例如，州加上城市）。这样的索引仅在以州加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处； 索引用CREATE INDEX语句创建，索引必须唯一命名 ： 123#在Products表的产品名列上创建一个简单的索引CREATE INDEX prod_name_indON PRODUCTS (prod_name); 检查索引：索引的效率随表数据的增加或改变而变化。许多数据库管理员发现，过去创建的某个理想的索引经过几个月的数据处理后可能变得不再理想 了。最好定期检查索引，并根据需要对索引进行调整； 4、触发器：是特殊的存储过程，它在特定的数据库活动发生时自动执行。触发器可以与特定表上的INSERT、UPDATE和DELETE操作（或组合）相关联； 与存储过程不一样（存储过程只是简单的存储SQL语句），触发器与单个的表相关联。与Orders表上的INSERT操作相关联的触发器只在Orders表中插入行时执行。类似地，Customers表上的INSERT和UPDATE操作的触发器只在表上出现这些操作时执行； 触发器的一些常见用途： 保证数据一致。例如，在INSERT或UPDATE操作中将所有州名转换为大写； 基于某个表的变动在其他表上执行活动。例如，每当更新或删除一行时将审计跟踪记录写入某个日志表； 进行额外的验证并根据需要回退数据。例如，保证某个顾客的可用资金不超限定，如果已经超出，则阻塞插入； 计算列的值或更新时间戳； 123456789#创建一个触发器，它对所有INSERT和UPDATE操作，将Customers表中的cust_state列转换为大写CREATE TRIGGER customer_stateAFTER INSERT OR UPDATEFOR EACH ROWBEGINUPDATE CustomersSET cust_state = Upper(cust_state)WHERE Customers.cust_id = :OLD.cust_idEND; 约束比触发器更快：一般来说，约束的处理比触发器快，因此在可能的时候，应该尽量使用约束； 5、数据库安全：任何安全系统的基础都是用户授权和身份确认。这是一种处理，通过这种处理对用户进行确认，保证他是有权用户，允许执行他要执行的操作。有的DBMS为此结合使用了操作系统的安全措施，而有的维护自己的用户及密码列表，还有一些结合使用外部目录服务服务器； 一般说来，需要保护的操作有： 对数据库管理功能（创建表、更改或删除已存在的表等）的访问； 对特定数据库或表的访问； 访问的类型（只读、对特定列的访问等）； 仅通过视图或存储过程对表进行访问； 创建多层次的安全措施，从而允许多种基于登录的访问和控制 ； 限制管理用户账号的能力； 安全性使用SQL的GRANT和REVOKE语句来管理，不过，大多数DBMS提供了交互式的管理实用程序，这些实用程序在内部使用GRANT和REVOKE语句 ； 总结：约束是实施引用完整性的重要部分，索引可改善数据检索的性能，触发器可以用来执行运行前后的处理，安全选项可用来管理数据访问。 脚本链接：https://pan.baidu.com/s/1BM1Z68UuLp73cLIrqjvfjw 提取码：5cer ​ ​ ​ ​ ​ ​","comments":true,"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"设计模式-观察者模式","date":"2019-03-18T02:08:53.000Z","path":"2019/03/18/设计模式-观察者模式/","text":"简单的说模式就是一种惯性的思维方式，用于解决同一类问题。 About模式：我们处理大量问题时，在很多不同的问题中重复出现的一种性质，它使得我们可以使用一种方法来描述问题实质并用本质上相同，但细节永不会重复的方法去解决，这种性质就叫模式。简单的说模式就是一种惯性的思维方式，用于解决同一类问题； 观察者模式（Observer）：何谓观察者模式？观察者模式定义了对象之间的一对多依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。 在这里，发生改变的对象称之为观察目标，而被通知的对象称之为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，所以么可以根据需要增加和删除观察者，使得系统更易于扩展。 所以观察者提供了一种对象设计，让主题和观察者之间以松耦合的方式结合。 简单例子观察者模式具备：事件的源、事件对象、事件处理对象； 以西游记为例，唐僧就是事件源，孙悟空、猪八戒、沙僧都是事件处理对象，事件对象包含有关事件和事件的源信息（就是记录唐僧发生事件的信息）； 先写事件对象类： TangEvent（记录唐僧发生事件的信息）： 1234567891011public class TangEvent &#123; private String eventStr; public TangEvent() &#123; &#125; public TangEvent(String eventStr) &#123; this.eventStr = eventStr; &#125; public String getEventStr() &#123; return eventStr; &#125;&#125; 接着写可以处理唐僧发生事件的接口类（Apprentice），只要是唐僧的徒弟就可以处理唐僧发生的事件，徒弟的功能就是观察唐僧看是否有事件需要处理： 123public interface Apprentice &#123; public void lookTS(TangEvent e);&#125; 再写可以处理事件的具体徒弟类，实现徒弟接口： 孙悟空实现类： 12345678910public class SunApprentice implements Apprentice &#123; @Override public void lookTS(TangEvent e) &#123; if(\"白骨精\".equals(e.getEventStr())) &#123; System.out.println(\"三打白骨精!\"); &#125; else if(\"女儿国王\".equals(e.getEventStr())) &#123; System.out.println(\"全凭师父定力！\"); &#125; &#125;&#125; 猪八戒实现类： 12345678910public class ZhuApprentice implements Apprentice &#123; @Override public void lookTS(TangEvent e) &#123; if(\"白骨精\".equals(e.getEventStr())) &#123; System.out.println(\"白骨精不是妖怪!\"); &#125; else if(\"女儿国王\".equals(e.getEventStr())) &#123; System.out.println(\"将师父留在女儿国吧！\"); &#125; &#125;&#125; 沙僧实现类： 12345678910public class ShaApprentice implements Apprentice &#123; @Override public void lookTS(TangEvent e) &#123; if(\"白骨精\".equals(e.getEventStr())) &#123; System.out.println(\"千万别误伤好人!\"); &#125; else if(\"女儿国王\".equals(e.getEventStr())) &#123; System.out.println(\"担心师父在女儿国王那有事！\"); &#125; &#125;&#125; 写事件源类（三要素：私有的监听者列表，公有的向监听者列表添加监听者的方法，公有的发生事情的方法）： 12345678910111213public class Tang &#123; private List&lt;Apprentice&gt; list = new ArrayList&lt;Apprentice&gt;();//私有的监听者列表 public void addTangListener(Apprentice apprentice) &#123;//公有的向监听者列表添加监听者的方法 this.list.add(apprentice); &#125; public void tangAction(String s) &#123;//公有的发生事情的方法 TangEvent tangEvent = new TangEvent(s); for(int i = 0; i &lt; this.list.size(); i++) &#123; Apprentice apprentice = this.list.get(i); apprentice.lookTS(tangEvent); &#125; &#125;&#125; 最后写一个Run类，事件源添加监听者实现类的实例： 1234567891011121314public class Run &#123; public static void main(String[] args) &#123; Tang tang = new Tang(); SunApprentice sun = new SunApprentice(); ZhuApprentice zhu = new ZhuApprentice(); ShaApprentice sha = new ShaApprentice(); //事件源加监听者实现类的实例 tang.addTangListener(sun); tang.addTangListener(zhu); tang.addTangListener(sha); tang.tangAction(\"白骨精\"); tang.tangAction(\"女儿国王\"); &#125;&#125; 至此，一个简单的观察者模式小例子完成。其实，在java中，我们不必像上面那样全都需要自己手动写，最后那个Run才需要我们自己完成。 事件源添加监听者接口实例四种方法： 1、自己加自己 2、自己加别人（实现接口） 3、自己加别人（适配器） 4、参数匿名类（适配器） 以Java Swing为例，先看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class MyFrame extends JFrame implements MouseListener &#123; private JPanel bodyPanel = null; private JButton b1 = null; private JButton b2 = null; private JButton b3 = null; private JButton b4 = null; private void init() &#123; this.bodyPanel = (JPanel)this.getContentPane(); this.bodyPanel.setLayout(new GridLayout(2, 2)); this.b1 = new JButton(\"b1\"); this.b1.addMouseListener(this);//自己加自己 this.bodyPanel.add(this.b1); this.b2 = new JButton(\"b2\"); MyListener1 myListener1 = new MyListener1(); this.b2.addMouseListener(myListener1);//自己加别人（实现接口） this.bodyPanel.add(this.b2); this.b3 = new JButton(\"b3\"); this.b3.addMouseListener(new MyListener2());//自己加别人（适配器） this.bodyPanel.add(this.b3); this.b4 = new JButton(\"b4\"); this.b4.addMouseListener(new MouseAdapter() &#123;//参数匿名类（适配器） public void mouseEntered(MouseEvent e) &#123; b4.setBackground(Color.BLACK); &#125; @Override public void mouseExited(MouseEvent e) &#123; b4.setBackground(Color.ORANGE); &#125; &#125;); this.bodyPanel.add(this.b4); this.setBounds(10, 10, 400, 400); this.setTitle(\"监听者模式\"); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public MyFrame() &#123; this.init(); &#125; public static void main(String[] args) &#123; MyFrame frame = new MyFrame(); frame.setVisible(true); &#125; @Override public void mouseClicked(MouseEvent e) &#123; &#125; @Override public void mousePressed(MouseEvent e) &#123; &#125; @Override public void mouseReleased(MouseEvent e) &#123; &#125; @Override public void mouseEntered(MouseEvent e) &#123; if(e.getSource() == this.b1) &#123; this.b1.setBackground(Color.RED); this.b4.setBackground(Color.BLUE); &#125; &#125; @Override public void mouseExited(MouseEvent e) &#123; if(e.getSource() == this.b1) &#123; this.b1.setBackground(Color.BLUE); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728public class MyListener1 implements MouseListener &#123; @Override public void mouseClicked(MouseEvent e) &#123; &#125; @Override public void mousePressed(MouseEvent e) &#123; &#125; @Override public void mouseReleased(MouseEvent e) &#123; &#125; @Override public void mouseEntered(MouseEvent e) &#123; JButton b2 = (JButton)e.getSource(); b2.setBackground(Color.BLUE); &#125; @Override public void mouseExited(MouseEvent e) &#123; JButton b2 = (JButton)e.getSource(); b2.setBackground(Color.GREEN); &#125;&#125; 12345678910111213public class MyListener2 extends MouseAdapter &#123; @Override public void mouseEntered(MouseEvent e) &#123; JButton b3 = (JButton)e.getSource(); b3.setBackground(Color.YELLOW); &#125; @Override public void mouseExited(MouseEvent e) &#123; JButton b3 = (JButton)e.getSource(); b3.setBackground(Color.PINK); &#125;&#125; 从代码也可以看出，适配器里面其实是一些空实现的方法，可以避免代码出现过多的空方法。 参考文章：http://cmsblogs.com/?p=3396#7Observer","comments":true,"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"零基础入门C语言","date":"2019-03-09T02:31:51.000Z","path":"2019/03/09/C语言入门/","text":"轻松入门C语言，通俗易懂的小例子理解C语言的三大结构 About面向对象和面向过程 面向过程就是人看待事物的眼光和思想，关注于步骤； 面向对象是一种对现实世界理解和抽象的方法； 面向过程—&gt;怎么做、面向对象—&gt;谁在做； 学习C语言的方法（其他语言类似） 入门：先了解背景、市场占有率、这门语言主要用途、前景如何、哪个公司发明； 最小单元：常量、变量、数据类型； 次小单元：运算符、表达式； 结构：业务逻辑（顺序结构、分支结构、循环结构）； 高级部分：数组、函数； 特征（语言所特有部分）：指针； 基础部分程序的入门 程序：做一件事情的过程，作用：计算机模拟现实生活，从而达到降低成本，提高效率的效果； 计算机中的程序：为了让计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合； 算法就是对解决问题的方法的描述，算法是描述、程序是执行； 算法固性：有穷性（步骤有限）、确定性（步骤清晰不模糊） 、交互性（具有输入输出）、有效性（步骤有效）； 如何表示算法：自然语言（需求分析）、流程图（概要设计-避免歧义）、伪代码（详细设计）、程序语言（出差：需求、部署）； C语言：面向过程的结构化语言，三种基本结构：顺序结构、分支选择结构、循环结构； 基础知识 低级语言：（汇编）机器语言，可以直接操作计算机硬件；中级语言（C），指针可操作计算机硬件，人类语言；高级语言：（Java）人类语言，经过编译变成机器语言，机器才能执行； 编译：语法查错、转成机器语言（转译）； C语言优点：既能开发系统程序，又能开发应用程序； C语言：面向过程，结构化的（顺序，分支，循环），函数语言； 学习方法：wwwh（why, what, when, how），程序 = 数据结构 + 算法； 最小单元变量和常量 最小的盛放数据单元； 常量：值不能改变的量，一般常量和符号常量（用#define定义，一改全改）； 变量：值可以改变的量，变量的本质是一片连续的内存空间，变量是一个容器，用来存放数据； C语言规定：变量必须先声明，再赋值，后使用；所有变量定义在函数首部，有了执行语句，就不能再有定义语句； 变量命名规则（三条）: ​ —必须以数字，字母，下划线组成，以字母或下划线开头； ​ —见名知义，首字母小写； ​ —变量不能和关键字重名，区分大小写； 基本数据类型 基本数据类型：运算法则、约束内存空间大小的单位； 数值：整型（int，short int，long int）和非整型（float，double），非数值：char； 1个字节 = 8位 、一个中文字符 = 2个字节 、一个英文字符 = 1个字节； C语言中没有字符串变量，用字符数组模拟字符串变量（难用）； ASCII码：0~9（48~57），A~Z（65~90），a~z（97~122）， C语言中char和int完全兼容； 类型转换: ​ —&gt;自动类型转换：把范围小的类型的值转换为范围大的类型的值：（ short, int, long, float, double）； ​ —&gt;强制类型转换：(类型名)变量或数值； 转义字符：转为其他的意思（\\t， \\n等）； C语言的输入输出：getchar() ，putchar()，输入输出字符； scanf() ，printf()输入输出任何东西，（sacnf和printf中的f是format的意思，即格式化输入和输出）； 次小单元运算符&amp;表达式 表达式：操作数 + 运算符； 数学表达式、赋值表达式、关系表达式、逻辑表达式； 算数运算符：+、-、* 、/、%（二目）， /：两边都是整数取整，/：两边至少一边为实型求精确值，%：要求两边都是整型，求余； 12345678910111213141516171819202122232425262728//算数运算符练习：回文数：void main() &#123; int ge, shi, qian, wan, x; printf(\"请输入一个五位数：\"); scanf(\"%d\", &amp;x); wan = x / 10000; qian = x % 10000 / 1000; shi = x % 100 / 10; ge = x % 10; if(wan == ge &amp;&amp; qian == shi) &#123; printf(\"%d是回文数\\n\", x); &#125; else &#123; printf(\"%d不是回文数\\n\", x); &#125;&#125;//水仙花数：void main() &#123; int n, ge, shi, bai; for(n = 100; n &lt;= 999; n++) &#123; ge = n % 10; shi = n % 100 / 10; bai = n / 100; if(ge * ge * ge + shi * shi * shi + bai * bai * bai == n) &#123; printf(\"%d\\n\", n); &#125; &#125;&#125; ++、–（一目），单个语句时a++和++a效果一样，参与运算时a++和++a效果不一样； 123456789//自增自减练习：void main() &#123; int a = 1, b = 2, c = 3, d, e, f; d = ++a; e = a + b; f = (b--) + c; printf(\"%d %d %d %d %d %d\\n\", a, b, c, d, e, f);&#125; 运行结果：2 1 3 2 4 5 赋值：变量 = 表达式； 关系运算符：&gt;、&gt;=、！=、==、&lt;、&lt;=； 逻辑运算符（与、或、非）：&amp;&amp;、||、！； C语言中：用0代表假，非零代表真；sizeof：可以获得数据类型占用内存空间的大小 ；sizeof(type_name) 结果以字节为单位显示； 三种结构顺序结构分支选择结构 if：（布尔常量， 布尔变量， 比较表达式， 逻辑表达式）； 多分支（否定式： 多重if-else、 switch-case）； 123456789101112131415161718192021222324252627282930313233343536//多重if-elsevoid main() &#123; int f; printf(\"请问你送几朵花：\"); scanf(\"%d\", &amp;f); if(f &gt;= 9 &amp;&amp; f &lt; 99) &#123; printf(\"笑一笑\"); &#125; else if(f &gt;= 99 &amp;&amp; f &lt; 999) &#123; printf(\"拉拉手\"); &#125; else if(f &gt;= 999) &#123; printf(\"抱一抱\"); &#125; else &#123; printf(\"不高兴\"); &#125; &#125;解释：程序能进入到下一个elseif语句块，说明前面if里的条件不成立//switch-casevoid main() &#123; int f; printf(\"请问你送几朵花：\"); scanf(\"%d\", &amp;f); switch(f) &#123; case 9: printf(\"笑一下\"); break; case 99: printf(\"拉拉手\"); break; case 999: printf(\"抱一下\"); break; default: printf(\"不高兴\"); &#125; &#125;解释：程序能进入到下一个case语句块，说明前面case里的条件不成立，每个case后应该有break语句，否则程序会执行当前case条件满足后的所有语句，不符逻辑。 （肯定式：If嵌套）； 1234567891011121314151617181920void main() &#123; int work, house, car; printf(\"请输入你的资源：\"); scanf(\"%d %d %d\", &amp;work, &amp;house, &amp;car); if(work) &#123; if(house) &#123; if(car) &#123; printf(\"赶紧结婚\"); &#125; else &#123; printf(\"买了车就结婚\"); &#125; &#125; else &#123; printf(\"无房不嫁女\"); &#125; &#125; else &#123; printf(\"先好好提升自己\"); &#125;&#125;解释：当进入下一个if条件判断时，说明满足之前if的判断条件。 switch-case：switch()里可以是整型常量，整型变量，整型表达式；case后面必须是整型常量，case最后一句跟break；case后面不能跟相同的值，case可以随意倒顺序； 条件运算符：a &gt; b ? c : d —-如果a &gt; b成立，则结果为C，否则为d； 循环结构 循环的本质：有规律的重复的做一件事； 循环分类：（小括号—规律，花括号—重复），规律：已知循环次数（循环变量i）和未知循环次数（循环的开关）；循环体：当型、直到型； 当型（while-未知循环次数、for-已知循环次数），直到型：do-while（已知循环次数和未知循环次数）； 12345678910111213141516171819202122232425262728293031323334353637383940414243//whilevoid main() &#123; int i = 0, j = 0; while(i &lt; 10) &#123; printf(\"第%d个同学演节目开始！\", (i + 1)); while(j &lt; 3) &#123; printf(\"第%d个节目!\", (j + 1)); j++; &#125; j = 0; printf(\"第%d个同学演节目结束！\\n\", (i + 1)); i++; &#125;&#125;//forvoid main() &#123; int i, j; for(i = 0; i &lt; 10; i++) &#123; printf(\"第%d个同学演节目开始！\", (i + 1)); for(j = 0; j &lt; 3; j++) &#123; printf(\"第%d个节目！\", (j + 1)); &#125; printf(\"第%d个同学演节目结束！\\n\", (i + 1)); &#125;&#125;//do-while（猜数字）void main() &#123; int flag = 1; int num = 8, guess; printf(\"请输入一个1~10之间的数！\"); do &#123; printf(\"请输入：\"); scanf(\"%d\", &amp;guess); if(guess &lt; num) &#123; printf(\"小了！\"); &#125; else if(guess &gt; num) &#123; printf(\"大了！\"); &#125; else &#123; flag = 0; &#125; &#125; while(flag); printf(\"恭喜你答对了！\");&#125; 已知循环次数：循环变量在外面定义并初始化，循环变量在循环体里进行自增或自减； 循环的嵌套：外层一趟，内层一遍； for循环：for（表达式1；表达式2；表达式3）， ​ 表达式1：循环变量赋初值； ​ 表达式2：循环条件； ​ 表达式3：更新循环变量值； break与continue：break，终止，在多层循环中，一个break语句只向外跳一层循环；continue：中止，只能用在循环里，跳过循环体中剩余的语句而执行下一次；对于while和do-while循环（continue语句执行之后的动作是条件判断），对于for循环，随后的动作是变量更新； 一般情况下，这几种循环体用的概率：for（60%）、while（25%）、do-while（15%）； 高级部分数组 why？数据带上结构：贴近现实生活，操作、维护方便； 主要内容：数组名、数组大小、数组下标、数组容器的样子、数组类型； 变量&amp;数组比较： ​ 变量：值可变的量、一片连续的内存空间、小容器； ​ 数组：一组数放在一起、一片连续的有序的类型相同的空间、大容器； 种类：一维、二维、多维； 一维数组声明： 1datatype arrayName[size]; //（size：整型常量） 静态定义（三种）： 123int num[5] = &#123;1, 2, 3, 4, 5&#125;;int n1[] = &#123;1, 2, 3&#125;;int n2[5] = &#123;1, 2, 3&#125; 动态定义（循环初始化）； 字符数组模拟字符串变量： 1char c[2] = \"ok\"； 输入输出字符串：gets(),puts()—可输入空格； 二维数组声明： 静态定义（两种）： 12int num[2][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;;int num[][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; 动态定义（使用for循环初始化）； 1234567891011121314151617//找数字：void main() &#123; int n = 8, i; int num[10]; for(i = 0; i &lt; 10; i++) &#123; scanf(\"%d\", &amp;num[i]); &#125; for(i = 0; i &lt; 10; i++) &#123; if(n == num[i]) &#123; printf(\"找到了：%d, 位置：%d\", num[i], i + 1); break; &#125; &#125; if(i == 10) &#123; printf(\"对不起，没找到！\"); &#125;&#125; 函数 使用函数四个优点： ​ 让主调函数更简短清晰； ​ 提高代码维护效率； ​ 提高代码开发效率； ​ 提高代码复用率； 函数类型： ​ 内置函数—函数原型，功能，在哪个工具箱（头文件）放着； ​ 自定义函数； rand（）：伪随机函数； 12srand((unsigned)time(NULL))---作种函数（每次出来的随机数不一样）；//没有这句，程序运行每次随机数一样 自定义函数：返回值类型 函数名（[参数的数据类型 参数名],…），函数一次性只能返回一个值； 一个函数只做一件事；（高内聚） 函数原型说明：int add(int a, int b)或int add(int, int)； 函数的参数：函数定义中声明的参数是形参，函数调用时传入的参数就是实参； 函数参数的传递：值传递（将实参拷贝一份赋值给形参），址传递（让形参和实参共享一片内存空间，即内存地址相同）； 12345678910111213141516171819202122//值拷贝传递void add(int x, int y) &#123; x++; y++;&#125;void main() &#123; int a = 1, b = 2; add(a, b); printf(\"%d %d\", a, b);&#125;运行结果：1 2//址传递void add(int n[2]) &#123; n[0]++; n[1]++;&#125;void main() &#123; int a[2] = &#123;1, 2&#125;; add(a); printf(\"%d %d\", a[0], a[1]);&#125;运行结果：2 3 变量作用域： 变量的有效范围 —&gt; 全局、局部； 123456789101112131415161718192021222324252627//简单彩票机void main() &#123; int i = 0, j, m; int lottery[7]; srand((unsigned)time(NULL)); printf(\"请问您是否要购买彩票？\"); printf(\"请选择：1-是，0-否\\n\"); scanf(\"%d\", &amp;m); if(m) &#123; do&#123; lottery[i] = (rand() % 33) + 1; for(j = 0; j &lt; i; j++) &#123; if(lottery[j] == lottery[i]) &#123; break; &#125; &#125; if(!(j &lt; i)) &#123; i++; &#125; &#125; while(i &lt; 7); for(i = 0; i &lt; 7; i++) &#123; printf(\"%d \", lottery[i]); &#125; &#125; else &#123; return 0; &#125;&#125; 特征指针 指针：就是内存地址，一个变量只有一个指针； 指针变量：用来存放地址的变量，变量的指针：变量的地址； 关键的运算符：&amp; 取地址符、* 指针运算符； int p== (int )p； n[i - 1] = (n + (i - 1)) = (p + (i - 1))；","comments":true,"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C语言/"}]},{"title":"JavaSE基础","date":"2019-03-07T06:22:36.000Z","path":"2019/03/07/Java基础/","text":"Java一些基础语法概念 About1、SUN（Stanford University Network），2008年10亿美金收购mysql，2010年74亿美金被甲骨文收购； 2、语言的进化：机器、汇编、高级语言、面向对象（计算机容易识别转换为人容易识别）； 3、java之父：James Gosling； 4、java诞生记：1991年SUN公司的Green计划（让电器带上智能—编程语言跨平台）、java开发了三年；Internet带来时机，本起名Oak（橡树），1995年正式发布java1.0版本； 5、java是sun公司倡导的JamesGosling发明的面向对象的可跨平台的编程语言； 6、平台 = cpu + 操作系统； 7、跨平台：编译以后能不能跨平台，并非源代码可跨平台运行； 8、Java可以反编译（缺点）； 9、java：一次编译，到处执行（编译器、解释器）； 10、语言执行方式的三种分类： 编译执行：缺点，无法跨平台；优点，速度快； 解释执行（html、javascript）：类似同声传译； 中间码+虚拟机（解释型语言）； 11、JDK：开发java需要从源文件到中间字节码的编译器；运行java需要java解释器；JDK=Java编译器+Java解释器+其他组件； 12、优点：面向对象、平台无关、自动收集内存、多线程开发；缺点：运行速度慢，占用资源多，复杂； 13、IDE工具：Jbuild可以拉拖界面； 基础1、数据类型：基本数据类型和引用数据类型； 基本数据类型：数值型（整数（byte—1个字节、short、int、long）、浮点（float、double））、字符型（char）、布尔型（boolean）； 引用数据类型：类（class）、接口（interface）、数组； 2、字符串String； 3、数组定义（三种方式）： 123int[] num = new int[2];int[] num = &#123;1, 2&#125;;int[] num = new int[]&#123;1, 2&#125;; 4、反序数： 12345int n = 12345;while (n != 0) &#123; System.out.print(n % 10); n = n / 10;&#125; 5、冒泡排序：（第一轮将大的排第一，第二轮将次大的排第二，以此类推，5个数循环4次）： 12345678910111213int[] num = new int[]&#123;2, 6, 4, 8, 3&#125;;for(int i = 0; i &lt; num.length - 1; i++) &#123; for(int j = 0; j &lt; num.length - i - 1; j++) &#123; if(num[j] &gt; num[j+1]) &#123; int temp = num[j]; num[j] = num[j+1]; num[j+1] = temp; &#125; &#125;&#125;for(int i = 0; i &lt; num.length; i++) &#123; System.out.println(num[i]); &#125; 6、二分查找（要求数字按序排列）： 123456789101112131415161718int[] num = &#123;1, 4, 6, 8, 10, 13&#125;;int n = 4;int start = 0, end = num.length - 1, m;while(true) &#123; m = (start + end) / 2; if(num[m] &gt; n) &#123; end = m - 1; &#125; else if(num[m] &lt; n) &#123; start = m + 1; &#125; else &#123; System.out.println(\"找到了\" + num[m] + \"，位置为：\"+ (m + 1)); break; &#125; if(start &gt; end) &#123; System.out.println(\"找不到！\"); break; &#125;&#125; 类和对象1、面向对象编程（oop，Object Oriented Programming），是一种设计软件的先进的主流的思想，旨在计算机中模拟现实世界中的事物和概念，Everything is object； 2、现实生活中的任何事物，都可以用状态（属性）和行为（方法）来描述； 属性是事物（类）本身的特性，用来表示它的状态；行为（方法）用来说明这个事物（类）所具有的功能； 3、类（主观）是具有相同属性和方法的一组对象（实例）的集合； 4、对象是具体的，是类定义内容的实现，把一个类的对象称为一个类的实例（客观存在的）； 5、类是对象的抽象定义，对象是类的具体实例； 6、java声明完类并不开辟空间，new关键字为实例开辟空间； 7、构造方法（什么？作用？调用时机？分类？） 方法名与类名完全相同，但没有返回类型（跟没有返回值不一样）； 123//Person类Person() &#123; //构造方法 &#125; 作用：让类开辟空间；在类诞生的时候做一些事情（一般是初始化）； 调用时机：new的时候自动调用（开辟空间的时候），传什么参调用什么方法； 分类： 默认有隐式构造方法（空参数），显式构造方法（带参）； 如果类中不带任何构造方法，系统提供隐式构造方法； 如果自己定义了显式构造方法，系统不再提供隐式构造方法； 8、static关键字： 成员变量（实例名、引用名）：new完后才可使用的变量； 12static int num = 0; //静态变量，不需成员名直接类名可调用；成员名也可调用//Person.num static定义完就开辟空间，开辟在静态池中； 静态变量只保持一份，节省空间； 作用：保存类的信息（比如new一次加一次）； 9、包：本质是个文件夹（方便管理、避免名字冲突）；包名是类名的一部分；包是java封装机制的一部分； 10、一般先写被调，再写主调； 封装和继承1、面向对象特征：封装、继承、多态；对象的特征：属性、方法； 2、封装：隐藏事物内部的实现细节、有选择的提供数据； 封装优点： 内部的修改不影响外部的使用； 防止外界误修改程序单元； 对象使用变得更简单； 3、访问修饰符：public、protected、默认、private（都可以修饰属性和方法，只有默认和public可以修饰类）； public：所有类都可以访问（本类、同包、异包下的子类、异包下的其他类）； protected：该类及其子类成员可以访问，同一个包中的可以访问（本类、同包、异包下的子类）； 默认：相同数据包里的可以访问（本类及其同包下的类可以访问）； private：只有该类可以访问； 4、实体类：get与set方法称为访问器； 5、继承（extends）： 在一个类的基础上定义一个新类是继承； 父子关系是相对的； 继承关系由“子类是父类”确定； java中只有单继承； 继承效果： 子类可以拥有父类的属性和方法； 子类可以拥有新的属性和方法（扩展）； 子类可以重写覆盖父类方法和属性（修改）； 1@Override //注解，写给编译器 可以声明父类，创建子类（父类装载子类—向上转型），父类能出现的地方，子类一定能出现；声明的什么类型，就只能调用什么类型的属性方法；创建的什么类型，就真正运行什么类型的方法；创建的什么类型，就可以强转为什么类型（向下转型）； 1Person p = new Teacher();//父类装载子类，父类的引用指向子类的空间 继承的优点： 提高代码复用性； 父类的属性方法可以用于子类； 可以轻松的定义子类； 使设计应用程序变得简单； 6、关键字this与super： this：表示调用本类声明的属性和方法，this使用在构造方法中表示调用本类其它构造方法； super：表示调用父类声明的属性和方法； 7、继承中的构造方法： 创建子类一定会调用父类的构造方法； 子类默认调用父类无参（显式或隐式）构造方法； 子类只能调用父类存在的构造方法； 子类构造方法中使用super调用父类构造方法，并且super必须放在第一行； 8、子类要覆盖父类的属性或方法，子类的访问修饰符必须大于或等于父类的访问修饰符； 方法重载和多态1、方法重载（Overload）： 具有相同的方法名称、不同的参数（类型或者个数）； 要点： 与参数名无关； 与返回类型无关； 父子类方法重载； 构造方法重载； 2、多态： 多态可以理解为“多种形式”的意思； 多态在程序中表现为同一个引用在不同的条件下指向不同实例，从而表现出不同状态； 多态一般用方法重载和方法重写来实现； 3、雪雪是个多态：在学校是学生，在家里是儿女，在社会是工作者（同一个人在不同环境下表现出不同状态）； 4、static（强调只有一份）修饰符： static只能修饰属性和方法，不能修饰类； static修饰符修饰的变量叫静态变量； static修饰符修饰的方法叫静态方法；静态方法独立于类的实例，使用类去访问，而不是类实例，所以也叫类方法；静态方法只能调用静态成员，不能调用成员化东西；成员方法可以调用静态方法；静态方法和属性不能写this和super； 5、final修饰符： final可以修饰属性、方法和类； 不能修改该变量；不能继承该类；子类不能重写该方法； 6、static和final：final强调是不变的；static强调只有一份； 7、内存机制： 方法区：类结构的样子、静态属性、静态方法； 堆：对象的实例； 栈：对象的引用、基本数据类型； 栈（最快）&gt;堆（容量大、速度慢）； 8、Java内存图示： 9、值传递与址传递：基本数据类型采用值传递、引用类型址传递； 接口1、抽象方法： abstract修饰的方法就是抽象方法； 抽象方法不能有方法实现，只能有方法定义； 抽象方法必须出现在抽象类中； 构造方法和static方法不能是抽象的； 2、抽象类： abstract修饰的类就是抽象类； 抽象类中可以拥有若干个（0~多个）抽象方法，也可以拥有若干个（0~多个）普通方法； 抽象类不能被实例化，可被继承； 如果一个抽象类被另一个类继承，这个类必须重写抽象类中所有抽象方法； 3、接口（interface），达到多继承的效果，接口就是功能： 是一种“纯虚抽象类”，可以理解为半个类； 接口用来完成多继承的效果； 接口中只能有方法的定义，不能有方法的具体实现； 接口中可以定义常量（static final）； 接口可以被继承（接口继承接口），接口可以多继承； 接口可以多实现（类实现接口）； 弥补单继承的不足，实现多继承的效果； 实现者-使用者纽带作用； 用法：extends， implements 4、编程技术的趋势：面向过程、面向对象、面向接口、面向方面； 5、什么是什么，可以理解为类的继承；什么能干什么，可以理解为接口的实现； JavaAPI（Java.lang—基础包）1、包装类、String和StringBuffer类、Math、Class、Object； 2、java的main方法和8个基本数据类型不是面向对象的； 3、装箱：int-&gt;Interger（valueOf）; 拆箱：Interger-&gt;int（intValue）； 4、包装类型 实例名 = 包装类型.valueOf(String);包装类型.parse基类型(String)；实例名.toString()； 5、字符串： 12String s0 = \"aa\";//字符串字面量String s1 = new String(\"aa\");//字符串对象 6、==：判断字符串指的是否为同一片空间；equals比较字符串值是否相等； 7、字符串字面量：值相等用==比较true；字符串对象：值相等用==比较false； 8、字符串lengh是方法，数组lengh是属性； 9、字符串比较内容：equals、comoareTo、startswith、endswith； 10、搜索字符串：indexOf（String）； 11、操作字符串：split（）、charAt（）、subString（）、replace（）、concat（）、trim（）—去掉前后不含空格的字符串； 12、Object：toString、equals（在object里比较的是两个引用是否相等，无法比内容，需重写equals方法）、hashcode（重写hashcode，使重写equals方法后，业务逻辑和虚拟机保持一致）、finalize（析构方法，收空间，System.gc()—建议立即回收垃圾方法）； 13、Class：类的类，包装正在运行类的运行状态及信息，可用来动态加载类，得到类的实例； 14、字符串（空间）的不变性：String—&gt;有序的、不变的字符序列； StringBuffer：可变字符串，解决字符串的不变性，节省空间； 12StringBuffer sb = new StringBuffer(\"ok\");sb.append(\"halou\"); 异常处理1、try、catch、finally、throw、throws； 2、异常：就是不同寻常的事情，异常并不总是错误，一切不寻常的事情都是异常（其中包含错误）； 3、所有异常类型都是内置类Throwable的子类： Error类对象由java虚拟机生成并抛出（用于java运行时系统来显示与运行时系统本身有关的错误）—灾难，无法处理； Exception类对象由应用程序处理或抛出（用于用户程序可能捕获的异常，也是用来创建用户异常类型子类的类）—可以处理。RuntimeException可以忽略，除了RuntimeException其他子类不能忽略； 4、处理方式：直接处理、向上抛出； 5、是一个业务逻辑才能try在一起； 6、try-catch如果代码段有异常没被处理，在发生异常处及后面代码不被执行，如果处理，进入catch处理后后面代码依然执行； 7、throws处理后，后面代码不再执行，看到throw方法直接返回，位于throw下面的代码不再执行；如果希望throw后面的代码执行，最后加finally，不管有木有错finally里语句要执行； 8、里面throw-throws，外面try-catch；如果里面是Runtime可以throw不throws，外面可抓可不抓；里面不throw，外面直接catch； JDBC数据库连接（java.sql）1、JDBC（sun公司制定）是一种标准，不是技术，是一些类和接口的集合（jar包）； 2、sun公司制定标准（接口），数据库生产商按照标准生产数据库连接对象（类-实现），开发人员学习接口，使用类； 3、Driver（驱动程序）、Connection（表示与数据库的连接）、PreparedStatement（执行预编译的SQL语句）、ResultSet（查询出来的数据库数据结果集）、Statement（执行SQL语句并将数据检索到ResultSet中）； java.util1、Date、Calender、GregorianCalendar（时间）；Arraylist、Vector、HashSet、HashMap、Hashtable（集合框架、容器）； 2、Date：表示特定的瞬间，精确到毫秒，获得当前时间； 3、toString原生出来是类名+地址； 4、Calender：日历类，抽象类，不能被实例化； 5、GregorianCalendar：标准日历类，是Calendar一个子类，日期类月份值跟业务逻辑相差1； 6、SimpleDateFormat：日期的格式化； 7、日历变日期：getTime()； 8、集合框架：用于表示和操纵集合的统一体系结构，集合用于存储、检索和操纵数据，Collection对象是将多个元素组成一个单元的对象； 9、集合框架包含三个组件：接口、实现、算法； 10、Iterator（迭代器）、Collection（多个变一个，用对象本身存集合里面，无序）、Map（多个变一个，键值对存储，无序）； 11、集合框架类层次结构： 12、List：有序的、带下标的、对象本身存；Set：无序、不带下标、对象本身存； Vector：线程安全的动态数组，ArrayList：线程不安全的动态数组； 13、Collection：可存储重复值； 迭代器-Iterator： 12345Iterator iterator = c1.iterator();while (iterator.hasNext()) &#123; Student temp = (Student) iterator.next(); System.out.println(temp.toString()); &#125; foreach迭代： 123for(Student s : c1) &#123; System.out.println(s.toString()); &#125; foreach里面内部就是iterator； 14、泛型：规定容器里只放一种东西； 15、Vector： 具有类似数组的数据结构，是动态的，容量可以递增； 可存储重复元素和NULL； 元素有序排列； 线程安全； 16、Set：无序、不能存储重复元素、可存null、线程不安全的； 17、Map： 键值对存储； 三种遍历方式—迭代（键、值、键值对）、entry（key-value）； 键不能重复，值可以重复； 键和值可以存null值，hashmap线程不安全； 12345678910111213141516171819System.out.println(\"通过keys进行遍历===========\");Set&lt;String&gt; keys = map.keySet();for(String keyStr: keys) &#123; System.out.println(keyStr); System.out.println(map.get(keyStr));&#125;System.out.println(\"通过values遍历=================\");Collection&lt;Student&gt; values = map.values();for(Student stu: values) &#123; System.out.println(stu);&#125;System.out.println(\"通过key-values（Entrys）遍历================\");Set&lt;Map.Entry&lt;String, Student&gt;&gt; entrys = map.entrySet();for(Map.Entry&lt;String, Student&gt; entry: entrys) &#123; System.out.println(entry.getKey()); System.out.println(entry.getValue());&#125; 18、hashtable线程安全，键和值都不可以存储null值，遍历的时候可以使用枚举类型； 1234567Hashtable&lt;String, Student&gt; ht = new Hashtable&lt;String, Student&gt;();ht.put(\"dd\", s1);System.out.println(\"枚举类型==============\");Enumeration&lt;Student&gt; enumeration = ht.elements();while (enumeration.hasMoreElements()) &#123; System.out.println(enumeration.nextElement());&#125; 19、实现comparable达到list集合排序功能； 20、集合框架的优点：提供有用的数据结构和算法，减少编程工作；提高程序速度和质量，因为它提供了高性能的数据结构和算法；可以方便地扩展或改写集合； JavaSwing1、GUI：图形用户界面； 2、Awt（抽象窗口工具-重量级页面技术）、Swing（波浪、翅膀-轻量级页面技术），swing是awt的子类； 3、Awt（重量级）：容器（包含Awt容器组件）、组件（以图形表示的对象允许用户交互）、布局管理器（定义GUI组件的位置）、图形和绘制方法（使用Awt图形方法相对于窗口绘制图形）、字体、事件（用于用户和系统交互）； 4、Swing（轻量级）：容器、组件、可改变的外观、Java2D图形绘制； 5、MVC（编程思想）：界面、操作、存储（视图、控制—业务的分发和流程的转发、持久—存储数据）； 6、页面主动拿数据（拉）、页面被动拿数据（推），swing是mvc的推； 7、重量级（直接借助于awt、被单独的显示）、中间层容器、功能性容器； 8、Dimention：描述矩形的单位； 9、JLabel：单向交互、显示图片或文字；JButton：交互；JTextField：文本域；JPasswordField、JTextArea、JScollPane； 10、布局管理器：屏幕组件可以按照一定的格式布局； 流式（FlowLayout）：默认，一直往下排列； BorderLayout：边框布局管理器，上下左右中； GridLayout：几行几列； GridBagLayout：高级布局管理器，实现精确的布局管理； 11、ActionListener：实现接口、完成事件方法、相应事件源上加事件； 12、JDialog（繁琐）和JOptionPane（简单）：弹出式对话框，完成于用户的交互； 13、对话框显示：模式（需处理）、非模式（不需处理）； 14、模式：观察者模式（事件的源、事件对象、事件处理对象）； 15、事件源（三个要素）：私有的监听者列表，公有的向监听者列表添加监听者的方法，公有的发生事情的方法； 16、事件源四种添加监听者接口实例：自己加自己、自己加别人实现接口、自己加别人（适配器）、参数匿名类（适配器）； 17、表格JTable：显示数据，表格模板（TableModel）：对数据操作，JMenu：菜单；热键：Alt+？ 18、JMenue不能做快捷键，可以做热键，不能带图片；JMenueIterm两个都可以做，可以带图片； 19、工具栏（JToolBar）挂在panel上； 20、标签面板（JTabbedPane）：是一种容器，提供一组标签显示不同页面； 设计模式1、模式：我们处理大量问题时，在很多不同的问题中重复出现的一种性质，它使得我们可以使用一种方法来描述问题实质并用本质上相同，但细节永不会重复的方法去解决，这种性质就叫模式。简单的说模式就是一种惯性的思维方式，用于解决同一类问题； 2、23种设计模式： 创建型：解决对象与对象之间创建性的问题； 结构型：解决对象与对象间搭配结构的问题； 行为型：解决对象与对象之间做事情； 创建型 结构型 行为型 类 工厂方法（Factory Method） 适配器（Adapter） 解释器（Interpreter）模板方法（Template Method） 对象 抽象工厂（Abstract Factory）生成器（Builder） 原型（Prototype）单态（Singleton） | 适配器（Adapter）桥接（Bridge）组成 （Composite）装饰（Decorate）外观（Facade）享元（Flyweight）代理（Proxy | 责任链（Chain of Responsibility）命令（Command）迭代器（Iterator）中介者（Mediator）备忘录（Memento）观察者（Observer）状态（State）策略（Strategy）访问者（Visitor） | Java Io1、I/O流用来完成java的输入输出工作，包括磁盘文件、设备、其他程序以及内存数据等等的输入输出； 2、数据流（不间断—I/O流）、数据包（间断）； 3、分类：字节流（Stream）、字符流； 4、基于流技术可以用来传递数据，还可以用来操作或格式化数据； 5、外部进入代码里面：输入流；代码输出数据：输出流； 6、声明、创建、读写、关闭； 7、字符流的根：Reader和Writer； 8、 123reader = new BufferedReader(new FileReader(\"./test1.txt\"));writer = new BufferedWriter(new FileWriter(\"./test2.txt\"));里面节点流，外面处理流； 9、字节流、缓冲字节流、字符流、缓冲字符流； Java多线程1、进程（是执行中的程序，是活动的实体—正在通电的内存；是自包容的运行程序，有自己的地址空间）—是操作系统的最小单元；线程（是轻量级进程，是CPU使用的基本单元；线程属于某一个进程，一个进程中拥有一个或多个线程；多个线程共享同一个进程资源）；进程是重量级的、线程是轻量级的； 2、read方法是一种阻塞方法； 3、多任务处理： 基于进程：计算机同时运行多个进程；基于线程：一个进程包含多个线程； 4、使用多线程的理由：与用户交互更佳、模拟同步动作、利用多处理器、等待缓慢I/0操作时完成其他任务、简化对象模型；线程也需要开销资源，谨慎使用； 5、JVM中的线程：当操作系统启动（javac、java、javaw等命令）JVM时就创建了一个进程；JVM进程内至少包含了 两个线程：mian方法和垃圾回收线程，它们称为主线程，有时它们还会启动其他线程，它们必须最后完成执行，执行各种关闭、释放动作； 6、创建线程两种方法：声明一个Thread类的子类，并覆盖run（）方法；声明一个实现Runnable接口的类，并实现run（）方法； 7、线程的状态：新建态（New—尚未启动的线程）、可运行态（Runnable—可运行线程的线程状态）、锁定态（Blocked—受阻塞线程的线程状态）、等待态（Waiting）、定时等待态（Timed_Waiting）、中止态（Terminated—已终止线程的线程状态）； 8、yield：使正在执行的线程临时暂停，并允许其他线程执行； 9、优先级：线程抢占cpu的能力； Java网络编程1、网络（套接字、socket）编程； 2、网络：实现资源共享和通信，连接终端系统（主机）的通信系统； 3、OSI模型：物理层、数据链路层（怎么连）、网络层（怎么找）、传输层（怎么传）、会话层、表示层、应用层（传什么）； 4、TCP：双向的、稳定的、可靠的、有序的、不间断的数据流（打电话）；UDP：单向的、间断的、不可靠的数据包（写信）； 5、IP：连接至网络的每台计算机都是唯一的，32位数字，包括网络ID和主机ID；域名系统：将特定IP地址映射至字符串，映射由域名服务器系统维护； 6、客户端：向另一台计算机请求服务的计算机；服务器：处理客户端请求的计算机； 7、InetAddress：封装IP地址和DNS；ServerSocket：用来创建套接字（TCP）服务器；Socket：创建客户端套接字； 8、UDP（数据报）：DatagramPacket—邮包、DatagramSocket—邮递员；","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]}]