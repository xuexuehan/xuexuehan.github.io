[{"title":"计算机网络（四）","date":"2019-06-29T10:51:26.000Z","path":"2019/06/29/计算机网络-Common-Four/","text":"计网：一些问题总结。 1、请说一下HTTP的报文段是什么样的？ 1）请求方法 GET：请求获取Request——URL所标识的资源 POST：在Request——URL所标识的资源后附加资源 HEAD：请求获取由Request——URL所标识的资源的响应消息报头 PUT：请求服务器存储一个资源，由Request——URL作为其标识 DELETE：请求服务器删除由Request——URL所标识的资源 TRACE：请求服务器回送收到的请求信息（用于测试和诊断） CONNECT：保留 OPTIONS：请求查询服务器性能 2）URL URI全名为Uniform Resource Indentifier（统一资源标识），用来唯一的标识一个资源，是一个通用的概念，URI由两个主要的子集URL和URN组成。URL全名为Uniform Resource Locator（统一资源定位），通过描述资源的位置来标识资源。URN全名为Uniform Resource Name（统一资源命名），通过资源的名字来标识资源，与其所处的位置无关，这样即使资源的位置发生变动，其URN也不会变化。 3）协议版本 格式为HTTP/主版本号.次版本号，常用为：HTTP/1.1 HTTP/1.0 4）请求头部 Host：接受请求的服务器地址，可以是IP或者是域名 User-Agent：发送请求的应用名称 Connection：指定与连接相关的属性，例如（Keep_Alive，长连接） Accept-Charset：通知服务器端可以发送的编码格式 Accept-Encoding：通知服务器端可以发送的数据压缩格式 Accept-Language：通知服务器端可以发送的语言 1）协议版本，同请求报文 2）状态码，100~199表示请求已收到继续处理，200~299表示成功，300~399表示资源重定向，400~499表示客户端请求出错，500~599表示服务器端出错 200：响应成功 302：跳转，重定向 400：客户端有语法错误 403：服务器拒绝提供服务 404：请求资源不存在 500：服务器内部错误 3）响应头部 Server：服务器应用软件的名称和版本 Content-Type：响应正文的类型 Content-Length：响应正文的长度 Content-Charset：响应正文所使用的编码 Content-Encoding：响应正文使用的数据压缩格式 Content-Language：响应正文使用的语言 2、请回答一下HTTP用的什么连接？ 在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。但从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。 3、请说一说TCP的三次握手，以及为什么不是两次？ 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 为什么不是两次： 在服务端对客户端的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果客户端并没有收到服务端的回应呢？此时，客户端仍认为连接未建立，服务端会对已建立的连接保存必要的资源，如果大量的这种情况，服务端会崩溃。 4、请说一下在浏览器中输入一个网址它的运行过程是怎样的？ 1）查询DNS，获取域名对应的IP。 检查浏览器缓存、检查本地hosts文件是否有这个网址的映射，如果有，就调用这个IP地址映射，解析完成。 如果没有，则查找本地DNS解析器缓存是否有这个网址的映射，如果有，返回映射，解析完成。 如果没有，则查找填写或分配的首选DNS服务器，称为本地DNS服务器。服务器接收到查询时： ​ 如果要查询的域名包含在本地配置区域资源中，返回解析结果，查询结束，此解析具有权威性。 ​ 如果要查询的域名不由本地DNS服务器区域解析，但服务器缓存了此网址的映射关系，返回解析结果，查询结束，此解析不具有权威性。 如果本地DNS服务器也失效： 如果未采用转发模式（迭代），本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后，会判断这个域名（如.com）是谁来授权管理，并返回一个负责该顶级域名服务器的IP，本地DNS服务器收到顶级域名服务器IP信息后，继续向该顶级域名服务器IP发送请求，该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如http://baidu.com）的IP给本地DNS服务器，循环往复直至查询到映射，将解析结果返回本地DNS服务器，再由本地DNS服务器返回解析结果，查询完成。 如果采用转发模式（递归），则此DNS服务器就会把请求转发至上一级DNS服务器，如果上一级DNS服务器不能解析，则继续向上请求。最终将解析结果依次返回本地DNS服务器，本地DNS服务器再返回给客户机，查询完成。 2）得到目标服务器的IP地址及端口号（http 80端口，https 443端口），会调用系统库函数socket，请求一个TCP流套接字。客户端向服务器发送HTTP请求报文： 应用层：客户端发送HTTP请求报文。 传输层：（加入源端口、目的端口）建立连接。实际发送数据之前，三次握手客户端和服务器建立起一个TCP连接。 网络层：（加入IP头）路由寻址。 数据链路层：（加入frame头）传输数据。 物理层：物理传输bit。 3）服务器端经过物理层→数据链路层→网络层→传输层→应用层，解析请求报文，发送HTTP响应报文。 4）关闭连接，TCP四次挥手。 5）客户端解析HTTP响应报文，浏览器开始显示HTML。 5、请说一说http rest？ REST(Representational State Transfer)一种轻量级的Web Service架构。可以完全通过HTTP协议实现。其实现和操作比SOAP和XML-RPC更为简洁，还可以利用缓存Cache来提高响应速度，性能、效率和易用性上都优于SOAP协议。REST架构对资源的操作包括获取、创建、修改和删除资源的操作对应HTTP协议提供的GET、POST、PUT和DELETE方法。REST提供了一组架构约束，当作为一个整体来应用时，强调组件交互的可伸缩性、接口的通用性、组件的独立部署、以及用来减少交互延迟、增强安全性、封装遗留系统的中间组件。REST架构约束： 客户-服务器（Client-Server），提供服务的服务器和使用服务的客户需要被隔离对待，客户和服务器之间通过一个统一的接口来互相通讯。 无状态（Stateless），服务端并不会保存有关客户的任何状态，客户端自身负责用户状态的维持，并在每次发送请求时都需要提供足够的信息。 可缓存（Cachable），REST系统需要能够恰当地缓存请求，以尽量减少服务端和客户端之间的信息传输，以提高性能。 分层系统（Layered System），服务器和客户之间的通信必须被这样标准化：允许服务器和客户之间的中间层（Ross：代理，网关等）可以代替服务器对客户的请求进行回应，而且这些对客户来说不需要特别支持。 统一接口（Uniform Interface），客户和服务器之间通信的方法必须是统一化的。 6、请说一说get和 post区别？ GET：从指定的资源请求数据。POST：向指定的资源提交要被处理的数据。 由于HTTP的规定和浏览器/服务器的限制，导致它们在应用过程中体现出一些不同。 7、请说一下tcp和udp的区别？ 1）TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接2）TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;**UDP尽最大努力交付，即不保 证可靠交付** 3）TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） 4）每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 5）TCP首部开销20字节;UDP的首部开销小，只有8个字节 6）TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 8、请说一下为什么tcp可靠，哪些方法保证可靠？ 1）确认和重传机制建立连接时三次握手同步双方的“序列号 + 确认号 + 窗口大小信息”，是确认重传、流控的基础 传输过程中，如果Checksum校验失败、丢包或延时，发送端重传。 2） 数据排序 TCP有专门的序列号SN字段，可提供数据re-order 3） 流量控制 滑动窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量，发送方通过维持一个发送滑动窗口来确保不会发生由于发送方报文发送太快接收方无法及时处理的问题。 4） 拥塞控制 TCP的拥塞控制由4个核心算法组成： “慢启动”（Slow Start） “拥塞避免”（Congestion avoidance） “快速重传 ”（Fast Retransmit） “快速恢复”（Fast Recovery） 9、请说一说TCP的流量控制？ 滑动窗口机制：滑动窗口协议的基本原理就是在任意时刻，发送方都维持了一个连续的允许发送的帧的序号，称为发送窗口；同时，接收方也维持了一个连续的允许接收的帧的序号，称为接收窗口。发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同。不同的滑动窗口协议窗口大小一般不同。发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧。 举例： 发送和接受方都会维护一个数据帧的序列，这个序列被称作窗口。发送方的窗口大小由接受方确定，目的在于控制发送速度，以免接受方的缓存不够大，而导致溢出，同时控制流量也可以避免网络拥塞。图中的4,5,6号数据帧已经被发送出去，但是未收到关联的ACK，7,8,9帧则是等待发送。可以看出发送端的窗口大小为6，这是由接受端告知的（事实上必须考虑拥塞窗口cwnd，这里暂且考虑cwnd&gt;rwnd）。此时如果发送端收到4号ACK，则窗口的左边缘向右收缩，窗口的右边缘则向右扩展，此时窗口就向前“滑动了”，即数据帧10也可以被发送。 10、请回答一下ipv6的位数？ IPv6的128位地址通常写成8组，每组由四个十六进制数组成。 11、请说一说osi七层模型？ 1）物理层在OSI参考模型中，物理层（Physical Layer）是参考模型的最低层，也是OSI模型的第一层。 物理层的主要功能是：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。 物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 2）数据链路层 数据链路层（Data Link Layer）是OSI模型的第二层，负责建立和管理节点间的链路。该层的主要功能是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。 在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。 该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。 MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制； LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。 数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。 3）网络层 网络层（Network Layer）是OSI模型的第三层，它是OSI参考模型中最复杂的一层，也是通信子网的最高一层。它在下两层的基础上向资源子网提供服务。其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。 一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。 在实现网络层功能时，需要解决的主要问题如下： 寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。 交换：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。 路由算法：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。 连接服务：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。 4）传输层 OSI下3层的主要任务是数据通信，上3层的任务是数据处理。而传输层（Transport Layer）是OSI模型的第4层。因此该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。 该层的主要任务是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。该层常见的协议：TCP/IP中的TCP协议、Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议。 传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。综上，传输层的主要功能如下： 传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。 处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。 监控服务质量。 5）会话层 会话层（Session Layer）是OSI模型的第5层，是用户应用程序和网络之间的接口，主要任务是：向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。 用户可以按照半双工、单工和全双工的方式建立会话。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC（介质访问控制子层）地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。域名（DN）就是一种网络上使用的远程地址例如：www.3721.com就是一个域名。会话层的具体功能如下： 会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。 会话流量控制：提供会话流量控制和交叉会话功能。 寻址：使用远程地址建立会话连接。l 出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。 6）表示层 表示层（Presentation Layer）是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。表示层的具体功能如下： 数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。 数据的编码：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。 压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。 数据的加密和解密：可以提高网络的安全性。 7）应用层 应用层（Application Layer）是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外，该层还负责协调各个应用程序间的工作。 应用层为用户提供的服务和协议有：文件服务、目录服务、文件传输服务（FTP）、远程登录服务（Telnet）、电子邮件服务（E-mail）、打印服务、安全服务、网络管理服务、数据库服务等。上述的各种网络服务由该层的不同应用协议和程序完成，不同的网络操作系统之间在功能、界面、实现技术、对硬件的支持、安全可靠性以及具有的各种应用程序接口等各个方面的差异是很大的。应用层的主要功能如下： 用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。 实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。 12、请说一说DNS解析过程？ 1）浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址，如果有，解析结束。同时域名被缓存的时间也可通过TTL属性来设置。2）如果浏览器缓存中没有（专业点叫还没命中），浏览器会检查操作系统缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在windows中可通过c盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的ip地址，那浏览器会首先使用这个ip地址。 但是这种操作系统级别的域名解析规程也被很多黑客利用，通过修改你的hosts文件里的内容把特定的域名解析到他指定的ip地址上，造成所谓的域名劫持。所以在windows7中将hosts文件设置成了readonly，防止被恶意篡改。 3）如果至此还没有命中域名，才会真正的请求本地域名服务器（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。 4）如果LDNS仍然没有命中，就直接跳到Root Server 域名服务器请求解析 5）根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址 6）此时LDNS再发送请求给上一步返回的gTLD 7）接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器 8）Name Server根据映射关系表找到目标ip，返回给LDNS 9）LDNS缓存这个域名和对应的ip 10）LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束 13、 请说一说http和https区别？ HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。HTTPS和HTTP的区别主要如下： https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 14、请说一下https中SSL层原理？ SSL利用数据加密、身份验证和消息完整性验证机制，为网络上数据的传输提供安全性保证。SSL支持各种应用层协议。由于SSL位于应用层和传输层之间，所以可以为任何基于TCP等可靠连接的应用层协议提供安全性保证。 1）身份验证机制 SSL利用数字签名来验证通信对端的身份。非对称密钥算法可以用来实现数字签名。由于通过私钥加密后的数据只能利用对应的公钥进行解密，因此根据解密是否成功，就可以判断发送者的身份，如同发送者对数据进行了“签名”。例如，Alice使用自己的私钥对一段固定的信息加密后发给Bob，Bob利用Alice的公钥解密，如果解密结果与固定信息相同，那么就能够确认信息的发送者为Alice，这个过程就称为数字签名。使用数字签名验证身份时，需要确保被验证者的公钥是真实的，否则，非法用户可能会冒充被验证者与验证者通信。如下图所示，Cindy冒充Bob，将自己的公钥发给Alice，并利用自己的私钥计算出签名发送给Alice，Alice利用“Bob”的公钥（实际上为Cindy的公钥）成功验证该签名，则Alice认为Bob的身份验证成功，而实际上与Alice通信的是冒充Bob的Cindy。SSL利用PKI提供的机制保证公钥的真实性。 2）数据传输的机密性 SSL加密通道上的数据加解密使用对称密钥算法，目前主要支持的算法有DES、3DES、AES等，这些算法都可以有效地防止交互数据被破解。对称密钥算法要求解密密钥和加密密钥完全一致。因此，利用对称密钥算法加密传输数据之前，需要在通信两端部署相同的密钥。 3）消息完整性验证 为了避免网络中传输的数据被非法篡改，SSL利用基于MD5或SHA的MAC算法来保证消息的完整性。MAC算法是在密钥参与下的数据摘要算法，能将密钥和任意长度的数据转换为固定长度的数据。利用MAC算法验证消息完整性的过程如下图所示。发送者在密钥的参与下，利用MAC算法计算出消息的MAC值，并将其加在消息之后发送给接收者。接收者利用同样的密钥和MAC算法计算出消息的MAC值，并与接收到的MAC值比较。如果二者相同，则报文没有改变；否则，报文在传输过程中被修改，接收者将丢弃该报文。 MAC算法要求通信双方具有相同的密钥，否则MAC值验证将会失败。因此，利用MAC算法验证消息完整性之前，需要在通信两端部署相同的密钥。 4）利用非对称密钥算法保证密钥本身的安全 对称密钥算法和MAC算法要求通信双方具有相同的密钥，否则解密或MAC值验证将失败。因此，要建立加密通道或验证消息完整性，必须先在通信双方部署一致的密钥。SSL利用非对称密钥算法加密密钥的方法实现密钥交换，保证第三方无法获取该密钥。如下图所示，SSL客户端（如Web浏览器）利用SSL服务器（如Web服务器）的公钥加密密钥，将加密后的密钥发送给SSL服务器，只有拥有对应私钥的SSL服务器才能从密文中获取原始的密钥。SSL通常采用RSA算法加密传输密钥。（Server端公钥加密密钥，私钥解密密钥） 实际上，SSL客户端发送给SSL服务器的密钥不能直接用来加密数据或计算MAC值，该密钥是用来计算对称密钥和MAC密钥的信息，称为premaster secret。SSL客户端和SSL服务器利用premaster secret计算出相同的主密钥（master secret），再利用master secret生成用于对称密钥算法、MAC算法等的密钥。premaster secret是计算对称密钥、MAC算法密钥的关键。 5）利用PKI保证公钥的真实性 PKI通过数字证书来发布用户的公钥，并提供了验证公钥真实性的机制。数字证书（简称证书）是一个包含用户的公钥及其身份信息的文件，证明了用户与公钥的关联。数字证书由权威机构——CA签发，并由CA保证数字证书的真实性。 SSL客户端把密钥加密传递给SSL服务器之前，SSL服务器需要将从CA获取的证书发送给SSL客户端，SSL客户端通过PKI判断该证书的真实性。如果该证书确实属于SSL服务器，则利用该证书中的公钥加密密钥，发送给SSL服务器。 验证SSL服务器/SSL客户端的身份之前，SSL服务器/SSL客户端需要将从CA获取的证书发送给对端，对端通过PKI判断该证书的真实性。如果该证书确实属于SSL服务器/SSL客户端，则对端利用该证书中的公钥验证SSL服务器/SSL客户端的身份。 15、请说一说TCP断连过程，以及单向连接关闭后还能否通信？ 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。四次挥手过程：（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 （2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 （3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 （4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。 四次挥手原因：这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 16、请说说TCP和UDP用一个端口发送信息是否冲突？ 不冲突，TCP、UDP可以绑定同一端口来进行通信，许多协议已经这样做了，例如DNS适用于udp / 53和tcp / 53。因为数据接收时时根据五元组{传输协议，源IP，目的IP，源端口，目的端口}判断接受者的。 17、请说说HTTP常见头？ 1）Accept：text/html, application/xhtml+xml, application/xml;q=0.9, image/webp, image/apng, /; q=0.8作用：向服务器申明客户端（浏览器）可以接受的媒体类型（MIME）的资源 解释：浏览器可以接受text/html、application/xhtml+xml、application/xml类型，通配符/ 表示任意类型的数据。并且浏览器按照该顺序进行接收。( text/html —&gt; application/xhtml+xml —&gt; application/xml) 2）Accept-encoding: gzip, deflate, br 作用：向服务器申明客户端（浏览器）接收的编码方法，通常为压缩方法 解释：浏览器支持采用经过gzip，deflate 或 br 压缩过的资源 3）Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7 作用：向服务器申明客户端（浏览器）接收的语言 解释：浏览器能够接受en-US, en 和 zh-CN 三种语言，其中 en-US 的权重最高 ( q 最高为1，最低为 0)，服务器优先返回 en-US 语言 延伸：语言与字符集的区别：zh-CN 为汉语，汉语中有许多的编码：gbk2312 等 4）Cache-control: max-age=0 作用：控制浏览器的缓存，常见值为private、no-cache、max-age、alidate，默认为 private，根据浏览器查看页面不同的方式来进行区别 解释：浏览器在访问了该页面后，不再会访问服务器 5）Cookie: 作用：告诉服务器关于Session 的信息，存储让服务器辨识用户身份的信息。 6）Refer：https://www.baidu.com/xxxxxxxxxx 作用：告诉服务器该页面从哪个页面链接的 解释：该页面从https://www.baidu.com 中的搜索结果中点击过来的 7）Upgrade-insecure-requests：1 作用：申明浏览器支持从http 请求自动升级为 https 请求，并且在以后发送请求的时候都使用 https 解释：当页面中包含大量的http 资源的时候（图片、iframe），如果服务器发现一旦存在上述的响应头的时候，会在加载 http 资源的时候自动替换为 https 请求 8）User-agent：Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36 作用：向服务器发送浏览器的版本、系统、应用程序的信息。 解释：Chrome 浏览器的版本信息为 63.0.3239.132，并将自己伪装成 Safari，使用的是 WebKit 引擎，WebKit伪装成 KHTML，KHTML伪装成Gecko（伪装是为了接收那些为Mozilla、safari、gecko编写的界面） 延伸：可以随便填（但不应该随便填）不过一般用于统计。 9）X-Chrome-UMA-Enabled、X-Client-Data ：与 Chrome 浏览器相关的数据 Response Headers 18、请说说soket编程和http协议？ 由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。 很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。 19、请说说tcp四次挥手？ 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。四次挥手过程： （1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 （2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 （3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 （4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。 四次挥手原因：这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 20、请说一说http缓存问题，缓存寿命，以及怎么判断文件在服务器是否更改的？ 1）缓存的类型:缓存是一种保存资源副本并在下次请求中直接使用该副本的技术，缓存能够节约网络资源，提升页面响应速度。常见的缓存类型分为共享缓存和私有缓存 私有缓存 私有缓存只能用于单独用户，常见的浏览器缓存便是私有缓存。私有缓存能够存储用户通过http下载过的文档，从而在用户再次访问时直接提供给用户，而不用向服务器发送请求。 共享缓存 共享缓存能够被多个用户使用，常用的web代理中便使用的共享缓存 2）缓存寿命 缓存寿命的计算的依据依次是： 请求头中的Cache-Control: max-age=N。相应的缓存寿命即为 N，从设置开始，N秒之后过期。 Expires属性，Expires属性的值为过期的时间点，在这个时间点后，该缓存被认为过期 Last-Modified信息。缓存的寿命为头里面 Date表示的事件点减去 Last-Modified的时间点的结果乘以 10% 3）判断文件是否更改可以看文件时间戳 21、请回答一下搜索敏感词汇时，页面被重置的原理？ 根据TCP协议的规定，用户和服务器建立连接需要三次握手：第一次握手用户向服务器发送SYN数据包发出请求（SYN, x:0），第二次握手服务器向用户发送SYN/ACK数据包发出回应（SYN/ACK, y:x+1），第三次握手用户向服务器发送ACK数据包发出确认（ACK, x+1:y+1），至此一个TCP连接建立成功。其中x为用户向服务器发送的序列号，y为服务器向用户发送的序列号。关键字检测，针对明文或者base64等弱加密通讯内容，与准备好的敏感词库进行匹配，当发现敏感词时，将服务器发回的SYN/ACK包改成SYN/ACK, Y:0，这代表TCP连接被重置，用户便主动放弃了连接，提示连接失败。让用户误认为服务器拒绝连接，而主动放弃继续与服务器连接，自动阻断记录含有敏感词的网页 22、 请你说一说两个机器之间的通讯过程？以及计算机网络为什么有七层？ PC1 首先判断目标ip是否和自己在同一网段，是就进行ARP广播，解析出MAC地址。不是，则将网关的MAC地址作为MAC地址。PC1封装的数据包括目标、源的端口号、IP、MAC地址。交换机收到数据后，对比MAC地址表，知道从哪个口发出数据。路由收到数据后根据路由表将数据发往下一个目标地。最后一个路由通过ARP解析出PC2的MAC地址。路由封装的数据包括目标、源的端口号、IP、MAC地址。建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题。它的最大优点是将服务、接口和协议这三个概念明确地区分开来：服务说明某一层为上一层提供一些什么功能，接口说明上一层如何使用下层的服务，而协议涉及如何实现本层的服务；这样各层之间具有很强的独立性，互连网络中各实体采用什么样的协议是没有限制的，只要向上提供相同的服务并且不改变相邻层的接口就可以了。网络七层的划分也是为了使网络的不同功能模块（不同层次）分担起不同的职责，从而带来如下好处： 减轻问题的复杂程度，一旦网络发生故障，可迅速定位故障所处层次，便于查找和纠错； 在各层分别定义标准接口，使具备相同对等层的不同网络设备能实现互操作，各层之间则相对独立，一种高层协议可放在多种低层协议上运行； 能有效刺激网络技术革新，因为每次更新都可以在小范围内进行，不需对整个网络动大手术； 23、请说一说什么是http协议，http的数据段包括什么？http 为什么是无状态的，http和https的区别?ip地址的abcd类是怎样分的，ABCD分层协议为什么如此分层，什么是长连接和短链接？ 什么是http协议？http（hyperText transport Protocol）是超文本传输协议的缩写，它用于传送www方式的数据，关于http协议采用了请求/响应模型，客户端向服务器发送了一个请求，服务器以一个状态行作为响应 http的数据段包括什么？ 通常http消息包括客户机向服务器请求消息和服务器向客户机的响应消息，这两种类型的消息由一个起始行，一个或多个头域，一个指示头域结束的空行和可选的消息体组成，http的头域包括通用头，请求头，响应头，和实体头四个部分，每个头域由一个域名，冒号，和域值三部分组成，域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩张成多行，在每行开始处，使用至少一个空格或制表符。 http为什么是无状态的？ 无状态是指协议对于事务处理没有记忆能力，因为http协议目的在于支持超文本的传输，更加广义一点就是支持资源的传输，那么在客户端浏览器向服务器发送请求，继而服务器将相应的资源发回客户这样一个过程中，无论对于客户端还是服务器，都没有必要记录这个过程，因为每一次请求和响应都是相对独立的，一般而言，一个url对应唯一的超文本，正因为这样d唯一性，所以http协议被设计为无状态的链接协议符合他本身的需求。 http和https的区别? http和https的区别主要如下： 1）https需要到ca申请证书，因而需要一定费用 2）http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议 3）http的连接很简单，是无状态的，https协议是由ssl+http协议构建的可进行加密串苏，身份验证的网络协议 4）http用的端口是80，https用的端口是443 ip地址的abcd类是怎样分的 A类地址的表示范围是：0.0.0.0-126.255.255.255，默认网络掩码为：255.0.0.0，A类地址分配给规模特别大的网络使用， B类地址表示范围是：128.0.0.0-191.255.255.255，默认网络掩码为欸：255.255.0.0，B类地址分配给一般的中型网络 C类地址的表示范围是192.0.0.0-223.255.255.255，默认网络掩码是：255.255.255.0，C类地址分配给小型网络，如局域网 D类地址称为广播地址，共特殊协议向选定的节点发送信息使用。 这样便于寻址和层次化的构造网络。 什么是长连接和短连接? http1.0中默认使用短连接，服务器和客户端没进行一次http操作，就建立一次连接，任务结束就终端连接，http1.1起。默认使用长连接，用以保持连接特性，当一个网页打开完成后，服务器和客户端之间用于传输http数据的tcp连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立好的连接。 24、请说一说tcp数据段都包括什么？tcp三次握手四次挥手过程、为什么挥手是四次？ TCP数据段：源端口（Source port） 和 目的端口（Destination port）： 字段标明了一个连接的两个端点用来跟踪同一时间内通过网络的不同会话。一般每个端口对应一个应用程序 序列号(Sequence number)：字节号 (32 位)，表示一个字节的编号 初始序列号ISNs(initial sequence numbers )：随机产生的 SYN：携带了ISNs 和SYN 控制位的数据段 确认号（Acknowledgement number）：期望接收的字节号 (32位) TCP段头长度（TCP header length）： TCP段头长度， 单位32位（4字节） 保留域/字段：逐步启用,如做拥塞控制等 URG：当紧急指针使用的时候，URG 被置为1。紧急指针是一个对于当前序列号的字节偏移量，标明紧急数据从哪里开始 当URG=1时，表明有紧急数据，必须首先处理收方收到这样的数据后，马上处理，处理完后恢复正常操作即使win=0，也可以发送这样的数据 ACK：为1 表示确认号有效，为0 标明确认号无效 PSH：表示这是带有PUSH标志的数据，接收方收到这样的数据，应该立刻送到上层，而不需要缓存它 RST：被用来重置一个已经混乱的连接 SYN：用在连接建立过程中 SYN=1，ACK=0 连接请求，当SYN=1，ACK=1 连接接受 FIN： 被用来释放连接，它表示发送方已经没有数据要传输了，但是可以继续接收数据 Window size： 告诉对方可以发送的数据字节数，从确认字节号开始（决定于接收方） Checksum：提供额外的可靠性，校验的范围包括头部、数据和概念性的伪头部 选项域：选项域提供了一种增加基本头没有包含内容的方法 Tcp三次握手： 1）第一次握手，客户端发送syn=j到服务器 2）服务器返回syn=k,ack=j+1, 3）客户端再向服务器发送ack=k+1; 三次握手结束，客户端和服务器建立连接 TCP四次挥手： 1）客户端发送fin=j包关闭连接 2）服务器返回ack=j+1 3）服务器发送fin=k包关闭连接 4）客户端返回ack=k+1 四次挥手结束，连接断开 为什么连接三次，断开连接四次？ 在连接中，服务器的ack和syn包是同时发送的，而在断开连接的时候，服务器向客户端发送的ack和fin包是分两次发送的，因为服务器收到客户端发送的fin包时，可能还有数据要传送，所以先发送ack，等数据传输结束后再发送fin断开这边的连接。 25、请说一下tcp与udp的区别，以及tcp为什么可靠，tcp滑动窗口，同传，拆包组装包是如何实现的？ TCP和UDP区别在于：1）TCP提供面向对象的连接，通信前要建立三次握手机制的连接，UDP提供无连接的传输，传输前不用建立连接 2）TCP提供可靠的，有序的，不丢失的传输，UDP提供不可靠的传输 3）TCP提供面向字节流的传输，它能将信息分割成组，并在接收端将其充足，UDP提供面向数据报的传输，没有分组开销 4）TCP提供拥塞控制，流量控制机制，UDP没有 TCP为什么可靠 1）确认和重传机制 建立连接时三次握手连接机制是确认重传流量控制的基础，传输过程中如果校验失败，丢包或延时，发送端重传 2）数据排序 TCP有专门的序列号字段，可提供数据reorder 3）流量控制 TCP窗口会指明双方能够发送接收的最大数据量 4）拥塞控制 TCP滑动窗口 TCP建立连接时，各端分配一个缓冲区用来存储接受的数据，并将缓冲区的尺寸发送给另一端，接收方发送的确认消息中包含了自己剩余的缓冲区尺寸，剩余缓冲区空间的数量叫做窗口，所谓滑动窗口，就是接收端可以根据自己的状况通告窗口大小，从而控制发送端的接收，进行流量控制. Tcp如何进行拆包、组装包？ 拆包：对于拆包目前常用的是以下两种方式：1）动态缓冲区暂存方式。之所以说缓冲区是动态的是因为当需要缓冲的数据长度超出缓冲区的长度时会增大缓冲区长度。大概过程描述如下：A 为每一个连接动态分配一个缓冲区，同时把此缓冲区和 SOCKET 关联，常用的是通过结构体关联。B 当接收到数据时首先把此段数据存放在缓冲区中。C 判断缓存区中的数据长度是否够一个包头的长度，如不够，则不进行拆包操作。D 根据包头数据解析出里面代表包体长度的变量。E 判断缓存区中除包头外的数据长度是否够一个包体的长度，如不够，则不进行拆包操作。F 取出整个数据包，这里的”取”的意思是不光从缓冲区中拷贝出数据包，而且要把此数据包从缓存区中删除掉。删除的办法就是把此包后面的数据移动到缓冲区的起始地址。 这种方法有两个缺点： 为每个连接动态分配一个缓冲区增大了内存的使用； 有三个地方需要拷贝数据，一个地方是把数据存放在缓冲区，一个地方是把完整的数据包从缓冲区取出来，一个地方是把数据包从缓冲区中删除。这种拆包的改进方法会解决和完善部分缺点。 2）利用底层的缓冲区来进行拆包由于TCP也维护了一个缓冲区，所以我们完全可以利用TCP的缓冲区来缓存我们的数据，这样一来就不需要为每一个连接分配一个缓冲区了。另一方面我们知道 recv 或者 wsarecv 都有一个参数，用来表示我们要接收多长长度的数据。利用这两个条件我们就可以对第一种方法进行优化了。对于阻塞 SOCKET 来说，我们可以利用一个循环来接收包头长度的数据，然后解析出代表包体长度的那个变量，再用一个循环来接收包体长度的数据。 26、请说一下tcp/ip四层网络协议？ TCP/IP四层网络协议分别是应用层，网络层，传输层，数据链路层 27、手写代码：从网络日志中，提取出date 字段，并排序？ 首先在grok中要用%{DATESTAMP:date}或者自定义模式去匹配你的时间然后在filter里， 12345filter&#123;date&#123;match =&gt;&#123;\"date\",\"yyyy-MM-dd HH:mm:ss:SSS\"&#125;&#125;&#125; 28、从打开浏览器输入url到到达服务器上项目中某一个Controller上，请你来描述一下这一串过程？ 这个过程中发生了网络通信，即利用ｔｃｐ／ｉｐ协议簇进行网络通信，发送端由应用层往下走，接收端由数据链路层往上走，步骤如下： 浏览器输入ｕｒｌ，其中http是协议 应用层DNS解析，返回对应的ip地址 应用层客户端发送http请求， 网络层ip查询ｍａｃ地址， 传输层ｔｃｐ传输报文 数据到达数据链路层，此时客户端发送请求结束 服务器在数据链路层收到数据包，再层层下上直到应用层， 服务器响应请求，查找客户端请求的资源并返回响应报文 29、请介绍下session？ Session：在web开发中，服务器可以为每个用户创建一个会话对象(session对象)，默认情况下一个浏览器独占一个session对象，因此在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其他程序时，其他程序可以从用户的session中取出该用户的数据，为用户服务，其实现原理是服务器创建session出来后，会把session的id号，以cookie的形式回写给客户机，这样只要客户机的浏览器不关，再去访问服务器时，都会带着session的id号去，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session服务。Session和cookie的区别： cookie是把用户的数据写给用户浏览器 session是把用户的数据写到用户独占的session中 session对象由服务器创建，开发人员可以调用request对象的getsession方法得到session对象 30、请问你知道跨域吗，条件是什么，在header里需要加什么，有几种方案？ 什么是跨域？浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域 跨域的几种方案： 基于script标签实现跨域 基于jquery跨域 通过iframe来跨子域 31、请来回答一下，比如淘宝的搜索算法，输入关键词，会给出搜索出来的商品结果，对于这样的算法，如何评价它的好坏？ 淘宝的搜索算法： 目标性比较强，当然，这个相对而言，从query来看，用户对目标商品的认知度相对较强 短query/符合query较多，传统搜索引擎里的xxx的商品这种query较少，当然，这与淘宝搜索的处理能力也有关系，用户对query进行分词的情况很常见 属性类query较为常见，如雪纺、鱼嘴等等表明用户特征的query较为常见 用户对结果的判断，基本上是价格敏感+信用敏感+销量敏感，其中销量敏感和信用敏感其实是一回事，来自知乎用户李杰。 对于这样的算法，笔者认为是很符合淘宝搜索要求的，能够更加精准。 32、商品的种类有几十万种，在这种大数据的情况下，如何评价搜索算法的好坏？ 在大数据时代，搜索算法最重要有三点，足够快，能够将用户所潜在需要的商品全部搜索出来，性能稳定。 博客转自：https://www.nowcoder.com/tutorial/97/bec3ecce724d4a84b6ee9880d64cf935","comments":true,"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"计算机网络（三）","date":"2019-06-29T09:25:10.000Z","path":"2019/06/29/计算机网络-Common-Three/","text":"计网：Socket概念总结。 I / O模型一个输入操作通常包括两个阶段： 等待数据准备好 从内核向进程复制数据 对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。 Unix 有五种 I/O 模型： 阻塞式 I/O 非阻塞式 I/O I/O 复用（select 和 poll） 信号驱动式 I/O（SIGIO） 异步 I/O（AIO） 阻塞式 I/O应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。 应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。 下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。 1ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); 非阻塞式 I/O应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。 由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。 I/O 复用使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。 它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。 如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。 信号驱动 I/O应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。 相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。 异步 I/O应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。 异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。 五大 I/O 模型比较 同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。 异步 I/O：第二阶段应用进程不会阻塞。 同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。 非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。 I/O 复用select / poll / epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。 select1int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。 fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。 timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。 成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。 123456789101112131415161718192021222324252627282930313233343536fd_set fd_in, fd_out;struct timeval tv;// Reset the setsFD_ZERO( &amp;fd_in );FD_ZERO( &amp;fd_out );// Monitor sock1 for input eventsFD_SET( sock1, &amp;fd_in );// Monitor sock2 for output eventsFD_SET( sock2, &amp;fd_out );// Find out which socket has the largest numeric value as select requires itint largest_sock = sock1 &gt; sock2 ? sock1 : sock2;// Wait up to 10 secondstv.tv_sec = 10;tv.tv_usec = 0;// Call the selectint ret = select( largest_sock + 1, &amp;fd_in, &amp;fd_out, NULL, &amp;tv );// Check if select actually succeedif ( ret == -1 ) // report error and abortelse if ( ret == 0 ) // timeout; no event detectedelse&#123; if ( FD_ISSET( sock1, &amp;fd_in ) ) // input event on sock1 if ( FD_ISSET( sock2, &amp;fd_out ) ) // output event on sock2&#125; poll1int poll(struct pollfd *fds, unsigned int nfds, int timeout); poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。 poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下： 12345struct pollfd &#123; int fd; /* file descriptor */ short events; /* requested events */ short revents; /* returned events */ &#125;; 1234567891011121314151617181920212223242526272829// The structure for two eventsstruct pollfd fds[2];// Monitor sock1 for inputfds[0].fd = sock1;fds[0].events = POLLIN;// Monitor sock2 for outputfds[1].fd = sock2;fds[1].events = POLLOUT;// Wait 10 secondsint ret = poll( &amp;fds, 2, 10000 );// Check if poll actually succeedif ( ret == -1 ) // report error and abortelse if ( ret == 0 ) // timeout; no event detectedelse&#123; // If we detect the event, zero it out so we can reuse the structure if ( fds[0].revents &amp; POLLIN ) fds[0].revents = 0; // input event on sock1 if ( fds[1].revents &amp; POLLOUT ) fds[1].revents = 0; // output event on sock2&#125; 比较1、功能： select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。 select 会修改描述符，而 poll 不会； select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制； poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。 如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。 2、速度：select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。 3、可移植性：几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。 epoll123int epoll_create(int size);int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。 从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。 epoll 仅适用于 Linux OS。 epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。 epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.// The function argument is ignored (it was not before, but now it is), so put your favorite number hereint pollingfd = epoll_create( 0xCAFE );if ( pollingfd &lt; 0 ) // report error// Initialize the epoll structure in case more members are added in futurestruct epoll_event ev = &#123; 0 &#125;;// Associate the connection class instance with the event. You can associate anything// you want, epoll does not use this information. We store a connection class pointer, pConnection1ev.data.ptr = pConnection1;// Monitor for input, and do not automatically rearm the descriptor after the eventev.events = EPOLLIN | EPOLLONESHOT;// Add the descriptor into the monitoring list. We can do it even if another thread is// waiting in epoll_wait - the descriptor will be properly addedif ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev ) != 0 ) // report error// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)struct epoll_event pevents[ 20 ];// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event arrayint ready = epoll_wait( pollingfd, pevents, 20, 10000 );// Check if epoll actually succeedif ( ret == -1 ) // report error and abortelse if ( ret == 0 ) // timeout; no event detectedelse&#123; // Check if any events detected for ( int i = 0; i &lt; ret; i++ ) &#123; if ( pevents[i].events &amp; EPOLLIN ) &#123; // Get back our connection pointer Connection * c = (Connection*) pevents[i].data.ptr; c-&gt;handleReadEvent(); &#125; &#125;&#125; 工作模式epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。 1、LT 模式： 当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。 2、ET 模式： 和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。 很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。 应用场景很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。 1、select 应用场景： select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。 select 可移植性更好，几乎被所有主流平台所支持。 2、poll 应用场景： poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。 3、epoll 应用场景： 只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。 需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。 需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。 博客转自：https://cyc2018.github.io/CS-Notes/#/notes/Socket","comments":true,"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"计算机网络（二）","date":"2019-06-28T14:13:58.000Z","path":"2019/06/28/计算机网络-Common-Two/","text":"计网：HTTP概念总结。 基础概念1、URI：URI 包含 URL 和 URN。 2、请求和响应报文： 1）请求报文： 2）响应报文： HTTP方法客户端发送的 请求报文 第一行为请求行，包含了方法字段。 1）GET - 获取资源：当前网络请求中，绝大部分使用的是 GET 方法。 2）HEAD - 获取报文首部： 和 GET 方法类似，但是不返回报文实体主体部分。 主要用于确认 URL 的有效性以及资源更新的日期时间等。 3）POST - 传输实体主体：POST 主要用来传输数据，而 GET 主要用来获取资源。 4）PUT - 上传文件：由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 123456PUT /new.html HTTP/1.1Host: example.comContent-type: text/htmlContent-length: 16&lt;p&gt;New File&lt;/p&gt; 5）PATCH - 对资源进行部分修改：PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 1234567PATCH /file.txt HTTP/1.1Host: www.example.comContent-Type: application/exampleIf-Match: \"e0023aa4e\"Content-Length: 100[description of changes] 6）DELETE - 删除文件：与 PUT 功能相反，并且同样不带验证机制。 1DELETE /file.html HTTP/1.1 7）OPTIONS - 查询支持的方法： 查询指定的 URL 能够支持的方法。 会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。 8）CONNECT - 要求在与代理服务器通信时建立隧道： 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 1CONNECT www.example.com:443 HTTP/1.1 9）TRACE - 追踪路径： 服务器会将通信路径返回给客户端。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。 通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。 HTTP 状态码服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 1、1XX 信息： 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。 2、2XX 成功： 200 OK 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。 3、3XX 重定向： 301 Moved Permanently ：永久性重定向 302 Found ：临时性重定向 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。 4、4XX 客户端错误： 400 Bad Request ：请求报文中存在语法错误。 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden ：请求被拒绝。 404 Not Found 5、5XX 服务器错误： 500 Internal Server Error ：服务器正在执行请求时发生错误。 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 HTTP 首部有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。 1、通用首部字段： 2、请求首部字段： 3、响应首部字段： 4、实体首部字段： 具体应用1、连接管理： 1）短连接与长连接： 当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。 长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close； 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。 2）流水线： 默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。 流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。 2、Cookie： HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。 Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。 Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。 1）用途： 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） 2）创建过程： 服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。 123456HTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry[page content] 客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。 123GET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry 3）分类： 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。 持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。 4）作用域： Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。 Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配： /docs /docs/Web/ /docs/Web/HTTP 5）JavaScript： 浏览器通过 document.cookie 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。 123document.cookie = \"yummy_cookie=choco\";document.cookie = \"tasty_cookie=strawberry\";console.log(document.cookie); 6）HttpOnly： 标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 document.cookie API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly 7）Secure： 标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。 8）Session： 除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。 Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。 使用 Session 维护用户登录状态的过程如下： 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。 应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。 9）浏览器禁用 Cookie： 此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。 10）Cookie 与 Session 选择： Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session； Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密； 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。 3、缓存 1）优点： 缓解服务器压力； 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。 2）实现方法： 让代理服务器进行缓存； 让客户端浏览器进行缓存。 3）Cache-Control：HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。 禁止进行缓存：no-store 指令规定不能对请求或响应的任何一部分进行缓存。 1Cache-Control: no-store 强制确认缓存：no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。 1Cache-Control: no-cache 私有缓存和公共缓存：private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。 1Cache-Control: private ​ public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。 1Cache-Control: public 缓存过期机制：max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。 ​ max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。 1Cache-Control: max-age=31536000 ​ Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。 1Expires: Wed, 04 Jul 2012 08:26:05 GMT 在 HTTP/1.1 中，会优先处理 max-age 指令； 在 HTTP/1.0 中，max-age 指令会被忽略掉。 4）缓存验证： 需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 http://www.google.com/ 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。 1ETag: \"82e22293907ce725faf67773957acd12\" 可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。 1If-None-Match: \"82e22293907ce725faf67773957acd12\" Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。 12Last-Modified: Wed, 21 Oct 2015 07:28:00 GMTIf-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT 4、内容协商 通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。 1）类型： 服务端驱动型：客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。 它存在以下问题： 服务器很难知道客户端浏览器的全部信息； 客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）； 给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。 代理驱动型：服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。 2）Vary： 1Vary: Accept-Language 在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。 例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 Vary: Accept-Language 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。 5、内容编码： 内容编码将实体主体进行压缩，从而减少传输的数据量。 常用的内容编码有：gzip、compress、deflate、identity。 浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。 6、范围请求：如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。 1）Range：在请求报文中添加 Range 首部字段指定请求的范围。 123GET /z4d4kWk.jpg HTTP/1.1Host: i.imgur.comRange: bytes=0-1023 请求成功的话服务器返回的响应包含 206 Partial Content 状态码。 12345HTTP/1.1 206 Partial ContentContent-Range: bytes 0-1023/146515Content-Length: 1024...(binary content) 2）Accept-Ranges：响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。 1Accept-Ranges: bytes 3）响应状态码： 在请求成功的情况下，服务器会返回 206 Partial Content 状态码。 在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。 在不支持范围请求的情况下，服务器会返回 200 OK 状态码。 7、分块传输编码：Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。 8、多部分对象集合：一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。 例如，上传多个表单时可以使用如下方式： 123456789101112Content-Type: multipart/form-data; boundary=AaB03x--AaB03xContent-Disposition: form-data; name=\"submit-name\"Larry--AaB03xContent-Disposition: form-data; name=\"files\"; filename=\"file1.txt\"Content-Type: text/plain... contents of file1.txt ...--AaB03x-- 9、虚拟主机：HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。 10、通信数据转发： 1）代理：代理服务器接受客户端的请求，并且转发给其它服务器。 使用代理的主要目的是： 缓存 负载均衡 网络访问控制 访问日志记录 代理服务器分为正向代理和反向代理两种： 用户察觉得到正向代理的存在。 而反向代理一般位于内部网络中，用户察觉不到。 2）网关：与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。 3）隧道：使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。 HTTPsHTTP 有以下安全性问题： 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 1、加密： 1）对称密钥加密：对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。 优点：运算速度快； 缺点：无法安全地将密钥传输给通信方。 2）非对称密钥加密： 非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。 优点：可以更安全地将公开密钥传输给通信发送方； 缺点：运算速度慢。 3）HTTPS 采用的加密方式：HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥） 2、认证：通过使用 证书 来对通信方进行认证。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。 3、完整性保护： SSL 提供报文摘要功能来进行完整性保护。 HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。 HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。 4、HTTPS 的缺点： 因为需要进行加密解密等过程，因此速度会更慢； 需要支付证书授权的高额费用。 HTTP/2.01、HTTP/1.x 缺陷： HTTP/1.x 实现简单是以牺牲性能为代价的： 客户端需要使用多个连接才能实现并发和缩短延迟； 不会压缩请求和响应首部，从而导致不必要的网络流量； 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。 2、二进制分帧层： HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。 在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。 一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。 消息（Message）是与逻辑请求或响应对应的完整的一系列帧。 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。 3、服务端推送： HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。 4、首部压缩： HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。 HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。 不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。 HTTP/1.1 新特性 默认是长连接 支持流水线 支持同时打开多个 TCP 连接 支持虚拟主机 新增状态码 100 支持分块传输编码 新增缓存处理指令 max-age GET 和 POST 比较1、作用：GET 用于获取资源，而 POST 用于传输实体主体。 2、参数： GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。 因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。 1234GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 3、安全： 安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。 GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 安全的方法除了 GET 之外还有：HEAD、OPTIONS。 不安全的方法除了 POST 之外还有 PUT、DELETE。 4、幂等性： 幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。 所有的安全方法也都是幂等的。 在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。 GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的： 1234GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1 POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录： 123POST /add_row HTTP/1.1 -&gt; Adds a 1nd rowPOST /add_row HTTP/1.1 -&gt; Adds a 2nd rowPOST /add_row HTTP/1.1 -&gt; Adds a 3rd row DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样： 123DELETE /idX/delete HTTP/1.1 -&gt; Returns 200 if idX existsDELETE /idX/delete HTTP/1.1 -&gt; Returns 404 as it just got deletedDELETE /idX/delete HTTP/1.1 -&gt; Returns 404 5、可缓存： 如果要对响应进行缓存，需要满足以下条件： 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。 响应报文的 Cache-Control 首部字段没有指定不进行缓存。 6、XMLHttpRequest： 为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest： XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。 而 GET 方法 Header 和 Data 会一起发送。 博客转自：https://cyc2018.github.io/CS-Notes/#/notes/HTTP","comments":true,"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"计算机网络（一）","date":"2019-06-28T06:40:00.000Z","path":"2019/06/28/计算机网络-Common-One/","text":"计网：基础概念和五层协议。 概念1、主机之间的通信方式： 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。 对等（P2P）：不区分客户和服务器。 2、电路交换与分组交换： 1）电路交换：电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。 2）分组交换： 每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。 在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。 3、时延： 总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延 1）排队时延：分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 2）处理时延：主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。 3）传输时延：主机或路由器传输数据帧所需要的时间。 其中 l 表示数据帧的长度，v 表示传输速率。 4）传播时延：电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。 其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。 4、计算机网络体系结构： 1）五层协议： 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 2） OSI： 其中表示层和会话层用途如下： 表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 会话层 ：建立及管理会话。 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。 3）TCP/IP： 它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 4）数据在各层之间的传递过程： 在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。 路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。 物理层1、通信方式： 根据信息在传输线上的传送方向，分为以下三种通信方式： 单工通信：单向传输 半双工通信：双向交替传输 全双工通信：双向同时传输 2、带通调制： 模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。 链路层1、基本问题： 1）封装成帧：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 2）透明传输：透明表示一个实际存在的事物看起来好像不存在一样。 帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 3）差错检测：目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。 2、信道分类： 1）广播信道： 一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。 所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。 主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。 2）点对点信道： 一对一通信。 因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。 3、信道复用技术： 1）频分复用：频分复用的所有主机在相同的时间占用不同的频率带宽资源。 2 ）时分复用：时分复用的所有主机在不同的时间占用相同的频率带宽资源。 使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。 3）统计时分复用：是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。 4）波分复用：光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 5）码分复用：为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片S 和 T有： 为了讨论方便，取 m=8，设码片 S 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。 在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到： 其中 S‘ 为 S 的反码。 利用上面的式子我们知道，当接收端使用码片 S 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。 码分复用需要发送的数据量为原先的 m 倍。 4、CSMA/CD 协议： CSMA/CD 表示载波监听多点接入 / 碰撞检测。 多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。 载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。 5、PPP协议：互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 PPP 的帧格式： F 字段为帧的定界符 A 和 C 字段暂时没有意义 FCS 字段是使用 CRC 的检验序列 信息部分的长度不超过 1500 6、MAC 地址： MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。 一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。 7、局域网： 局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。 主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。 可以按照网络拓扑结构对局域网进行分类： 8、以太网：是一种星型拓扑结构局域网。 早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。 目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。 以太网帧格式： 类型 ：标记上层使用的协议； 数据 ：长度在 46-1500 之间，如果太小则需要填充； FCS ：帧检验序列，使用的是 CRC 检验方法； 9、交换机： 交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。 正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。 下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。 10、虚拟局域网： 虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。 例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。 使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。 网络层1、概述： 因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。 使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protocol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） 2、IP 数据报格式： 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 3、IP 地址编址方式： IP 地址的编址方式经历了三个历史阶段： 分类 子网划分 无分类 1）分类：由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 2）子网划分： 通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。 注意，外部网络看不到子网的存在。 3）无分类： 无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。 CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 4、地址解析协议 ARP：网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。 ARP 实现由 IP 地址得到 MAC 地址。 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。 如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。 5、网际控制报文协议 ICMP：ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。 ICMP 报文分为差错报告报文和询问报文。 1）Ping： Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。 Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。 2）Traceroute： Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。 Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文； 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。 6、虚拟专用网 VPN： 由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。 有三个专用地址块： 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。 下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。 7、网络地址转换 NAT： 专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 8、路由器的结构： 路由器从功能上可以划分为：路由选择和分组转发。 分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。 9、路由器分组转发流程： 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 报告转发分组出错。 10、路由选择协议： 路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。 互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。 可以把路由选择协议划分为两大类： 自治系统内部的路由选择：RIP 和 OSPF 自治系统间的路由选择：BGP 1）内部网关协议 RIP： RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。 RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 距离向量算法： 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1； 对修改后的 RIP 报文中的每一个项目，进行以下步骤： 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中； 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。 RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。 2）内部网关协议 OSPF： 开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。 开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。 OSPF 具有以下特点： 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。 只有当链路状态发生变化时，路由器才会发送信息。 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。 3） 外部网关协议 BGP： BGP（Border Gateway Protocol，边界网关协议） AS 之间的路由选择很困难，主要是由于： 互联网规模很大； 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量； AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。 BGP 只能寻找一条比较好的路由，而不是最佳路由。 每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。 传输层1、概述：网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 2、UDP 和 TCP 的特点： 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 3、UDP 首部格式： 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 4、TCP 首部格式： 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 5、TCP 的三次握手： 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 三次握手的原因： 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 6、TCP 的四次挥手： 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 四次挥手的原因： 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。 7、TCP 可靠传输： TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下： 其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。 超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下： 其中 RTTd 为偏差的加权平均值。 8、TCP 滑动窗口： 窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 9、TCP 流量控制： 流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 10、TCP 拥塞控制： 如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 1）慢开始与拥塞避免： 发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 2）快重传与快恢复： 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 应用层1、域名系统： DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。 域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。 DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输： 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。 2、文件传送协议： FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件： 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。 数据连接：用来传送一个文件数据。 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式： 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。 3、动态主机配置协议： DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。 DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。 DHCP 工作过程如下： 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。 DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。 DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。 4、远程登录协议： TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。 TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 5、电子邮件协议： 一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。 邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 1）SMTP： SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。 2）POP3：POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。 3）IMAP：IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 6、常用端口： 7、Web 页面请求过程： 1）DHCP 配置主机信息： 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。 2）ARP 解析 MAC 地址： 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。 DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。 3）DNS 解析域名： 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 4）HTTP 请求页面： 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。 HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。 HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。 博客转自：https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%951","comments":true,"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"Java基础（五）","date":"2019-06-25T11:50:24.000Z","path":"2019/06/25/Java-Common-Five/","text":"Java：多线程、 volatile、synchronized、死锁。 多线程1、在操作系统中进程和线程的区别： 进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位） 线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位） 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。 多进程是指操作系统能同时运行多个任务（程序）。 多线程是指在同一程序中有多个顺序流在执行。 2、在java中要想实现多线程，有两种手段，一种是继承Thread类，另外一种是实现Runable接口.(其实准确来讲，应该有三种，还有一种是实现Callable接口，并与Future、线程池结合使用。 3、扩展java.lang.Thread类： 继承Thread类的方法是比较常用的一种，如果说你只是想起一条线程。没有什么其它特殊的要求，那么可以使用Thread.（推荐使用Runable）。 1234567891011121314151617181920212223242526//start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。//从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。public class Thread1 extends Thread &#123; private String name; public Thread1(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(name + \"运行 : \" + i); try &#123; sleep((int) Math.random() * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; Thread1 mTh1=new Thread1(\"A\"); Thread1 mTh2=new Thread1(\"B\"); mTh1.start(); mTh2.start(); &#125;&#125; 4、实现java.lang.Runnable接口： 采用Runnable也是非常常见的一种，我们只需要重写run方法即可。 123456789101112131415161718192021222324//Thread2类通过实现Runnable接口，使得该类有了多线程类的特征。run（）方法是多线程程序的一个约定。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。//在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。//实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。public class Thread2 implements Runnable &#123; private String name; public Thread2(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(name + \"运行 : \" + i); try &#123; Thread.sleep((int) Math.random() * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; new Thread(new Thread2(\"C\")).start(); new Thread(new Thread2(\"D\")).start(); &#125;&#125; 5、Thread和Runnable的区别： 如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。 实现Runnable接口比继承Thread类所具有的优势： 适合多个相同的程序代码的线程去处理同一个资源； 可以避免java中的单继承的限制； 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立； 线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类。 6、线程状态转换： 1）新建状态（New）：新创建了一个线程对象。 2 ）就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。 3）运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。 4）阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种： 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁) 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁） 5）死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 7、线程调度： 1）调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。 Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量： 123456static int MAX_PRIORITY //线程可以具有的最高优先级，取值为10。static int MIN_PRIORITY //线程可以具有的最低优先级，取值为1。static int NORM_PRIORITY //分配给线程的默认优先级，取值为5。 Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。 2）线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。 3）线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。 4）线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。 5）线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。 6）线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。 8、线程同步： 1）synchronized关键字的作用域有二种： 是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法； 是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。 2）除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){//区块}，它的作用域是当前对象； 3）synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法； Java对多线程的支持与同步机制深受大家的喜爱，似乎看起来使用了synchronized关键字就可以轻松地解决多线程共享数据同步问题。到底如何？――还得对synchronized关键字的作用进行深入了解才可定论。 总的说来，synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。 无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。 每个对象只有一个锁（lock）与之相关联。 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。 volatile1、Java语言为了解决并发编程中存在的原子性、可见性和有序性问题，提供了一系列和并发处理相关的关键字，比如synchronized、volatile、final、concurren包等。 2、volatile的用法： volatile通常被比喻成”轻量级的synchronized“，也是Java并发编程中比较重要的一个关键字。和synchronized不同，volatile是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。 volatile的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用volatile修饰就可以了。 123456789101112131415//是一个比较典型的使用双重锁校验的形式实现单例的，其中使用volatile关键字修饰可能被多个线程同时访问到的singleton。public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 3、volatile的原理： 为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。 但是，对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。 但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议。 缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。 所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。 4、volatile与可见性： 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。 Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。 5、volatile与有序性： 有序性即程序执行的顺序按照代码的先后顺序执行。 除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是可能存在有序性问题。 而volatile除了可以保证数据的可见性之外，还有一个强大的功能，那就是他可以禁止指令重排优化等。 普通的变量仅仅会保证在该方法的执行过程中所依赖的赋值结果的地方都能获得正确的结果，而不能保证变量的赋值操作的顺序与程序代码中的执行顺序一致。 volatile可以禁止指令重排，这就保证了代码的程序会严格按照代码的先后顺序执行。这就保证了有序性。被volatile修饰的变量的操作，会严格按照代码顺序执行，load-&gt;add-&gt;save 的执行顺序就是：load、add、save。 6、volatile与原子性： 原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。 线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。 为了保证原子性，需要通过字节码指令monitorenter和monitorexit，但是volatile和这两个指令之间是没有任何关系的。 所以，volatile是不能保证原子性的。 在以下两个场景中可以使用volatile来代替synchronized： 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。 变量不需要与其他状态变量共同参与不变约束。 Synchronized1、synchronized，是Java中用于解决并发情况下数据同步访问的一个很重要的关键字。当我们想要保证一个共享资源在同一时间只会被一个线程访问到时，我们可以在代码中使用synchronized关键字对类或者对象加锁。 2、synchronized关键字在需要原子性、可见性和有序性这三种特性的时候都可以作为其中一种解决方案，看起来是“万能”的。的确，大部分并发控制操作都能使用synchronized来完成。 3、synchronized的用法：synchronized是Java提供的一个并发控制的关键字。主要有两种用法，分别是同步方法和同步代码块。也就是说，synchronized既可以修饰方法也可以修饰代码块。 被synchronized修饰的代码块及方法，在同一时间，只能被单个线程访问。 4、synchronized的实现原理： synchronized，是Java中用于解决并发情况下数据同步访问的一个很重要的关键字。当我们想要保证一个共享资源在同一时间只会被一个线程访问到时，我们可以在代码中使用synchronized关键字对类或者对象加锁。 5、synchronized与原子性： 原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。 线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。 在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。这两个字节码指令，在Java中对应的关键字就是synchronized。 通过monitorenter和monitorexit指令，可以保证被synchronized修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。 6、synchronized与可见性： 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。 被synchronized修饰的代码，在开始执行时会加锁，执行完成后会进行解锁。而为了保证可见性，有一条规则是这样的：对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。 所以，synchronized关键字锁住的对象，其值是具有可见性的。 7、synchronized与有序性： 有序性即程序执行的顺序按照代码的先后顺序执行。 除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是可能存在有序性问题。 这里需要注意的是，synchronized是无法禁止指令重排和处理器优化的。也就是说，synchronized无法避免上述提到的问题。 那么，为什么还说synchronized也提供了有序性保证呢？ 这就要再把有序性的概念扩展一下了。Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。 as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守as-if-serial语义。 简单说就是，as-if-serial语义保证了单线程中，指令重排是有一定的限制的，而只要编译器和处理器都遵守了这个语义，那么就可以认为单线程程序是按照顺序执行的。当然，实际上还是有重排的，只不过我们无须关心这种重排的干扰。 所以呢，由于synchronized修饰的代码，同一时间只能被同一线程访问。那么也就是单线程执行的。所以，可以保证其有序性。 ReentranceLock 和 synchronized区别1）可重入性：字面的意思就是可以再次进入的锁，synchronized其实也是可重锁，同一线程每进入一次，锁的计数器都会加一，在释放锁是计数器都会减一，只有当计数器为0 时才能释放锁。 2）锁的实现：ReentrantLock是JDK实现的， Synchronized 是JVM实现 。前者可以直接看到源码，后者实现难以看到。 3）性能的区别：在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。 4）功能的区别： 便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。 锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized。 当需要使用以下三种功能是需要使用ReentrantLock： ReentranLock 可以指定公平锁还是非公平锁 ，（公共锁就是先等待的线程先获得锁）实现自旋锁，通过循环调用CAS操作来实现加锁，性能比较好，避免进入内核态的线程阻塞； 提供了Condition类，可以分组唤醒需要唤醒的线程，提供能够中断等待锁的线程的机制，lock.lockInterruptibly()； 具体使用场景要根据实际的业务进行分析 ，使用Synchronized时不需要释放锁，jvm会帮助我们做释放锁的操作。 死锁1、死锁是指在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所占用不会释放的资源而处于的一种永久等待状态。死锁的四个必要条件： 互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。 请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源。 非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。 循环等待条件(Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。 2、java中产生死锁可能性的最根本原因是： 多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环； 默认的锁申请操作是阻塞的。 3、避免死锁： 破坏死锁的循环等待条件。 破坏死锁的请求与保持条件，使用lock的特性，为获取锁操作设置超时时间。这样不会死锁（至少不会无尽的死锁） 设置一个条件遍历与一个锁关联。该方法只用一把锁，没有chopstick类，将竞争从对筷子的争夺转换成了对状态的判断。仅当左右邻座都没有进餐时才可以进餐。提升了并发度。 4、linux中查看死锁进程状态： 使用pstack 和 gdb 工具对死锁程序进行分析。 pstack 进程号： 查看各个线程的堆栈信息。 当进程吊死的时候，多次使用，死锁的线程将一直处于等锁的状态，确定某些线程一直没有变化，一直处于等锁的状态。那么这些线程很可能是死锁了。如果怀疑哪些线程发生死锁了，可以采用gdb 进一步attach线程并进行分析。 执行命令gdb attach 进程号，进入gdb调试终端。 运行：(gdb) info thread。 博客转自： https://blog.csdn.net/evankaka/article/details/44153709 https://www.hollischuang.com/?s=%E5%A4%9A%E7%BA%BF%E7%A8%8B https://www.nowcoder.com/tutorial/97/a119ecb875cd4d56a3111cccb25ab05c","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础（四）","date":"2019-06-25T07:51:29.000Z","path":"2019/06/25/Java-Common-Four/","text":"Java：泛型、 String、集合类、Comparable和Comparator。 泛型1、Java泛型：允许在定义类和接口的时候使用类型参数（type parameter）。声明的类型参数在使用时用具体的类型来替换。从好的方面来说，泛型的引入可以解决之前的集合类框架在使用过程中通常会出现的运行时刻类型错误，因为编译器可以在编译时刻就发现很多明显的错误。而从不好的地方来说，为了保证与旧有版本的兼容性，Java泛型的实现上存在着一些不够优雅的地方。 2、类型擦除（type erasure）：Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的List 和List等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是Java的泛型实现方式与C++模板机制实现方式之间的重要区别。 很多泛型的奇怪特性都与这个类型擦除的存在有关，包括： 泛型类并没有自己独有的Class类对象。比如并不存在List.class或是List.class，而只有List.class。 静态变量是被泛型类的所有实例所共享的。对于声明为MyClass的类，访问其中的静态变量的方法仍然是 MyClass.myStaticVar； 不管是通过new MyClass;还是new MyClass创建的对象，都是共享一个静态变量； 泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException;和MyException的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的catch语句。 3、类型擦除的基本过程也比较简单：首先是找到用来替换类型参数的具体类。这个具体类一般是Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。同时去掉出现的类型声明，即去掉&lt;&gt;的内容。比如: T get()方法声明就变成了Object get()； List就变成了List。 接下来就可能需要生成一些桥接方法（bridge method）。这是由于擦除了类型之后的类可能缺少某些必须的方法。 12345class MyString implements Comparable&lt;String&gt; &#123; public int compareTo(String str) &#123; return 0; &#125;&#125; 当类型信息被擦除之后，上述类的声明变成了class MyString implements Comparable。但是这样的话，类MyString就会有编译错误，因为没有实现接口Comparable声明的int compareTo(Object)方法。这个时候就由编译器来动态生成这个方法。 StringQ1：String s = new String(“promissing”)；定义了几个对象。 Q2：如何理解String的intern方法？ A1：在编译期，符号引用s和字面量Hollis会被加入到Class文件的常量池中，然后在类加载阶段，这两个常量会进入常量池。但是，这个“进入”阶段，并不会直接把所有类中定义的常量全部都加载进来，而是会做个比较，如果需要加到字符串常量池中的字符串已经存在，那么就不需要再把字符串字面量加载进来了。所以，当我们说&lt;若常量池中已经存在”hollis”，则直接引用，也就是此时只会创建一个对象&gt;说的就是这个字符串字面量在字符串池中被创建的过程。 在运行期，new String(“promissing”);执行到的时候，是要在Java堆中创建一个字符串对象的，而这个对象所对应的字符串字面量是保存在字符串常量池中的。但是，String s = new String(“promissing”);，对象的符号引用s是保存在Java虚拟机栈上的，他保存的是堆中刚刚创建出来的的字符串对象的引用。 A2：当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用。 1、运行时常量池的动态扩展：编译期生成的各种字面量和符号引用是运行时常量池中比较重要的一部分来源，但是并不是全部。那么还有一种情况，可以在运行期向运行时常量池中增加常量。那就是String的intern方法。 intern()有两个作用，第一个是将字符串字面量放入常量池（如果池没有的话），第二个是返回这个常量的引用。 2、字符串是常量，在定义之后不能被改变，字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享它们。 1）定义： 123//从该类的声明中我们可以看出String是final类型的，表示该类不能被继承，同时该类实现了三个接口：java.io.Serializable、 Comparable&lt;String&gt;、 CharSequencepublic final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;&#125; 2）属性： 1234567//这是一个字符数组，并且是final类型，他用于存储字符串内容，从fianl这个关键字中我们可以看出，String的内容一旦被初始化了是不能被更改的。 虽然有这样的例子： String s = “a”; s = “b” 但是，这并不是对s的修改，而是重新指向了新的字符串， 从这里我们也能知道，String其实就是用char[]实现的private final char value[];//缓存字符串的hash Code，默认值为 0private int hash;//因为String实现了Serializable接口，所以支持序列化和反序列化。Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidCastException)private static final long serialVersionUID = -6849794470754667710L;private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0]; 3）方法： 3、字符串的不变性： 12//定义一个字符串String s = \"abcd\"; s中保存了string对象的引用。下面的箭头可以理解为“存储他的引用”。 12//使用变量来赋值变量String s2 = s; s2保存了相同的引用值，因为他们代表同一个对象。 12//字符串连接s = s.concat(\"ef\"); s中保存的是一个重新创建出来的string对象的引用。 总结： 一旦一个string对象在内存(堆)中被创建出来，他就无法被修改。特别要注意的是，String类的所有方法都没有改变字符串本身的值，都是返回了一个新的对象。 如果需要一个可修改的字符串，应该使用StringBuffer 或者 StringBuilder。否则会有大量时间浪费在垃圾回收上，因为每次试图修改都有新的string对象被创建出来。 4、不可变的好处： 可以缓存 hash 值：因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 String Pool 的需要：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 安全性：String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。 线程安全：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。 5、String、StringBuffer和StrngBuilder 可变性： String 不可变； StringBuffer 和 StringBuilder 可变。 线程安全： String 不可变，因此是线程安全的； StringBuilder 不是线程安全的； StringBuffer 是线程安全的，内部使用 synchronized 进行同步。 集合类1、Collection 和 Collections：首先要明确的是，Collection 和 Collections是两个不同的概念。Collection是一个接口，所有的集合类（除Map外）都要继承（实现）自该接口。它提供了对集合对象进行基本操作的通用接口方法。Collections是一个包装类，它包含有各种有关集合操作的静态多态方法。（Collections是一个工具类，不能实例化）。 2、Collection家族关系图： 1）Set： TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 2）List： ArrayList：基于动态数组实现，支持随机访问。 Vector：和 ArrayList 类似，但它是线程安全的。 LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 3）Queue： LinkedList：可以用它来实现双向队列。 PriorityQueue：基于堆结构实现，可以用它来实现优先队列。 3、Map家族的关系图： TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 4、关系图谱： 5、LinkedList与 ArrayList 的比较： ArrayList 基于动态数组实现，LinkedList 基于双向链表实现； ArrayList 支持随机访问，LinkedList 不支持； LinkedList 在任意位置添加删除元素更快。 6、HashMap与HashTable 的比较： HashTable 使用 synchronized 来进行同步，HashTable是线程安全的，它的方法是同步了的，可以直接用在多线程环境中。HashMap则不是线程安全的。在多线程环境中，需要手动实现同步机制； 在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，既可以表示HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键，而应该用containsKey()方法来判断。而在HashTable中，无论是key还是value都不能为null。 HashMap 的迭代器是 fail-fast 迭代器； HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。 7、ConcurrentHashMap：HashTable中采用的锁机制是一次锁住整个hash表，从而同一时刻只能有一个线程对其进行操作；而ConcurrentHashMap中则是一次锁住一个桶。ConcurrentHashMap默认将hash表分为16个桶，诸如get，put，remove等常用操作只锁住当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。 上面说到的16个线程指的是写线程，而读操作大部分时候都不需要用到锁。只有在size等操作时才需要锁住整个hash表。 在迭代方面，ConcurrentHashMap使用了一种不同的迭代方式。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是，在改变时new新的数据从而不影响原有的数据，iterator完成后再将头指针替换为新的数据，这样iterator可以使用原来老的数据，而写线程也可以并发的完成改变。 Comparable和Comparator当需要排序的集合或数组不是单纯的数字型时，通常可以使用Comparator或Comparable，以简单的方式实现对象排序或自定义排序。 1、Comparator：强行对某个对象collection进行整体排序的比较函数，可以将Comparator传递给Collections.sort或Arrays.sort。 1234567891011121314151617181920212223242526import java.util.Arrays;import java.util.Comparator;public class SampleComparator implements Comparator &#123; @Override public int compare(Object o1, Object o2) &#123; return toInt(o1) - toInt(o2); &#125; private int toInt(Object o) &#123; String str = (String) o; str = str.replaceAll(\"一\", \"1\"); str = str.replaceAll(\"二\", \"2\"); str = str.replaceAll(\"三\", \"3\"); return Integer.parseInt(str); &#125; public static void main(String[] args) &#123; String[] array = new String[] &#123;\"一二\", \"三\", \"二\" &#125;; Arrays.sort(array, new SampleComparator()); for(int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]); &#125; &#125;&#125;结果：二三一二 2、Comparable：强行对实现它的每个类的对象进行整体排序，实现此接口的对象列表（和数组）可以通过Collections.sort或Arrays.sort进行自动排序。 12345678910111213141516171819202122232425262728293031323334353637//对象User，需要按年龄排序import java.util.Arrays;public class User implements Comparable &#123; private String id; private int age; public User(String id, int age) &#123; this.id = id; this.age = age; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public int compareTo(Object o) &#123; return this.age - ((User)o).getAge(); &#125; public static void main(String[] args) &#123; User[] users = new User[] &#123; new User(\"a\", 30), new User(\"b\", 20) &#125;; Arrays.sort(users); for (int i = 0; i &lt; users.length; i++) &#123; User user = users[i]; System.out.println(user.getId() + \" \" + user.getAge()); &#125; &#125;&#125;结果：b 20a 30 1234567891011121314151617//Comparator对User集合实现排序的方式import java.util.Arrays;import java.util.Comparator;public class UserComparator implements Comparator &#123; @Override public int compare(Object o1, Object o2) &#123; return ((User) o1).getAge() - ((User) o2).getAge(); &#125; public static void main(String[] args) &#123; User[] users = new User[] &#123; new User(\"a\", 30), new User(\"b\", 20) &#125;; Arrays.sort(users, new UserComparator()); for (int i = 0; i &lt; users.length; i++) &#123; User user = users[i]; System.out.println(user.getId() + \" \" + user.getAge()); &#125; &#125;&#125; 3、Comparator和Comparable的区别： 一个类实现了Camparable接口则表明这个类的对象之间是可以相互比较的，这个类对象组成的集合就可以直接使用sort方法排序。 Comparator可以看成一种算法的实现，将算法和数据分离，Comparator也可以在下面两种环境下使用： 类的设计师没有考虑到比较问题而没有实现Comparable，可以通过Comparator来实现排序而不必改变对象本身； 可以使用多种排序标准，比如升序、降序等。 博客转自： https://www.hollischuang.com/archives/230 https://www.hollischuang.com/archives/1330 https://blog.csdn.net/zhangerqing/article/details/8093387","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础（三）","date":"2019-06-25T02:36:36.000Z","path":"2019/06/25/Java-Common-Three/","text":"Java：异常处理机制、 访问修饰符、关键字、Object类、拆箱与装箱、反射。 异常处理机制1、About：Java为我们提供了非常完美的异常处理机制，使得我们可以更加专心的去写程序，有的时候遇到需要添加异常处理块的地方，IDE会有自动提示，我们看看异常处理的一些类的结构组成： 从根部开始分为两大类：Error和Exception。Error是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。Exception是程序本身可以处理的异常，这种异常分两大类：非运行时异常（发生在编译阶段，又称checkException)和运行时异常（发生在程序运行过程中，又叫uncheckException）。非运行时异常一般就是指一些没有遵守Java语言规范的代码，容易看的出来，并且容易解决的异常，运行时异常是那些在程序运行过程中产生的异常，具有不确定性，如空指针异常等，造成空指针的原因很多，所以运行时异常具有不确定性，往往难以排查，还有就是程序中存在的逻辑错误，光从一段代码中看不出问题，需要纵观全局才能发现的错误，也会造成运行时异常，这就要求我们在写程序时多多注意，尽量去处理异常，当异常发生时，希望程序能朝理想的方面运行！ 2、异常的类型： 一方面我们可以将异常分为受控异常和不受控异常，其实一般来讲，受控异常就是非运行时异常，不受控异常就是运行时异常和Error。另一方面，我们直接将异常分为非运行时异常和运行时异常。 3、异常处理的过程： 使用try/catch/finally语句块安装异常处理程序，每个try块中包含可能出现异常的语句，每个catch块中包含处理异常的程序，不论程序有无异常，finally块中的语句都会执行。 当程序处理不了异常的时候会怎么办？是这样的：当前方法如果声明了相应的异常处理器，如果加了catch(NumberFormatException e)，则直接抛出，但是如果没有声明，则会找到它的调用者，如果调用者也没有做相应的处理，则会一直往前找，直到找到main方法，最后抛出异常！此处简单总结下异常处理的过程： 在可能出错的方法加上try/catch块语句，来调用异常处理器。 当异常发生时，直接跳到相应的异常处理器catch中，如果有则抛出异常，执行该catch块中的语句，如果没有，则找到它的调用者，直到main方法。 如果有finally块，则执行finally块中的语句。 注意： 一个try可对应多个catch。 有try必须至少有一个catch或者finally。 finally块不是必须的，可有可无。 一般情况下，当异常发生时，会执行catch块中的语句，特殊情况：当main方法中抛出异常时，如果程序声明了该异常处理器，则执行相应的catch块中的语句，如果程序没有声明相应的异常处理器，则不执行catch块中的语句，直接抛出异常！那么，这个异常来源于哪儿？既然main中有try/catch语句（虽然不是对应的异常处理器），为什么没有抛出，说明main方法中的try/catch块根本就没有捕捉到异常，那么系统怎么处理？其实是这样的，这种情况下，异常被直接丢给JVM，而JVM的处理方式就是：直接中断你的程序！ 4、常见异常： NullPointerException 空指针：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。 ClassNotFoundException 找不到类：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。 ClassCastException 类型转换。 ArithmeticException 算数条件，算术条件异常。譬如：整数除零等。 ArrayIndexOutOfBoundsException 数组越界，数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。 5、常见问题： 1）finally和return问题：finally中的内容不论程序有无异常，都会被执行，那么如果我们的程序在try和catch块中return了，finally中的还会执行吗？ 即使有return语句，finally块也一定会被执行！ 2）尽量不要将catch和finally一起使用。 try/catch/finally一起使用，在《Big Java》一书中提到，不建议这样做，因为会影响程序的可读性，最好的做法是：用try/catch嵌套，catch用来捕获异常，finally用来关闭资源，如下： 12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) &#123; boolean file = open(); System.out.println(\"this is main return value:\" + file); &#125; public static boolean open() &#123; String filename = \"d:\\\\test.txtp\"; try &#123; try &#123; FileReader reader = new FileReader(filename); Scanner in = new Scanner(reader); String input = in.next(); int value = Integer.parseInt(input); System.out.println(value); return true; &#125; finally &#123; // 一些关闭资源的操作 System.out.println(\"this is finally block!\"); &#125; &#125; catch (FileNotFoundException e) &#123; System.out.println(\"this is catch_for_filenot... block!\"); return false; &#125; &#125;&#125; 3）自定义异常：可以根据自己的需要，进行自定义异常处理器。 12345678910111213141516171819//自定义异常处理器，继承Exception或者RuntimeException，依情况而定.public class NameNotSupportException extends RuntimeException &#123; private static final long serialVersionUID = 777777777777L; public NameNotSupportException(String message) &#123; super(message); &#125;&#125;public class DefineTest &#123; public static void main(String[] args) &#123; String name = \"xuexue\"; if(!\"promissing\".equals(name)) &#123; throw new NameNotSupportException(\"promissing\"); &#125; else &#123; System.out.println(\"ok\"); &#125; &#125;&#125;Exception in thread \"main\" com.ZJ02.NameNotSupportException: promissing at com.xx.DefineTest.main(DefineTest.java:7) protected、public、private区别访问修饰符：public、protected、默认、private（都可以修饰属性和方法，只有默认和public可以修饰类）； public：所有类都可以访问（本类、同包、异包下的子类、异包下的其他类）； protected：该类及其子类成员可以访问，同一个包中的可以访问（本类、同包、异包下的子类）； 默认：相同数据包里的可以访问（本类及其同包下的类可以访问）； private：只有该类可以访问。 关键字super、final、static1、this和super： this：自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。 普通的直接引用； 形参与成员名字重名，用this来区分； 12345678//age是GetAge成员方法的形参，this.age是Person类的成员变量class Person &#123; private int age = 10; public int GetAge(int age)&#123; this.age = age; return this.age; &#125;&#125; 引用构造函数。 super：指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。 普通的直接引用：与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员； 子类中的成员变量或方法与父类中的成员变量或方法同名； 1234567891011121314151617181920212223//既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。class Country &#123; String name; void value() &#123; name = \"China\"; &#125;&#125; class City extends Country &#123; String name; void value() &#123; name = \"Shanghai\"; super.value(); //调用父类的方法 System.out.println(name); System.out.println(super.name); &#125; public static void main(String[] args) &#123; City c = new City(); c.value(); &#125;&#125;结果：ShanghaiChina 引用构造函数： super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 2、final： final修饰类：这个类不能被继承。如：String类、StringBuffer类、System类； final修饰方法：不能被重写。如：Object类的getClass()方法； final修饰属性：此属性就是一个常量，一旦初始化就不可再被赋值。习惯上，常用大写字符表示。 3、static： 在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。 被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。 static变量：static修饰的变量我们称之为静态变量，没有用static修饰的变量称之为实例变量，他们两者的区别是； 静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。 但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。 static方法： static修饰的方法我们称之为静态方法，我们通过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现，也就是说他不能是抽象方法abstract。 Static方法是类中的一种特殊方法，我们只有在真正需要他们的时候才会将方法声明为static。如Math类的所有方法都是静态static的。 static局限： 只能调用static变量； 只能调用static方法； 不能以任何形式引用this、super； static变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。 总结：无论是变量，方法，还是代码块，只要用static修饰，就是在类被加载时就已经”准备好了”,也就是可以被使用或者已经被执行，都可以脱离对象而执行。反之，如果没有static，则必须要依赖于对象实例。 类加载器类加载器就是把类加载阶段中的”通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到java虚拟机外部来实现的代码模块。 类加载器的分类： 启动类加载器：这个类负责将存放在JAVA_HOME/lib目录或者被-Xbootclasspath参数所指定的路径中的并且是虚拟机内存中； 扩展类加载器：负责加载JAVA_HOME/lib/ext目录中或者被java.ext.dirs系统变量指定路径中的所有类库，开发者可以直接使用扩展类加载器； 应用程序类加载器：负责加载用户类路径上指定的类加载器，一般情况下就是程序中默认的类加载器。 Object通用方法1、equals()： 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法； 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。 2、hashCode()： hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。 3、toString()： 默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。 4、clone()： 1） cloneable：clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。 2）浅拷贝：拷贝对象和原始对象的引用类型引用同一个对象。 3）深拷贝：拷贝对象和原始对象的引用类型引用不同对象。 拆箱、装箱1、Java基本类型共有八种，基本类型可以分为三类： 字符类型char； 布尔类型boolean； 数值类型byte、short、int、long、float、double。 2、基本数据类型好处： 在Java语言中，new一个对象是存储在堆里的，我们通过栈中的引用来使用这些对象；所以，对象本身来说是比较消耗资源的。 对于经常用到的类型，如int等，如果我们每次使用这种变量的时候都需要new一个Java对象的话，就会比较笨重。所以，和C++一样，Java提供了基本数据类型，这种数据的变量不需要使用new创建，他们不会在堆上创建，而是直接在栈内存中存储，因此会更加高效。 3、包装类型：Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个基本数据类型对应的类统称为包装类(Wrapper Class)。 4、为什么需要包装类？ Java是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将int 、double等类型放进去的。因为集合的容器要求元素是Object类型。 为了让基本类型也具有对象的特征，就出现了包装类型，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。 5、自动拆箱与自动装箱： 自动装箱: 就是将基本数据类型自动转换成对应的包装类； 自动拆箱：就是将包装类自动转换成对应的基本数据类型。 12Integer i = 10; //自动装箱int b = i; //自动拆箱 自动装箱都是通过包装类的valueOf()方法来实现的，自动拆箱都是通过包装类对象的xxxValue()来实现的。 Java反射JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。Java反射可以用来获取一个class对象或实例化一个class表示的类的对象，还可以获取构造方法，成员变量，成员方法。 Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段； Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法； Constructor ：可以用 Constructor 创建新的对象。 博客转自： https://blog.csdn.net/zhangerqing/article/details/8248186 https://www.cnblogs.com/chenssy/p/3386721.html https://www.nowcoder.com/tutorial/97/41e1689116434042adf7b769470f14fc","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础（二）","date":"2019-06-24T11:15:21.000Z","path":"2019/06/24/Java-Common-Two/","text":"Java：跨平台、 String Pool、JVM内存机制、GC、内存泄露与溢出。 Java跨平台1、平台无关性：一种语言在计算机上的运行不受平台的约束，一次编译，到处执行（Write Once ，Run Anywhere）。 也就是说，用Java创建的可执行二进制程序，能够不加改变的运行于多个平台。 2、平台无关性的实现：对于Java的平台无关性的支持，就像对安全性和网络移动性的支持一样，是分布在整个Java体系结构中的。其中扮演者重要的角色的有Java语言规范、Class文件、Java虚拟机（JVM）等。 3、Java虚拟机： 对于不同的硬件和操作系统，最主要的区别就是指令不同。比如同样执行a+b，A操作系统对应的二进制指令可能是10001000，而B操作系统对应的指令可能是11101110。那么，想要做到跨平台，最重要的就是可以根据对应的硬件和操作系统生成对应的二进制指令。 而这一工作，主要由Java虚拟机完成。虽然Java语言是平台无关的，但是JVM却是平台有关的，不同的操作系统上面要安装对应的JVM。 所以，Java之所以可以做到跨平台，是因为Java虚拟机充当了桥梁。他扮演了运行时Java程序与其下的硬件和操作系统之间的缓冲角色。 4、字节码： 各种不同的平台的虚拟机都使用统一的程序存储格式——字节码（ByteCode）是构成平台无关性的另一个基石。Java虚拟机只与由自己码组成的Class文件进行交互。 我们说Java语言可以Write Once ,Run Anywhere。这里的Write其实指的就是生成Class文件的过程。 因为Java Class文件可以在任何平台创建，也可以被任何平台的Java虚拟机装载并执行，所以才有了Java的平台无关性。 5、Java语言规范： 已经有了统一的Class文件，以及可以在不同平台上将Class文件翻译成对应的二进制文件的Java虚拟机，Java就可以彻底实现跨平台了吗？ 其实并不是的，Java语言在跨平台方面也是做了一些努力的，这些努力被定义在Java语言规范中。 比如，Java中基本数据类型的值域和行为都是由其自己定义的。而C/C++中，基本数据类型是由它的占位宽度决定的，占位宽度则是由所在平台决定的。所以，在不同的平台中，对于同一个C++程序的编译结果会出现不同的行为。 通过保证基本数据类型在所有平台的一致性，Java语言为平台无关性提供强了有力的支持。 总结： 对于Java的平台无关性的支持是分布在整个Java体系结构中的。其中扮演着重要的角色的有Java语言规范、Class文件、Java虚拟机等。 Java语言规范：通过规定Java语言中基本数据类型的取值范围和行为； Class文件：所有Java文件要编译成统一的Class文件； Java虚拟机：通过Java虚拟机将Class文件转成对应平台的二进制文件等。 Java的平台无关性是建立在Java虚拟机的平台有关性基础之上的，是因为Java虚拟机屏蔽了底层操作系统和硬件的差异。 字符串常量池（String Pool）字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 123456789101112//s1 和 s2 采用 new String() 的方式新建了两个不同字符串String s1 = new String(\"aaa\");String s2 = new String(\"aaa\");System.out.println(s1 == s2); // false//s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。String s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true//如果采用 \"bbb\" 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。String s5 = \"bbb\";String s6 = \"bbb\";System.out.println(s5 == s6); // true new String(“abc”)：使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。 “abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量； 使用 new 的方式会在堆中创建一个字符串对象。 JVM内存机制 方法区：类结构的样子、静态属性、静态方法； 堆：对象的实例、数组； 栈：对象的引用、基本数据类型； 栈（最快）&gt; 堆（容量大、速度慢）。 123456789101112131415161718public class People &#123; private String name; private String sex; public static int myNum = 0; public void eat() &#123;&#125; public void sleep() &#123;&#125; public static void think() &#123;&#125; public People(String name, String sex) &#123; this.name = name; this.sex = sex; &#125; public static void main(String[] args) &#123; int[] num = &#123;1, 2, 3&#125;; int a = 1; People p1 = new People(\"叮当\", \"男\"); People p2 = new People(\"超人\", \"男\"); &#125;&#125; 上述代码对应的内存图示如下： JVM内存结构：Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。 JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。 程序计数器（PC Register）：是当前线程所执行的字节码的行号指示器。在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 每条线程都有一个独立的程序计数器，所以程序计数器是线程私有的内存区域。 Java虚拟机栈：描述Java方法执行的内存模型，每个方法执行的同时会创建一个栈帧，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 Java虚拟机栈是线程私有的，它的生命周期与线程相同。 本地方法栈：本地方法栈与虚拟机栈的区别：虚拟机栈为虚拟机执行Java方法服务（也就是字节码），而本地方法栈为虚拟机使用到的Native方法服务。 Java堆：Java堆是被所有的线程共享的一块内存区域，在虚拟机启动时创建。Java堆的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 Java堆是垃圾回收器管理的主要区域，从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆可以细分为：新生代、老生代；从内存分配的角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区（TLAB）。 方法区：被所有的线程共享的一块内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 Java内存模型：Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。 Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。 在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。 Java对象模型：Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。 每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。 总结： JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。 垃圾回收机制垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。 引用：如果Reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。 强引用（Strong Reference）：如“Object obj = new Object（）”，这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。 软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2之后提供了SoftReference类来实现软引用。 弱引用（Weak Reference）：它也是用来描述非须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。 虚引用（Phantom Reference）：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供了PhantomReference类来实现虚引用。 对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆（heap）中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”.当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。但是，为了保证GC能够在不同平台实现的问题，Java规范对GC的很多行为都没有进行严格的规定。例如，对于采用什么类型的回收算法、什么时候进行回收等重要问题都没有明确的规定。因此，不同的JVM的实现者往往有不同的实现算法。这也给Java程序员的开发带来行多不确定性。 增量式GC（IncrementalGC）：设计GC的时候，就必须在停顿时间和回收率之间进行权衡。增量式GC就是通过一定的回收算法，把一个长时间的中断，划分为很多个小的中断，通过这种方式减少GC对用户程序的影响。 为什么要进行垃圾回收？ 随着程序的运行，内存中存在的实例对象、变量等信息占据的内存越来越多，如果不及时进行垃圾回收，必然会带来程序性能的下降，甚至会因为可用内存不足造成一些不必要的系统异常。 哪些“垃圾”需要回收？ 有三个是不需要进行垃圾回收的：程序计数器、JVM栈、本地方法栈。因为它们的生命周期是和线程同步的，随着线程的销毁，它们占用的内存会自动释放，所以只有方法区和堆需要进行GC。具体到哪些对象的话，简单概况一句话：如果某个对象已经不存在任何引用，那么它可以被回收。通俗解释一下就是说，如果一个对象，已经没有什么作用了，就可以被当废弃物被回收了。 什么时候进行垃圾回收？ 根据一个经典的引用计数算法，每个对象添加一个引用计数器，每被引用一次，计数器加1，失去引用，计数器减1，当计数器在一段时间内保持为0时，该对象就认为是可以被回收得了。但是，这个算法有明显的缺陷：当两个对象相互引用，但是二者已经没有作用时，按照常规，应该对其进行垃圾回收，但是其相互引用，又不符合垃圾回收的条件，因此无法完美处理这块内存清理，因此Sun的JVM并没有采用引用计数算法来进行垃圾回收。而是采用一个叫：根搜索算法，如下图： 基本思想就是：从一个叫GC Roots的对象开始，向下搜索，如果一个对象不能到达GC Roots对象的时候，说明它已经不再被引用，即可被进行垃圾回收（此处 暂且这样理解，其实事实还有一些不同，当一个对象不再被引用时，并没有完全“死亡”，如果类重写了finalize()方法，且没有被系统调用过，那么系统会调用一次finalize()方法，以完成最后的工作，在这期间，如果可以将对象重新与任何一个和GC Roots有引用的对象相关联，则该对象可以“重生”，如果不可以，那么就说明彻底可以被回收了），如上图中的Object5、Object6、Object7，虽然它们3个依然可能相互引用，但是总体来说，它们已经没有作用了，这样就解决了引用计数算法无法解决的问题。 为什么要分代? 分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。 在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。 虚拟机中的共划分为三个代：年轻代(Young Generation)、年老代(Old Generation)和持久代(Permanent Generation)。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。 年轻代：所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区(两个中的一个)，当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的(多于两个)，这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。 年老代：在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 持久代：用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显着影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。 什么情况下触发垃圾回收？ 由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。 Scavenge GC：一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。 Full GC：对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC： 年老代(Tenured)被写满； 持久代(Perm)被写满； System.gc()被显示调用； 上一次GC之后Heap的各域分配策略动态变化。 常见的GC算法： 标记-清除算法（Mark-Sweep）：最基础的GC算法，将需要进行回收的对象做标记，之后扫描，有标记的进行回收，这样就产生两个步骤：标记和清除。这个算法效率不高，而且在清理完成后会产生内存碎片，这样，如果有大对象需要连续的内存空间时，还需要进行碎片整理，所以，此算法需要改进。 复制算法（Copying）：新生代内存分为了三份，Eden区和2块Survivor区，一般Sun的JVM会将Eden区和Survivor区的比例调为8:1，保证有一块Survivor区是空闲的，这样，在垃圾回收的时候，将不需要进行回收的对象放在空闲的Survivor区，然后将Eden区和第一块Survivor区进行完全清理，这样有一个问题，就是如果第二块Survivor区的空间不够大怎么办？这个时候，就需要当Survivor区不够用的时候，暂时借持久代的内存用一下。此算法适用于新生代。 标记-整理（或叫压缩）算法（Mark-Compact）：和标记-清楚算法前半段一样，只是在标记了不需要进行回收的对象后，将标记过的对象移动到一起，使得内存连续，这样，只要将标记边界以外的内存清理就行了。此算法适用于持久代。 常见的一些垃圾收集器： 串行GC（SerialGC）：是最基本、最古老的收集器，但是现在依然被广泛使用，是一种单线程垃圾回收机制，而且不仅如此，它最大的特点就是在进行垃圾回收的时候，需要将所有正在执行的线程暂停（Stop The World），对于有些应用这是难以接受的，但是我们可以这样想，只要我们能够做到将它所停顿的时间控制在N个毫秒范围内，大多数应用我们还是可以接受的，而且事实是它并没有让我们失望，几十毫米的停顿我们作为客户机（Client）是完全可以接受的，该收集器适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式。 并行GC（ParNew）：基本和Serial GC一样，但本质区别是加入了多线程机制，提高了效率，这样它就可以被用在服务器端（Server）上，同时它可以与CMS GC配合，所以，更加有理由将它置于Server端。 并行回收GC（Parallel Scavenge）：在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式。 CMS (Concurrent Mark Sweep)收集器。该收集器目标就是解决Serial GC 的停顿问题，以达到最短回收时间。常见的B/S架构的应用就适合用这种收集器，因为其高并发、高响应的特点。CMS收集器是基于“标记-清除”算法实现的。 总结：Java垃圾回收器是一种“自适应的、分代的、停止—复制、标记-清扫”式的垃圾回收器。 内存泄漏和溢出区别 内存泄漏（memory leak）：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。 内存溢出（ out of memory） ：指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。 博客转自： https://www.hollischuang.com/archives/category/java https://blog.csdn.net/zhangerqing/article/details/8214365#commentBox","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础（一）","date":"2019-06-23T02:29:29.000Z","path":"2019/06/23/Java-Common-one/","text":"Java：三大特性、 重写与重载、接口与抽象类。 封装、继承、多态1、封装：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。 使用封装的优点： 良好的封装能够减少耦合； 类内部的结构可以自由修改； 可以对成员进行更精确的控制； 隐藏信息，实现细节。 12345678910111213141516171819202122//封装可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码private String age ; //原来int类型，改成String类型的public void setAge(int age) &#123; //转换即可 this.age = String.valueOf(age);&#125;//可以对成员变量进行更精确的控制，对对象的入口、出口进行控制public void setAge(int age) &#123; if(age &gt; 120) &#123; System.out.println(\"Error: error age input.\"); &#125; else &#123; this.age = age; &#125;&#125;public String getSex() &#123; if(\"0\".equals(sex)) &#123; sex = \"男\"; &#125; else if(\"1\".equals(sex)) &#123; sex = \"女\"; &#125; return sex;&#125; 2、继承：复用代码的一种方式。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。 继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。 继承定义了类如何相互关联，共享特性。 在使用继承时需要注意： 子类拥有父类非private的属性和方法； 子类可以拥有自己属性和方法，即子类可以对父类进行扩展； 子类可以用自己的方式实现父类的方法（重写）。 构造器：只能够被调用，而不能被继承。调用父类的构造方法使用super()即可。 总结：对于继承来说，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。 protected关键字：将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。 向上转型： 将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型。由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是属性和方法的丢失。这就是为什么编译器在“未曾明确表示转型”或“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。 谨慎继承，继承存在如下缺陷： 父类变，子类就必须变； 继承破坏了封装，对于父类而言，它的实现细节对于子类来说都是透明的； 继承是一种强耦合关系。 3、多态：指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。 Java中多态的实现方式：接口实现、继承父类进行方法重写、同一个类中进行方法重载。 Java实现多态有三个必要条件：继承、重写、向上转型； 继承：在多态中必须存在有继承关系的子类和父类； 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法； 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。 多态机制遵循的原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class A &#123; public String show(D obj) &#123; return (\"A and D\"); &#125; public String show(A obj) &#123; return (\"A and A\"); &#125;&#125;public class B extends A &#123; public String show(B obj)&#123; return (\"B and B\"); &#125; public String show(A obj)&#123; return (\"B and A\"); &#125;&#125;public class C extends B &#123;&#125;public class D extends B &#123;&#125;public class Test &#123; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(\"1--\" + a1.show(b)); System.out.println(\"2--\" + a1.show(c)); System.out.println(\"3--\" + a1.show(d)); System.out.println(\"4--\" + a2.show(b)); System.out.println(\"5--\" + a2.show(c)); System.out.println(\"6--\" + a2.show(d)); System.out.println(\"7--\" + b.show(b)); System.out.println(\"8--\" + b.show(c)); System.out.println(\"9--\" + b.show(d)); &#125;&#125;结果：1--A and A2--A and A3--A and D4--B and A5--B and A6--A and D7--B and B8--B and B9--A and D 总结：面向对象编程有三大特性：封装、继承、多态。 封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而言它的内部细节是隐藏的，暴露给外界的只是它的访问方法。 继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。 多态指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定。 重写与重载1、定义： 重载（Overloading）：函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。 重写（Overriding）：在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。 2、重载 VS 重写： 重载是一个编译期概念、重写是一个运行期间概念； 重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法； 重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法； 因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）。 3、重写有以下三个限制： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型； 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。 1234567891011121314151617181920public class Dog &#123; public void bark() &#123; System.out.println(\"woof \"); &#125;&#125;public class Hound extends Dog &#123; public void sniff() &#123; System.out.println(\"sniff \"); &#125; public void bark() &#123; System.out.println(\"bowl \"); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Dog dog = new Hound(); dog.bark(); &#125;&#125;结果：bowl 4、重载： 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 应该注意的是，返回值不同，其它都相同不算是重载。 123456789//定义了两个bark方法，一个是没有参数的bark方法，另外一个是包含一个int类型参数的bark方法。在编译期，编译期可以根据方法签名（方法名和参数情况）情况确定哪个方法被调用。public class Dog &#123; public void bark() &#123; System.out.println(\"woof \"); &#125; public void bark(int num) &#123; System.out.println(\"woof \" + num); &#125;&#125; 接口与抽象类抽象类与接口是java语言中对抽象概念进行定义的两种机制，正是由于他们的存在才赋予java强大的面向对象的能力。他们两者之间对抽象概念的支持有很大的相似，甚至可以互换，但是也有区别。 1、抽象类： 抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可； 抽象方法必须由子类来进行重写； 只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法； 抽象类中可以包含具体的方法，当然也可以不包含抽象方法； 子类中的抽象方法不能与父类的抽象方法同名； abstract不能与final并列修饰同一个类； abstract 不能与private、static、final或native并列修饰同一个方法。 创建抽象类和抽象方法非常有用，因为他们可以使类的抽象性明确起来,并告诉用户和编译器打算怎样使用他们。抽象类还是有用的重构器，因为它们使我们可以很容易地将公共方法沿着继承层次结构向上移动。 2、接口：接口本身就不是类，不能实例化。接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口，同时也表示着“interface只是它的外貌，但是现在需要声明它是如何工作的”。 接口是抽象类的延伸，java为了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷，但是推荐继承和接口共同使用，因为这样既可以保证数据安全性又可以实现多重继承。 在使用接口过程中需要注意如下几个问题： Interface所有的方法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！ 接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name； 接口中不存在实现的方法； 实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现； 不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable){}； 在实现多接口的时候一定要避免方法名的重复。 3、抽象类与接口的区别： 语法层次： 抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。 对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。 设计层次： 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。 设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们再抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。 总结： 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口； 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的； 抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系； 抽象类和接口是java语言中两种不同的抽象概念，他们的存在对多态提供了非常好的支持，虽然他们之间存在很大的相似性。但是对于他们的选择往往反应了对问题域的理解。只有对问题域的本质有良好的理解，才能做出正确、合理的设计。 博客转自： https://chenssy.blog.csdn.net/column/info/chenssy-javaimpr/2 https://www.hollischuang.com/archives/1308 -","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Redis基础","date":"2019-06-17T02:02:34.000Z","path":"2019/06/17/Redis/","text":"Redis：数据类型、使用场景、持久化、复制、分片。 1、概述： Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。 键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。 Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。 2、数据类型： 1）String： 12345678&gt; set hello worldOK&gt; get hello\"world\"&gt; del hello(integer) 1&gt; get hello(nil) 2）List： 123456789101112131415161718192021&gt; rpush list-key item(integer) 1&gt; rpush list-key item2(integer) 2&gt; rpush list-key item(integer) 3&gt; lrange list-key 0 -11) \"item\"2) \"item2\"3) \"item\"&gt; lindex list-key 1\"item2\"&gt; lpop list-key\"item\"&gt; lrange list-key 0 -11) \"item2\"2) \"item\" 3）Set： 123456789101112131415161718192021222324252627&gt; sadd set-key item(integer) 1&gt; sadd set-key item2(integer) 1&gt; sadd set-key item3(integer) 1&gt; sadd set-key item(integer) 0&gt; smembers set-key1) \"item\"2) \"item2\"3) \"item3\"&gt; sismember set-key item4(integer) 0&gt; sismember set-key item(integer) 1&gt; srem set-key item2(integer) 1&gt; srem set-key item2(integer) 0&gt; smembers set-key1) \"item\"2) \"item3\" 4）Hash： 123456789101112131415161718192021222324&gt; hset hash-key sub-key1 value1(integer) 1&gt; hset hash-key sub-key2 value2(integer) 1&gt; hset hash-key sub-key1 value1(integer) 0&gt; hgetall hash-key1) \"sub-key1\"2) \"value1\"3) \"sub-key2\"4) \"value2\"&gt; hdel hash-key sub-key2(integer) 1&gt; hdel hash-key sub-key2(integer) 0&gt; hget hash-key sub-key1\"value1\"&gt; hgetall hash-key1) \"sub-key1\"2) \"value1\" 5）Zset： 12345678910111213141516171819202122232425&gt; zadd zset-key 728 member1(integer) 1&gt; zadd zset-key 982 member0(integer) 1&gt; zadd zset-key 982 member0(integer) 0&gt; zrange zset-key 0 -1 withscores1) \"member1\"2) \"728\"3) \"member0\"4) \"982\"&gt; zrangebyscore zset-key 0 800 withscores1) \"member1\"2) \"728\"&gt; zrem zset-key member1(integer) 1&gt; zrem zset-key member1(integer) 0&gt; zrange zset-key 0 -1 withscores1) \"member0\"2) \"982\" 3、数据结构： 1）字典： dictht 是一个散列表结构，使用拉链法解决哈希冲突。 Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。 rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。 渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。 在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。 采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。 2）跳跃表： 是有序集合的底层实现之一。 跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。 在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。 与红黑树等平衡树相比，跳跃表具有以下优点： 插入速度非常快速，因为不需要进行旋转等操作来维护平衡性； 更容易实现； 支持无锁操作。 4、使用场景： 1）计数器： 可以对 String 进行自增自减运算，从而实现计数器功能。 Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。 2）缓存：将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。 3）查找表： 例如 DNS 记录就很适合使用 Redis 进行存储。 查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。 4）消息队列： List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。 不过最好使用 Kafka、RabbitMQ 等消息中间件。 5）会话缓存： 可以使用 Redis 来统一存储多台应用服务器的会话信息。 当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。 6）分布式锁实现： 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。 可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。 7）其他： Set 可以实现交集、并集等操作，从而实现共同好友等功能。 ZSet 可以实现有序性操作，从而实现排行榜等功能。 5、Redis 与 Memcached： 两者都是非关系型内存键值数据库，主要有以下不同： 1）数据类型：Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。 2）数据持久化：Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。 3）分布式： Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。 Redis Cluster 实现了分布式的支持。 4）内存管理机制： 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。 Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。 6、键的过期时间： Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。 对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。 7、数据淘汰策略： 可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。 Redis 具体有 6 种淘汰策略： 作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。 使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。 Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。 8、持久化： Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。 1）RDB 持久化： 将某个时间点的所有数据都存放到硬盘上。 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。 如果系统发生故障，将会丢失最后一次创建快照之后的数据。 如果数据量很大，保存快照的时间会很长。 2）AOF 持久化： 将写命令添加到 AOF 文件（Append Only File）的末尾。 使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项： always 选项会严重减低服务器的性能； everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响； no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。 随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。 9、事务： 一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。 事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。 Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。 10、事件：Redis 服务器是一个事件驱动程序。 1）文件事件： 服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。 Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。 2）时间事件： 服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。 时间事件又分为： 定时事件：是让一段程序在指定的时间之内执行一次； 周期性事件：是让一段程序每隔指定时间就执行一次。 Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。 3）事件的调度与执行： 服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。 事件调度与执行由 aeProcessEvents 函数负责，伪代码如下： 12345678910111213141516def aeProcessEvents(): # 获取到达时间离当前时间最接近的时间事件 time_event = aeSearchNearestTimer() # 计算最接近的时间事件距离到达还有多少毫秒 remaind_ms = time_event.when - unix_ts_now() # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0 if remaind_ms &lt; 0: remaind_ms = 0 # 根据 remaind_ms 的值，创建 timeval timeval = create_timeval_with_ms(remaind_ms) # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定 aeApiPoll(timeval) # 处理所有已产生的文件事件 procesFileEvents() # 处理所有已到达的时间事件 processTimeEvents() 将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下： 12345678def main(): # 初始化服务器 init_server() # 一直处理事件，直到服务器关闭为止 while server_is_not_shutdown(): aeProcessEvents() # 服务器关闭，执行清理操作 clean_server() 从事件处理的角度来看，服务器运行流程如下： 11、复制： 通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。 一个从服务器只能有一个主服务器，并且不支持主主复制。 1）连接过程： 主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令； 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令； 主服务器每执行一次写命令，就向从服务器发送相同的写命令。 2）主从链： 随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。 12、Sentinel：Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。 13、分片： 分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。 假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… ，有不同的方式来选择一个指定的键存储在哪个实例中。 最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。 还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。 根据执行分片的位置，可以分为三种分片方式： 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。 服务器分片：Redis Cluster。 14、一个简单的论坛系统分析： 该论坛系统功能如下： 可以发布文章； 可以对文章进行点赞； 在首页可以按文章的发布时间或者文章的点赞数进行排序显示。 1）文章信息： 文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。 Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。 2）点赞功能： 当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。 为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。 3）对文章进行排序： 为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的） 博客转自： https://cyc2018.github.io/CS-Notes/#/notes/Redis?id=%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6","comments":true,"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"MySQL（二）","date":"2019-06-15T12:09:31.000Z","path":"2019/06/15/SQL-Common-Two/","text":"数据库：事务、缓存、连接、数据库优化。 1、什么是数据库事务？ 数据库事务是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含有以下两个目的： 为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。 当事务被提交给了DBMS（数据库管理系统），则DBMS（数据库管理系统）需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。 数据库事务拥有以下四个特性，被称之为ACID特性： 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。 2、数据库连接泄露的含义？ 数据库连接泄露指的是如果在某次使用或者某段程序中没有正确地关闭Connection、Statement和ResultSet资源，那么每次执行都会留下一些没有关闭的连接，这些连接失去了引用而不能得到重新使用，因此就造成了数据库连接的泄漏。数据库连接的资源是宝贵而且是有限的，如果在某段使用频率很高的代码中出现这种泄漏，那么数据库连接资源将被耗尽，影响系统的正常运转。 3、写一下mysql删除语句？ 1）drop语句。可以用来删除数据库和表。 1234--用drop语句来删除数据库drop database db;--用drop语句来删除表drop table tb; 2）delete语句。用来删除表中的字段。 1delete from tb where id=1; 3）用truncate来删除表中的所有字段。 1truncate table tb; 4、说一下数据库mysql中CHAR和VCHAR的区别？ 1）char(n)类型： char类型是定长的类型，即当定义的是char(10)，输入的是”abc”这三个字符时，它们占的空间一样是10个字节，包括7个空字节。当输入的字符长度超过指定的数时，char会截取超出的字符。而且，当存储char值时，MySQL是自动删除输入字符串末尾的空格。 char是适合存储很短的、一般固定长度的字符串。例如，char非常适合存储密码的MD5值，因为这是一个定长的值。对于非常短的列，char比varchar在存储空间上也更有效率。取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要。 2）varchar(n)类型： varchar(n)类型用于存储可变长的，长度为n个字节的可变长度且非Unicode的字符数据。n必须是介于1和8000之间的数值，存储大小为输入数据的字节的实际长度+1/2. 比如varchar(10), 然后输入abc三个字符，那么实际存储大小为3个字节。除此之外，varchar还需要使用1或2个额外字节记录字符串的长度，如果列的最大长度小于等于255字节（是定义的最长长度，不是实际长度），则使用1个字节表示长度，否则使用2个字节来表示。取数据的时候，不需要去掉多余的空格。 5、请说一下SQL左连接以及使用场景？ left join(左连接) 返回包括 LEFT OUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。使用场景：可以保持左表完整加入另一表中的数据。 6、请说说redis？ redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 7、请写一些基本的SQL语句？ 12345678910111213141516171819202122--选择select * from table1 where 范围--插入insert into table1(field1,field2) values(value1,value2)--删除delete from table1 where 范围--更新update table1 set field1=value1 where 范围--查找select * from table1 where field1 like '%value1%' ---like的语法很精妙，查资料!--排序select * from table1 order by field1,field2 [desc]--总数select count as totalcount from table1--求和select sum(field1) as sumvalue from table1--平均select avg(field1) as avgvalue from table1--最大select max(field1) as maxvalue from table1--最小select min(field1) as minvalue from table1 8、某个表格中有10条一模一样的数据，现在要删掉其中的9条，请写一下sql语句？ 1delete * from table_name limit 9 9、 请说一说数据库中的聚类查询？ 聚集索引中键值的逻辑顺序决定了表中相应行的物理顺序。聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。聚集索引对于那些经常要搜索范围值的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。例如，如果应用程序执行的一个查询经常检索某一日期范围内的记录，则使用聚集索引可以迅速找到包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此类查询的性能。同样，如果对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚集（物理排序），避免每次查询该列时都进行排序，从而节省成本。当索引值唯一时，使用聚集索引查找特定的行也很有效率。例如，使用唯一雇员ID 列 emp_id 查找特定雇员的最快速的方法，是在 emp_id 列上创建聚集索引或 PRIMARY KEY 约束。 如果不创建索引，系统会自动创建一个隐含列作为表的聚集索引。 10、如果mysql中用户密码丢了怎么办，建一个数据库表，授权命令是什么？ 对于普通用户的密码丢失，直接用root超级管理员登录修改密码即可。若是root密码丢失，可通过mysqlld_saft方式找回。 1）停止mysql：service mysqld stop 2）安全模式启动：mysql_safe-skip-grant-tables&amp; 3）无密码回车键登录：mysql –uroot –p; 4）重置密码：use mysql update user set password=password(“)where user=’root’ and host=’localhost’;flush privileges 5）正常启动：service mysql restart 6）再使用mysqladmin：mysqladmin password ‘123456’ Mysql创建数据库：Create database demodb default character set utf8 collate utf8_general_ci； 授权：Grant all privileges on demodb. * [用户名称]@’%’ 立即启动修改：Flush privileges 11、请说一下数据库事务、主键与外键的区别？ 数据库的事务：事务即用户定义的一个数据库操作序列，这些操作要么全做要全不做，是一个不可分割的工作单位，它具有四个特性，ACID，原子性，一致性，隔离性，持续性。 主键和外键的区别： 主键是能确定一条记录的唯一标识，比如，一条记录包括身份正号，姓名，年龄。身份证号是唯一能确定你这个人的，其他都可能有重复，所以，身份证号是主键。 外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。 12、对缓存技术了解吗？ Redis可以实现缓存机制， Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、 list(链表)、set(集合)和zset(有序集合)。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步,当前 Redis的应用已经非常广泛，国内像新浪、淘宝，国外像 Flickr、Github等均在使用Redis的缓存服务。 Redis作为一个高性能的key-value数据库具有以下特征： 多样的数据模型； 持久化； 主从同步。 Redis支持丰富的数据类型，最为常用的数据类型主要由五种：String、Hash、List、Set和Sorted Set。Redis通常将数据存储于内存中，或被配置为使用虚拟内存。Redis有一个很重要的特点就是它可以实现持久化数据，通过两种方式可以实现数据持久化：使用RDB快照的方式，将内存中的数据不断写入磁盘；或使用类似MySQL的AOF日志方式，记录每次更新的日志。前者性能较高，但是可能会引起一定程度的数据丢失；后者相反。 Redis支持将数据同步到多台从数据库上，这种特性对提高读取性能非常有益。 13、请问count和sum的区别，以及count(*)和count(列名)的区别？ Count和sum区别：求和用累加sum()，求行的个数用累计count。 Count（*）包括了所有的列，在统计结果的时候不会忽略列值为null。 Count（列名）只包括列名那一项，会忽略列值为空的计数。 14、 join作用，想删除一行怎么做？ join作用是连接两个表，假设有2个表——Student表和SC表（选课表）： 内连接（自然连接）：当使用内连接时，如果Student中某些学生没有选课，则在SC中没有相应元组。最终查询结果舍弃了这些学生的信息； 外连接：如果想以Student表为主体列出每个学生的基本情况及其选课情况。即使某个学生没有选课，依然在查询结果中显示（SC表的属性上填空值）。就需要使用外连接。 15、请问如何对数据库作优化？ 1）调整数据结构的设计，对于经常访问的数据库表建立索引； 2）调整SQL语句， ORACLE公司推荐使用ORACLE语句优化器（Oracle Optimizer）和行锁管理器（row-level manager）来调整优化SQL语句； 3）调整服务器内存分配。内存分配是在信息系统运行过程中优化配置的，数据库管理员可以根据数据库运行状况调整数据库系统全局区（SGA区）的数据缓冲区、日志缓冲区和共享池的大小；还可以调整程序全局区（PGA区）的大小； 4）调整硬盘Ｉ／Ｏ，DBA可以将组成同一个表空间的数据文件放在不同的硬盘上，做到硬盘之间Ｉ／Ｏ负载均衡。 16、请问什么是幻读？ 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，但是还没有来得及提交到数据库中，这时，另一个事务也访问这个数据，然后使用了这个数据。 17、请说一下MyBatis有什么优势，他如何做事务管理？ MyBatis优点： 易于上手和掌握； sql写在xml里，便于统一管理和优化； 解除sql与程序代码的耦合； 提供映射标签，支持对象与数据库的orm字段关系映射； 提供对象关系映射标签，支持对象关系组建维护； 提供xml标签，支持编写动态sql。 Mybatis管理事务是分为两种方式： 使用JDBC的事务管理机制，就是利用java.sql.Connection对象完成对事务的提交； 使用MANAGED的事务管理机制，这种机制mybatis自身不会去实现事务管理，而是让程序的容器（JBOSS,WebLogic）来实现对事务的管理。 18、请说一下事务的隔离级别，以及你一般使用的事务是哪种？ 事务的隔离性：同一时间只允许一个事务请求同一数据，不同事物之间彼此没有任何干扰。 事务隔离级别如下： 博文转自：https://www.nowcoder.com/tutorial/97/7d14246976434f489277d982aaa7aab2","comments":true,"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"MySQL（一）","date":"2019-06-13T13:28:44.000Z","path":"2019/06/13/SQL-Common-One/","text":"数据库：事务、索引、SQL基础操作、查询性能优化。 事务1、About：事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。 2、ACID： 原子性（Atomicity）：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。 一致性（Consistency）：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。 隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的。 持久性（Durability）：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。 并发一致性问题在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。 1、丢失修改：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。 2、读脏数据：T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。 3、不可重复读：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。 4、幻影读：T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。 产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。 隔离级别1、未提交读（READ UNCOMMITTED）：事务中的修改，即使没有提交，对其它事务也是可见的。 2、提交读（READ COMMITTED）：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。 3、可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同样数据的结果是一样的。 4、可串行化（SERIALIZABLE）：强制事务串行执行。需要加锁实现，而其它隔离级别通常不需要。 三大范式一般地，在进行数据库设计时，应遵循三大原则，也就是我们通常说的三大范式： 要求确保表中每列的原子性，也就是不可拆分； 要求确保表中每列与主键相关，而不能只与主键的某部分相关（主要针对联合主键），主键列与非主键列遵循完全函数依赖关系，也就是完全依赖； 确保主键列之间没有传递函数依赖关系，也就是消除传递依赖。 SQL基础操作1、数据库创建与使用： 12CREATE DATABASE test;USE test; 2、创建表： 123456CREATE TABLE mytable ( id INT NOT NULL AUTO_INCREMENT, --int 类型，不为空，自增 col1 INT NOT NULL DEFAULT 1, --int 类型，不可为空，默认值为 1，不为空 col2 VARCHAR(45) NULL, --变长字符串类型，最长为 45 个字符，可以为空 col3 DATE NULL, --日期类型，可为空 PRIMARY KEY (`id`)); --设置主键为 id 3、修改表： 12345678--添加列ALTER TABLE mytableADD col CHAR(20);--删除列ALTER TABLE mytableDROP COLUMN col;--删除表DROP TABLE mytable; 4、插入： 12345678910--普通插入INSERT INTO mytable(col1, col2)VALUES(val1, val2);--插入检索出来的数据INSERT INTO mytable1(col1, col2)SELECT col1, col2FROM mytable2;--将一个表的内容插入到一个新表CREATE TABLE newtable ASSELECT * FROM mytable; 5、更新： 123UPDATE mytableSET col = valWHERE id = 1; 6、删除： 1234DELETE FROM mytableWHERE id = 1;--TRUNCATE TABLE 可以清空表，也就是删除所有行TRUNCATE TABLE mytable; 7、查询： 123456789--DISTINCT，相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同SELECT DISTINCT col1, col2FROM mytable;--LIMIT，限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。--返回前 5 行SELECT * FROM mytable LIMIT 5;SELECT * FROM mytable LIMIT 0, 5;--返回第 3 ~ 5 行SELECT * FROM mytable LIMIT 2, 3; 8、排序： ASC ：升序（默认） DESC ：降序 1234--可以按多个列进行排序，并且为每个列指定不同的排序方式SELECT *FROM mytableORDER BY col1 DESC, col2 ASC; 9、过滤：不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。 123SELECT *FROM mytableWHERE col IS NULL; 下表显示了 WHERE 子句可用的操作符： 10、通配符：通配符也是用在过滤语句中，但它只能用于文本字段。 % 匹配 &gt;=0 个任意字符； _ 匹配 ==1 个任意字符； 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。 1234--不要滥用通配符，通配符位于开头处匹配会非常慢SELECT *FROM mytableWHERE col LIKE '[^AB]%'; -- 不以 A 和 B 开头的任意文本 11、计算字段：在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。 计算字段通常需要使用 AS 来取别名，否则输出的时候字段名为计算表达式。 12SELECT col1 * col2 AS aliasFROM mytable; CONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。 12SELECT CONCAT(TRIM(col1), '(', TRIM(col2), ')') AS concat_colFROM mytable; 12、函数： 汇总： AVG() 会忽略 NULL 行。 文本处理： SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。 13、分组： 把具有相同的数据值的行放在同一组中。 可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。 指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。 1234567891011121314SELECT col, COUNT(*) AS numFROM mytableGROUP BY col;--GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序SELECT col, COUNT(*) AS numFROM mytableGROUP BY colORDER BY num;--WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤SELECT col, COUNT(*) AS numFROM mytableWHERE col &gt; 2GROUP BY colHAVING num &gt;= 2; 分组规定： GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前； 除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出； NULL 的行会单独分为一组； 大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。 14、连接： 连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。 连接可以替换子查询，并且比子查询的效率一般会更快。 可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。 1）内连接：内连接又称等值连接，使用 INNER JOIN 关键字。 123SELECT A.value, B.valueFROM tablea AS A INNER JOIN tableb AS BON A.key = B.key; 2）自连接：自连接可以看成内连接的一种，只是连接的表是自身而已。 12345--一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名SELECT e1.nameFROM employee AS e1 INNER JOIN employee AS e2ON e1.department = e2.department AND e2.name = \"Jim\"; 3）自然连接：自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。 内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。 12SELECT A.value, B.valueFROM tablea AS A NATURAL JOIN tableb AS B; 4）外连接：外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。 1234--检索所有顾客的订单信息，包括还没有订单信息的顾客SELECT Customers.cust_id, Orders.order_numFROM Customers LEFT OUTER JOIN OrdersON Customers.cust_id = Orders.cust_id; 15、组合查询：使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。 每个查询必须包含相同的列、表达式和聚集函数。 默认会去除相同行，如果需要保留相同行，使用 UNION ALL。 只能包含一个 ORDER BY 子句，并且必须位于语句的最后。 1234567SELECT colFROM mytableWHERE col = 1UNIONSELECT colFROM mytableWHERE col =2; 16、视图：视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。 对视图的操作和对普通表的操作一样。 视图具有如下好处： 简化复杂的 SQL 操作，比如复杂的连接； 只使用实际表的一部分数据； 通过只给用户访问视图的权限，保证数据的安全性； 更改数据格式和表示。 1234CREATE VIEW myview ASSELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_colFROM mytableWHERE col5 = val; 17、存储过程：存储过程可以看成是对一系列 SQL 操作的批处理。 使用存储过程的好处： 代码封装，保证了一定的安全性； 代码复用； 由于是预先编译，因此具有很高的性能。 18、游标：在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。 使用游标的四个步骤： 声明游标，这个过程没有实际检索出数据； 打开游标； 取出数据； 关闭游标。 19、触发器：触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。 触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。 20、事务管理： 基本术语： 事务（transaction）指一组 SQL 语句； 回退（rollback）指撤销指定 SQL 语句的过程； 提交（commit）指将未存储的 SQL 语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。 不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。 21、权限管理： 123456789101112131415161718--MySQL 的账户信息保存在 mysql 这个数据库中USE mysql;SELECT user FROM user;--创建账户，新创建的账户没有任何权限CREATE USER myuser IDENTIFIED BY 'mypassword';--修改账户名RENAME USER myuser TO newuser;--删除账户DROP USER myuser;--查看权限SHOW GRANTS FOR myuser;--授予权限--账户用 username@host 的形式定义，username@% 使用的是默认主机名。GRANT SELECT, INSERT ON mydatabase.* TO myuser;--删除权限REVOKE SELECT, INSERT ON mydatabase.* FROM myuser;--更改密码SET PASSWROD FOR myuser = Password('new_password'); 索引1、About： MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。 之所以要建立索引，其实就是为了构建一种数据结构，可以在上面应用一种高效的查询算法，最终提高数据的查询速度。 索引的本质：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。 2、B+ Tree 原理： 1）数据结构： B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。 B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。 在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。 2）操作： 进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。 插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。 3） 与红黑树的比较： 红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因： 更少的查找次数： 平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。 红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。 利用磁盘预读特性： 为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。 操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。 3、MySQL 索引： 索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。 1）B+Tree 索引： 是大多数 MySQL 存储引擎的默认索引类型。 因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。 因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。 可以指定多个列作为索引列，多个索引列共同组成键。 适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。 InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。 辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。 2）哈希索引： 哈希索引能以 O(1) 时间进行查找，但是失去了有序性： 无法用于排序与分组； 只支持精确查找，无法用于部分查找和范围查找。 InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。 3）全文索引： MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。 查找条件使用 MATCH AGAINST，而不是普通的 WHERE。 全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。 InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。 4）空间数据索引： MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。 必须使用 GIS 相关的函数来维护数据。 4、索引优化： 1）独立的列：在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。 2）多列索引：在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。 3）索引列的顺序：让选择性最强的索引列放在前面。 索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。 4）前缀索引：对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。 前缀长度的选取需要根据索引选择性来确定。 5）覆盖索引：索引包含所有需要查询的字段的值。 具有以下优点： 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。 5、索引的优点： 大大减少了服务器需要扫描的数据行数。 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。 6、索引的使用条件： 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效； 对于中到大型的表，索引就非常有效； 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。 查询性能优化1、使用 Explain 进行分析： Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。 比较重要的字段有： select_type : 查询类型，有简单查询、联合查询、子查询等； key : 使用的索引； rows : 扫描的行数。 2、优化数据访问： 1）减少请求的数据量： 只返回必要的列：最好不要使用 SELECT * 语句； 只返回必要的行：使用 LIMIT 语句来限制返回的数据； 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。 2）减少服务器端扫描的行数：最有效的方式是使用索引来覆盖查询。 3、重构查询方式： 1）切分大查询：一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。 2）分解大连接查询： 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处： 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。 减少锁竞争； 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。 查询本身效率也可能会有所提升。 切分1、水平切分：水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。 当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力。 2、垂直切分：垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。 在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。 3、Sharding 策略： 哈希取模：hash(key) % N； 范围：可以是 ID 范围也可以是时间范围； 映射表：使用单独的一个数据库来存储映射关系。 4、Sharding 存在的问题： 事务问题：使用分布式事务来解决，比如 XA 接口。 连接：可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。 ID 唯一性： 使用全局唯一 ID（GUID） 为每个分片指定一个 ID 范围 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法) 复制1、主从复制： 主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。 binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中； I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）； SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。 2、读写分离： 主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。 读写分离能提高性能的原因在于： 主从服务器负责各自的读和写，极大程度缓解了锁的争用； 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销； 增加冗余，提高可用性。 读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。 Redis1、About：Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。 键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。 Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。 2、数据类型： 博客转自： https://cyc2018.github.io/CS-Notes/#/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86","comments":true,"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"数据结构（一）","date":"2019-06-08T06:22:00.000Z","path":"2019/06/08/数据结构总结/","text":"数据结构一些总结。 数组、栈、队列、链表、二分搜索树、集合、映射； 优先队列、堆、线段树、TRie前缀树、并查集； 平衡二叉树与AVL树、红黑树、哈希表。 About分类： 线性结构：数组、栈、队列、链表、哈希表… 树结构：二叉树、二分搜索树、AVL、红黑树、Treap、Splay、堆、Trie、线段树、K-D树、并查集、哈夫曼树… 图结构：邻接矩阵、邻接表… 应用： 数据库：树结构（AVL、红黑树、Treap、伸展树、B树）、哈希表； 操作系统：多任务间切换（系统栈，优先队列：堆）； 文件压缩：哈夫曼树； 通讯录：Trie-前缀树； 大量的算法，以数据结构为基石：寻路算法（图论算法—&gt;DFS：使用栈，BFS：使用队列）。 数组1、把数据码成一排进行存放，索引可以有语意，也可以没有语意； 2、最大优点：快速查询，最好应用于“索引有语意”的情况，并非所有有语意的索引都适用于数组； 3、size：数组中第一个没有元素的位置； 4、向数组末尾添加元素相当于在size位置处添加元素（将size索引位置值变为添加的值，size++）； 5、向数组指定位置添加元素（先将size-1处的元素值依次往后移，再将元素插入指定位置，size++）； 6、删除指定位置元素（将要删除索引处后面元素相继向左移动，size–）； 7、泛型：让数据结构可以放置“任何”数据类型（不可以是基本数据类型-8种，只能是类对象）； 8、动态数组（扩容、缩容）：新数组开辟新空间（可以装更多元素），将原来数组元素赋值到新数组； 9、动态数组的时间复杂度： 添加操作：addLast（e）-&gt; O（1）、addFIrst（e）-&gt; O（n）、add（index, e）-&gt; O（n / 2） = O（n）、resize（）-&gt; O（n）； 删除操作：removeLast（e）-&gt; O（1）、removeFIrst（e）-&gt; O（n）、remove（index, e）-&gt; O（n / 2） = O（n）、resize（）-&gt; O（n）； 修改操作：set（index, e）-&gt; O（1）； 查找操作：get（index）-&gt; O（1）、contains（e）-&gt; O（n）、find（e）-&gt; O（n）； 10、均摊复杂度：耗时的操作不会每次都触发，耗时的操作可分摊到其他操作中； 11、防止复杂度震荡：Lazy，当size == capacity / 4时，才将capacity减半。 123456789101112131415161718192021222324252627282930313233343536//关键代码Array类public void add(int index, E e) &#123;//在第index位置处插入一个新元素e if(index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"AddLast failed. Require index &gt;= 0 and index &lt;= size\"); &#125; if(size == data.length) &#123; resize(2 * data.length); &#125; for(int i = size -1; i &gt;= index; i--) &#123; data[i + 1] = data[i]; &#125; data[index] = e; size++;&#125;public E remove(int index) &#123;//从数组中删除index位置的元素，返回删除的元素 if(index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"Remove failed. Index is illegal.\"); &#125; E ret = data[index]; for(int i = index + 1; i &lt; size; i++) &#123; data[i - 1] = data[i]; &#125; size--; data[size] = null;//loitering objects != memory leak if(size == data.length / 4 &amp;&amp; data.length / 2 != 0) &#123; resize(data.length / 2); &#125; return ret;&#125;private void resize(int newCapacity) &#123;//动态数组 E[] newData = (E[])new Object[newCapacity]; for(int i = 0; i &lt; size; i++) &#123; newData[i] = data[i]; &#125; data = newData;&#125; 栈和队列1、栈（Stack）： 是一种线性结构； 相比数组，栈对应的操作是数组的子集； 只能从一端添加元素，也只能从同一端取出元素（栈顶）； 是一种后进先出的数据结构（LIFO，Last In First Out）； 栈拥有不可思议的作用。 2、栈的应用： 无处不在的undo操作（撤销）-编辑器； 程序调用的系统栈-操作系统； 括号匹配-编译器。 3、栈的实现-Stack： void push 入栈 O(1) 均摊； E pop() 出栈 O(1) 均摊； E peek() 查看栈顶元素（top） O(1)； int getSize() 栈大小 O(1)； boolean isEmpty() 栈是否为空 O(1)。 12345678910//关键代码，基于动态数组实现public void push(E e) &#123; array.addLast(e);&#125;public E pop() &#123; return array.removeLast();&#125;public E peek() &#123; return array.getLast();&#125; 4、队列（Queue）： 是一种线性结构； 相比数组，队列对应的操作是数组的子集； 只能从一端（队尾）添加元素，从另一端（队首）取出元素； 队列是一种先进先出的数据结构（先到先得）-FIFO，First In First Out； 5、队列的实现-Queue： void enqueue(E) O(1) 均摊； E dequeue() O(n)； E getFront() O(1)； int getSize() O(1)； boolean isEmpty() O(1)。 12345678910//关键代码，基于动态数组实现public void enqueue(E e) &#123; array.addLast(e);&#125;public E dequeue() &#123; return array.removeFirst();&#125;public E getFront() &#123; return array.getFirst();&#125; 6、循环队列： front == tail 队列为空，（tail + 1） % c == front 队列为满； 入队：只需维护tail（tail++ % 数组长度）； 出队：只需维护front（–）。 7、循环队列的实现-LoopQueue： void enqueue(E) O(1) 均摊； E dequeue() O(1) 均摊； E getFront() O(1)； int getSize() O(1)； boolean isEmpty() O(1)。 12345678910111213141516171819202122232425262728293031323334353637383940//关键代码private E[] data;private int front, tail;private int size;public void enqueue(E e) &#123; if((tail + 1) % data.length == front) &#123; resize(getCapacity() * 2); &#125; data[tail] = e; tail = (tail + 1) % data.length; size++;&#125;private void resize(int newCapacity) &#123; E[] newData = (E[]) new Object[newCapacity + 1]; for(int i = 0; i &lt; size; i++) &#123; newData[i] = data[(i + front) % data.length]; &#125; data = newData; front = 0; tail = size;&#125;public E dequeue() &#123; if(isEmpty()) &#123; throw new IllegalArgumentException(\"cannot dequeue from an empty queue.\"); &#125; E res = data[front]; data[front] = null; front = (front + 1) % data.length; size--; if(size == getCapacity() / 4 &amp;&amp; getCapacity() / 2 != 0) &#123; resize(getCapacity() / 2); &#125; return res;&#125;public E getFront() &#123; if(isEmpty()) &#123; throw new IllegalArgumentException(\"Queue is empty.\"); &#125; return data[front];&#125; 8、链表实现队列： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//Node类private class Node &#123; public E e; public Node next; public Node(E e, Node next) &#123; this.e = e; this.next = next; &#125; public Node(E e) &#123; this(e, null); &#125; public Node() &#123; this(null, null); &#125;&#125;//关键代码private Node head, tail;private int size;public void enqueue(E e) &#123;//链表尾插入 if(tail == null) &#123; tail = new Node(e); head = tail; &#125; else &#123; tail.next = new Node(e); tail = tail.next; &#125; size++;&#125;public E dequeue() &#123;//链表头删除 if(isEmpty()) &#123; throw new IllegalArgumentException(\"Cannot dequeue from an empty queue.\"); &#125; Node retNode = head; head = head.next; retNode.next = null; if(head == null) &#123; tail = null; &#125; size--; return retNode.e;&#125;public E getFront() &#123; if(isEmpty()) &#123; throw new IllegalArgumentException(\"Queue is empty.\"); &#125; return head.e;&#125; 链表1、线性数据结构：底层依托静态数组，靠resize解决固定容量问题； 2、链表：真正的动态数据结构； 最简单的动态数据结构； 更深入的理解引用（或者指针）； 更深入的理解递归； 辅助组成其他数据结构。 3、链表Linked List： 数据存储在“节点”（Node）中； 1234class Node &#123; E e； Node next;&#125; 优点：真正的动态，不需要处理固定容量的问题； 缺点：丧失了随机访问的能力。 4、数组和链表的对比： 数组最好用于索引有语意的情况； 最大的优点：支持快速查询； 链表不适合用于索引有语意的情况； 最大的优点：动态。 5、在链表头添加元素： 6、在链表中间添加元素（关键是找到要添加的节点的前一个节点；）： 7、链表元素的删除： 8、复杂度分析： 添加操作：addLast(e) O(n)、addFirst(e) O(1)、add(index, e) O(n / 2) = O(n)； 删除操作：removeLast(e) O(n)、removeFirst(e) O(1)、remove(index, e) O(n / 2) = O(n)； 修改操作：set(index, e) O(n)； 查找操作：get(index) O(n)、contains(e) O(n)。 9、对链表头进行操作（增、删）：O（1）、只查链表头的元素：O（1）； 10、链表实现栈、链表实现队列： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144public class LinkedList&lt;E&gt; &#123; private class Node &#123; public E e; public Node next; public Node(E e, Node next) &#123; this.e = e; this.next = next; &#125; public Node(E e) &#123; this(e, null); &#125; public Node() &#123; this(null, null); &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125; private Node dummyHead;//虚拟头节点 private int size; public LinkedList() &#123; dummyHead = new Node(null, null); size = 0; &#125; public int getSize() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; //在链表头添加新的元素e public void addFirst(E e) &#123; // Node node = new Node(e); // node.next = head; // head = node; // // head = new Node(e, head); // size++; add(0, e); &#125; //在链表的index位置添加新的元素e public void add(int index, E e) &#123; if(index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"Add failed. Illegal index.\"); &#125; Node prev = dummyHead; for(int i = 0; i &lt; index; i++) &#123; prev = prev.next; &#125; // Node node = new Node(e); // node.next = prev.next; // prev.next = node; prev.next = new Node(e, prev.next); size++; &#125; //在链表末尾添加新的元素e public void addLast(E e) &#123; add(size, e); &#125; public E get(int index) &#123; if(index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"Get failed. Illegal index.\"); &#125; Node cur = dummyHead.next; for(int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; return cur.e; &#125; public E getFirst() &#123; return get(0); &#125; public E getLast() &#123; return get(size - 1); &#125; public void set(int index, E e) &#123; if(index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"Set failed. Illegal index.\"); &#125; Node cur = dummyHead.next; for(int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; cur.e = e; &#125; public boolean contains(E e) &#123; Node cur = dummyHead.next; while(cur != null) &#123; if(cur.e.equals(e)) &#123; return true; &#125; cur = cur.next; &#125; return false; &#125; public E remove(int index) &#123; if(index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"Remove failed. Illegal index.\"); &#125; Node prev = dummyHead; for(int i = 0; i &lt; index; i++) &#123; prev = prev.next; &#125; Node ret = prev.next; prev.next = ret.next; ret.next = null; size--; return ret.e; &#125; public E removeFirst() &#123; return remove(0); &#125; public E removeLast() &#123; return remove(size - 1); &#125; //从链表删除元素e public void removeElement(E e) &#123; Node prev = dummyHead; while (prev.next != null) &#123; if(prev.next.e.equals(e)) &#123; break; &#125; prev = prev.next; &#125; if(prev.next != null) &#123; Node delNode = prev.next; prev.next = delNode.next; delNode.next = null; &#125; &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); Node cur = dummyHead.next; while (cur != null) &#123; res.append(cur + \"-&gt;\"); cur = cur.next; &#125; res.append(\"Null\"); return res.toString(); &#125;&#125; 链表和递归1、递归：本质上，将原来的问题，转化为更小的同一问题； 2、求解最基本问题，把原问题转化为更小的问题； 3、递归函数： 递归函数的调用，本质就是函数调用； 只不过调用的函数是自己而已。 递归调用是有代价的：函数调用+系统栈空间。 4、双链表： 1234class Node &#123; E e; Node next, prev;&#125; 加入虚拟头节点：对于很多操作，在链表头不需特殊讨论。 5、循环链表： 6、数组链表： 二分搜索树1、树结构本身是一种天然的组织结构； 2、树结构：高效； 3、二叉树： 123456//和链表一样，动态数据结构class Node &#123; E e; Node left; //左孩子 Node right; //右孩子&#125; 二叉树具有唯一根节点； 二叉树每个节点最多有两个孩子； 二叉树每个节点最多有一个父亲节点； 二叉树具有天然递归结构： 每个节点的左子树也是二叉树； 每个节点的右子树也是二叉树，一个节点也是二叉树，空也是二叉树。 4、二分搜索树（Binary Search Tree）： 二分搜索树是二叉树； 二分搜索树的每个节点的值： 大于其左子树的所有节点的值； 小于其右子树的所有节点的值。 每一棵子树也是二分搜索树； 存储的元素必须有可比较性（存储数据的局限性）； 二分搜索树不包含重复元素： 如果想包含重复元素的话，改变定义：左子树小于等于节点，或者右子树大于等于节点。 注意：数组和链表，可以有重复元素。 二分搜索树添加元素的非递归写法，和链表很像； 在二分搜索树方面，递归比非递归实现简单。 5、遍历： 把所有节点都访问一遍； 访问的原因和业务相关； 在线性结构下，遍历是及其容易的； 在树结构下，也没那么难； 对遍历操作，两颗子树都要顾及。 6、后序遍历应用：为二分搜索树释放内存。 7、栈消除递归。 8、深度优先遍历：前序、中序、后序；广度优先遍历（搜索策略）：层序遍历（非递归实现-借助队列） 广度优先遍历：更快的找到问题的解，常用于算法设计中-最短路径。 9、二分搜索树删除节点（找后继和前驱都可以删除）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267import java.util.LinkedList;import java.util.Queue;import java.util.Stack;public class BST&lt;E extends Comparable&lt;E&gt;&gt; &#123; private class Node &#123; public E e; public Node left, right; public Node(E e) &#123; this.e = e; left = null; right = null; &#125; &#125; private Node root; private int size; public BST() &#123; this.root = null; this.size = 0; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void add(E e) &#123; // if(root == null) &#123; // root = new Node(e); // &#125; else &#123; // add(root, e); // &#125; root = add(root, e); &#125; private Node add(Node node, E e) &#123; // if(e.equals(node.e)) &#123; // return; // &#125; else if(e.compareTo(node.e) &lt; 0 &amp;&amp; node.left == null) &#123; // node.left = new Node(e); // size++; // return; // &#125; else if(e.compareTo(node.e) &gt; 0 &amp;&amp; node.right == null) &#123; // node.right = new Node(e); // size++; // return; // &#125; //向以node为根的二分搜索树中插入元素E，递归算法 //返回插入新节点后二分搜索树的根 if(node == null) &#123; size++; return new Node(e); &#125; if(e.compareTo(node.e) &lt; 0) &#123; node.left = add(node.left, e); &#125; if(e.compareTo(node.e) &gt; 0) &#123; node.right = add(node.right, e); &#125; return node; &#125; public boolean contains(E e) &#123;//二分搜索树中是否包含元素e return contains(root, e); &#125; private boolean contains(Node node, E e) &#123;//以node为根的二分搜索树中是否包含元素e，递归算法 if(node == null) &#123; return false; &#125; if(e.compareTo(node.e) &lt; 0) &#123; return contains(node.left, e); &#125; else if(e.compareTo(node.e) &gt; 0) &#123; return contains(node.right, e); &#125; else &#123; return true; &#125; &#125; //遍历 public void preOrder() &#123;//前序遍历 preOrder(root); &#125; private void preOrder(Node node) &#123; // if(node == null) &#123; // return; // &#125; if(node != null) &#123; System.out.println(node.e); preOrder(node.left); preOrder(node.right); &#125; &#125; public void preOrderNR() &#123;//前序非递归遍历，栈消除递归 Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; Node cur = stack.pop(); System.out.println(cur.e); if(cur.right != null) &#123; stack.push(cur.right); &#125; if(cur.left != null) &#123; stack.push(cur.left); &#125; &#125; &#125; public void inOrder() &#123;//中序排序 inOrder(root); &#125; private void inOrder(Node node) &#123; if(node == null) &#123; return; &#125; inOrder(node.left); System.out.println(node.e); inOrder(node.right); &#125; public void postOrder() &#123;//后序遍历 postOrder(root); &#125; private void postOrder(Node node) &#123; if(node == null) &#123; return; &#125; postOrder(node.left); postOrder(node.right); System.out.println(node.e); &#125; //层序遍历，队列实现 public void levelOrder() &#123; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); while (!q.isEmpty()) &#123; Node cur = q.remove(); System.out.println(cur.e); if(cur.left != null) &#123; q.add(cur.left); &#125; if(cur.right != null) &#123; q.add(cur.right); &#125; &#125; &#125; //寻找二分搜索树的最小元素 public E minimum() &#123; if(size == 0) &#123; throw new IllegalArgumentException(\"BST is empty\"); &#125; return minimum(root).e; &#125; //返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node) &#123; if(node.left == null) &#123; return node; &#125; return minimum(node.left); &#125; //寻找二分搜索树的最大元素 public E maximum() &#123; if(size == 0) &#123; throw new IllegalArgumentException(\"BST is empty\"); &#125; return maximum(root).e; &#125; //返回以node为根的二分搜索树的最大值所在的节点 private Node maximum(Node node) &#123; if(node.right == null) &#123; return node; &#125; return maximum(node.right); &#125; //从二分搜索树中删除最小值所在节点，返回最小值 public E removeMin() &#123; E ret = minimum(); root = removeMin(root); return ret; &#125; //删除以node为根的二分搜索树中的最小节点 //返回删除节点后新的二分搜索树的根 private Node removeMin(Node node) &#123; if(node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; node.left = removeMin(node.left); return node; &#125; //从二分搜索树中删除最大值所在节点，返回最大值 public E removeMax() &#123; E ret = maximum(); root = removeMax(root); return ret; &#125; //删除以node为根的二分搜索树中的最大节点 //返回删除节点后新的二分搜索树的根 private Node removeMax(Node node) &#123; if(node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; node.right = removeMax(node.right); return node; &#125; //从二分搜索树中删除元素为e的节点 public void remove(E e) &#123; root = remove(root, e); &#125; //删除以node为根的二分搜索树中值为e的节点，递归算法 //返回删除节点后新的二分搜索树的根 private Node remove(Node node, E e) &#123; if(node == null) &#123; return null; &#125; if(e.compareTo(node.e) &lt; 0) &#123; node.left = remove(node.left, e); return node; &#125; else if(e.compareTo(node.e) &gt; 0) &#123; node.right = remove(node.right, e); return node; &#125; else &#123;//e == node.e //待删节点左子树为空的情况 if(node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; //待删节点右子树为空的情况 if(node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; //待删节点左右子树为均不为空的情况 //找到比待删节点大的最小节点，即待删除节点右子树的最小节点 //用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; &#125; &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); generateBSTString(root, 0, res); return res.toString(); &#125; private void generateBSTString(Node node, int depth, StringBuilder res) &#123; if(node == null) &#123; res.append(generateBSTString(depth) + \" \\n\"); return; &#125; res.append(generateBSTString(depth) + node.e + \"\\n\"); generateBSTString(node.left, depth + 1, res); generateBSTString(node.right, depth + 1, res); &#125; private String generateBSTString(int depth) &#123; StringBuilder res = new StringBuilder(); for(int i = 0; i &lt; depth; i++) &#123; res.append(\"--\"); &#125; return res.toString(); &#125;&#125; 集合和映射1、集合：每个元素只能存在一次（去重）； Set: void add(E) 不能添加重复元素； void remove(E) ； boolean contains(E)； int getSize()； boolean isEmpty()。 应用：客户统计、词汇量统计。 2、BST和LinkedList都属于动态数据结构，可以用来实现set。 3、集合类的复杂度分析： LinkedListSet： 增add：O(n)； 查contains：O(n)； 删remove：O(n)。 BSTSet： 增add：O(h) h为二分搜索树的高度 h=logn； 查contains：O(h)； 删remove：O(h)。 4、java集合底层是：红黑树，本质是有序的集合； ​ 基于链表实现的集合：无序。 5、 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//链表实现集合public class LinkedListSet&lt;E&gt; implements Set&lt;E&gt; &#123; private LinkedList&lt;E&gt; list; public LinkedListSet() &#123; list = new LinkedList&lt;&gt;(); &#125; @Override public void add(E e) &#123; if(!list.contains(e)) &#123; list.addFirst(e); &#125; &#125; @Override public void remove(E e) &#123; list.removeElement(e); &#125; @Override public boolean contains(E e) &#123; return list.contains(e); &#125; @Override public int getSize() &#123; return list.getSize(); &#125; @Override public boolean isEmpty() &#123; return list.isEmpty(); &#125;&#125;//二分搜索树实现集合public class BSTSet&lt;E extends Comparable&lt;E&gt;&gt; implements Set&lt;E&gt; &#123; private BST&lt;E&gt; bst; public BSTSet() &#123; bst = new BST&lt;&gt;(); &#125; @Override public void add(E e) &#123; bst.add(e); &#125; @Override public void remove(E e) &#123; bst.remove(e); &#125; @Override public boolean contains(E e) &#123; return bst.contains(e); &#125; @Override public int getSize() &#123; return bst.size(); &#125; @Override public boolean isEmpty() &#123; return bst.isEmpty(); &#125;&#125; 6、映射Map： 存储（键，值）数据对的数据结构（Key，Value）； 根据键（Key），寻找值（Value）； 非常容易使用链表或者二分搜索树实现。 7、映射的时间复杂度分析： 8、有序映射和无序映射： 有序映射中的键具有顺序性（基于搜索树的实现）； 无序映射中的键没有顺序性（基于哈希表的实现）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240//链表实现映射import java.util.ArrayList;public class LinkedListMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123; private class Node &#123; public K key; public V value; public Node next; public Node(K key, V value, Node next) &#123; this.key = key; this.value = value; this.next = next; &#125; public Node(K key) &#123; this(key, null, null); &#125; public Node() &#123; this(null, null, null); &#125; @Override public String toString() &#123; return key.toString() + \":\" + value.toString(); &#125; &#125; private Node dummyHead; private int size; public LinkedListMap() &#123; dummyHead = new Node(); size = 0; &#125; @Override public void add(K key, V value) &#123; Node node = getNode(key); if(node == null) &#123; dummyHead.next = new Node(key, value, dummyHead.next); size++; &#125; else &#123; node.value = value; &#125; &#125; @Override public V remove(K key) &#123; Node prev = dummyHead; while (prev.next != null) &#123; if(prev.next.key.equals(key)) &#123; break; &#125; prev = prev.next; &#125; if(prev.next != null) &#123; Node delNode = prev.next; prev.next = delNode.next; delNode.next = null; size--; return delNode.value; &#125; return null; &#125; @Override public boolean contains(K key) &#123; return getNode(key) != null; &#125; @Override public V get(K key) &#123; Node node = getNode(key); return node == null ? null : node.value; &#125; @Override public void set(K key, V newValue) &#123;//更新键对应的值 Node node = getNode(key); if(node == null) &#123; throw new IllegalArgumentException(key + \"does't exist!\"); &#125; node.value = newValue; &#125; @Override public int getSize() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; private Node getNode(K key) &#123; Node cur = dummyHead.next; while (cur != null) &#123; if(cur.key.equals(key)) &#123; return cur; &#125; cur = cur.next; &#125; return null; &#125;&#125;//二分搜索树实现映射import java.util.ArrayList;public class BSTMap&lt;K extends Comparable&lt;K&gt;, V&gt; implements Map&lt;K, V&gt; &#123; private class Node &#123; public K key; public V value; public Node left, right; public Node(K key, V value) &#123; this.key = key; this.value = value; left = null; right = null; &#125; &#125; private Node root; private int size; public BSTMap() &#123; this.root = null; this.size = 0; &#125; @Override public void add(K key, V value) &#123; root = add(root, key, value); &#125; private Node add(Node node, K key, V value) &#123; //返回插入新节点后二分搜索树的根 //向以node为根的二分搜索树中插入元素E，递归算法 if(node == null) &#123; size++; return new Node(key, value); &#125; if(key.compareTo(node.key) &lt; 0) &#123; node.left = add(node.left, key, value); &#125; if(key.compareTo(node.key) &gt; 0) &#123; node.right = add(node.right, key, value); &#125; if(key.compareTo(node.key) == 0) &#123; node.value = value; &#125; return node; &#125; //返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node) &#123; if(node.left == null) &#123; return node; &#125; return minimum(node.left); &#125; //删除以node为根的二分搜索树中的最小节点 //返回删除节点后新的二分搜索树的根 private Node removeMin(Node node) &#123; if(node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; node.left = removeMin(node.left); return node; &#125; //从二分搜索树中删除元素为e的节点 @Override public V remove(K key) &#123; Node node = getNode(root, key); if(node != null) &#123; root = remove(root, key); return node.value; &#125; return null; &#125; //删除以node为根的二分搜索树中键为key的节点，递归算法 //返回删除节点后新的二分搜索树的根 private Node remove(Node node, K key) &#123; if(node == null) &#123; return null; &#125; if(key.compareTo(node.key) &lt; 0) &#123; node.left = remove(node.left, key); return node; &#125; else if(key.compareTo(node.key) &gt; 0) &#123; node.right = remove(node.right, key); return node; &#125; else &#123;//key == node.key //待删节点左子树为空的情况 if(node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; //待删节点右子树为空的情况 if(node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; //待删节点左右子树为均不为空的情况 //找到比待删节点大的最小节点，即待删除节点右子树的最小节点 //用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; &#125; &#125; @Override public boolean contains(K key) &#123; return getNode(root, key) != null; &#125; @Override public V get(K key) &#123; Node node = getNode(root, key); return node == null ? null : node.value; &#125; @Override public void set(K key, V newValue) &#123; Node node = getNode(root, key); if(node == null) &#123; throw new IllegalArgumentException(key + \" doesn't exist!\"); &#125; node.value = newValue; &#125; //返回以node为根节点的二分搜索树中，key所在的节点 private Node getNode(Node node, K key) &#123; if(node == null) &#123; return null; &#125; if(key.compareTo(node.key) == 0) &#123; return node; &#125; else if(key.compareTo(node.key) &lt; 0) &#123; return getNode(node.left, key); &#125; else &#123; return getNode(node.right, key); &#125; &#125; @Override public int getSize() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125;&#125; 优先队列和堆1、普通队列：先进先出，后进后出； ​ 优先队列：出队顺序和入队顺序无关，和优先级相关；（应用：任务调度）。 2、优先队列实现： 普通线性结构：入队-O（1）、出队-O（n）； 顺序线性结构：入队-O（n）、出队-O（1）； 堆：入队-O（logn）、出队-O（logn）。 3、堆的基本结构： 二叉堆是一颗完全二叉树（完全二叉树：把元素顺序排列成树的形状）； 堆中某个节点的值总是不大于其父节点的值–最大堆。 4、数组存储二叉堆： 索引从1开始： parent（i）= i / 2； left child (i) = 2 * i； right child(i) = 2 * i + 1。 索引从0开始： parent（i ）=（ i - 1） / 2； left child (i ) = 2 * i + 1； right child(i) = 2 * i + 2。 5、堆的时间复杂度分析： add O（logn）； extractMax （logn）。 6、replace操作： replace：取出最大元素后，放入一个新元素； 实现1：可以先extractMax，再add，两次O（logn）的操作； 实现2：可以直接将堆顶元素替换以后Sift Down，一次O（logn）的操作。 7、heapify操作：将任意数组整理成堆的形状； 将n个元素逐个插入到一个空堆中，算法复杂度是O（nlogn）； heapify的过程，算法复杂度为O（n）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class MaxHeap&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Array&lt;E&gt; data; public MaxHeap(int capacity) &#123; data = new Array&lt;&gt;(capacity); &#125; public MaxHeap() &#123; data = new Array&lt;&gt;(); &#125; public MaxHeap(E[] arr) &#123; data = new Array&lt;&gt;(arr); for(int i = parent(arr.length - 1); i &gt;= 0; i--) &#123; siftDown(i); &#125; &#125; //返回堆中元素个数 public int size() &#123; return data.getSize(); &#125; //返回一个布尔值，表示堆中是否为空 public boolean isEmpty() &#123; return data.isEmpty(); &#125; //返回完全二叉树的数组表示中，一个索引所表示的元素的父亲节点的索引 private int parent(int index) &#123; if(index == 0) &#123; throw new IllegalArgumentException(\"index-0 doesn't have parent\"); &#125; return (index - 1) / 2; &#125; //返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引 private int leftChild(int index) &#123; return index * 2 + 1; &#125; //返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引 private int rightChild(int index) &#123; return index * 2 + 2; &#125; //向堆中添加元素 public void add(E e) &#123; data.addLast(e); siftUp(data.getSize() - 1); &#125; private void siftUp(int k) &#123; while (k &gt; 0 &amp;&amp; data.get(parent(k)).compareTo(data.get(k)) &lt; 0) &#123; data.swap(k, parent(k)); k = parent(k); &#125; &#125; //查看堆中最大元素 public E findMax() &#123; if(data.getSize() == 0) &#123; throw new IllegalArgumentException(\"can not findMax when heap is empty\"); &#125; return data.get(0); &#125; //取出堆中最大元素 public E extractMax() &#123; E ret = findMax(); data.swap(0, data.getSize() - 1); data.removeLast(); siftDown(0); return ret; &#125; private void siftDown(int k) &#123; while (leftChild(k) &lt; data.getSize()) &#123; int j = leftChild(k); if(j + 1 &lt; data.getSize() &amp;&amp; data.get(j + 1).compareTo(data.get(j)) &gt; 0) &#123; j = rightChild(k); &#125; if(data.get(k).compareTo(data.get(j)) &gt;= 0) &#123; break; &#125; else &#123; data.swap(k, j); k = j; &#125; &#125; &#125; //取出堆中的最大元素，并且替换成元素e public E replace(E e) &#123; E ret = findMax(); data.set(0, e); siftDown(0); return ret; &#125;&#125; 8、优先队列的经典问题：在1000000个元素中选出前100名； 在N个元素中选出前M个元素； 排序？ NlogN； 使用优先队列？NlogM。 使用优先队列，维护当前看到的前M个元素；需要使用最小堆。 1234567891011121314151617181920212223242526public class PriorityQueue&lt;E extends Comparable&lt;E&gt;&gt; implements Queue&lt;E&gt; &#123; private MaxHeap&lt;E&gt; maxHeap; public PriorityQueue() &#123; maxHeap = new MaxHeap&lt;&gt;(); &#125; @Override public int getSize() &#123; return maxHeap.size(); &#125; @Override public boolean isEmpty() &#123; return maxHeap.isEmpty(); &#125; @Override public void enqueue(E e) &#123; maxHeap.add(e); &#125; @Override public E dequeue() &#123; return maxHeap.extractMax(); &#125; @Override public E getFront() &#123; return maxHeap.findMax(); &#125;&#125; 线段树（区间树）1、关心的是一个线段或区间； 2、最经典的线段树问题：区间染色、区间查询； 3、 4、线段树不一定是完全二叉树，线段树是平衡二叉树，堆也是平衡二叉树； ​ 平衡二叉树：树的最大深度与最小深度相差最多为1。 5、 6、区间操作的数据结构： 线段树； 树状数组（Binary Index Tree）。 区间相关的问题：RMQ（Range Minimum Query）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public interface Merger&lt;E&gt; &#123; E merge(E a, E b);&#125;public class SegmentTree&lt;E&gt; &#123; private E[] tree; private E[] data; private Merger&lt;E&gt; merger; public SegmentTree(E[] arr, Merger&lt;E&gt; merger) &#123; this.merger = merger; data = (E[]) new Object[arr.length]; for(int i = 0; i &lt; arr.length; i++) &#123; data[i] = arr[i]; &#125; tree = (E[]) new Object[4 * arr.length]; buildSegmentTree(0, 0, data.length - 1); &#125; //在treeIndex的位置创建表示区间[l...r]的线段树 private void buildSegmentTree(int treeIndex, int l, int r) &#123; if(l == r) &#123; tree[treeIndex] = data[l]; return; &#125; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); int mid = l + (r - l) / 2;//mid = l + r buildSegmentTree(leftTreeIndex, l, mid); buildSegmentTree(rightTreeIndex, mid + 1, r); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); &#125; //返回区间[queryL, queryR]的值 public E query(int queryL, int queryR) &#123; if(queryL &lt; 0 || queryL &gt;= data.length || queryR &lt; 0 || queryR &gt;= data.length || queryL &gt; queryR) &#123; throw new IllegalArgumentException(\"Index is illegal.\"); &#125; return query(0, 0, data.length - 1, queryL, queryR); &#125; //在以treeIndex为根的线段树中[l...r]的范围里，搜索区间[queryL...queryR]的值 private E query(int treeIndex, int l, int r, int queryL, int queryR) &#123; if(l == queryL &amp;&amp; r == queryR) &#123; return tree[treeIndex]; &#125; int mid = l + (r - l) / 2; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if(queryL &gt;= mid + 1) &#123; return query(rightTreeIndex, mid + 1, r, queryL, queryR); &#125; else if(queryR &lt;= mid) &#123; return query(leftTreeIndex, l, mid, queryL, queryR); &#125; E leftResult = query(leftTreeIndex, l, mid, queryL, mid); E rightResult = query(rightTreeIndex, mid + 1, r, mid + 1, queryR); return merger.merge(leftResult, rightResult); &#125; public int getSize() &#123; return data.length; &#125; public E get(int index) &#123; if(index &lt; 0 || index &gt;= data.length) &#123; throw new IllegalArgumentException(\"Index is illegal.\"); &#125; return data[index]; &#125; //返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引 private int leftChild(int index) &#123; return 2 * index + 1; &#125; //返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引 private int rightChild(int index) &#123; return 2 * index + 2; &#125; //将index位置的值，更新为e public void set(int index, E e) &#123; if(index &lt; 0 || index &gt;= data.length) &#123; throw new IllegalArgumentException(\"Index is illegal.\"); &#125; data[index] = e; set(0, 0, data.length - 1, index, e); &#125; //在以treeIndex为根的线段树中更新index的值为e private void set(int treeIndex, int l, int r, int index, E e) &#123; if(l == r) &#123; tree[treeIndex] = e; return; &#125; int mid = l + (r - l) / 2; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if(index &gt;= mid + 1) &#123; set(rightTreeIndex, mid + 1, r, index, e); &#125; else &#123; set(leftTreeIndex, l, mid, index, e); &#125; tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append('['); for (int i = 0; i &lt; tree.length; i++) &#123; if (tree[i] != null) &#123; res.append(tree[i]); &#125; else &#123; res.append(\"null\"); &#125; if (i != tree.length - 1) &#123; res.append('-'); &#125; else &#123; res.append(']'); &#125; &#125; return res.toString(); &#125;&#125; Trie字典树 前缀树1、Trie：专门为字符串设计； 2、字典：如果有n个条目，使用树结构，查询的时间复杂度是O（logn），如果有100万个条目（2^20），logn大约为20； ​ Trie：查询每个条目的时间复杂度，和字典中一共有多少条目无关，时间复杂度为O（w），w为查询单词的长度，大多数单词的长度小于10； 3、Trie：每个节点有若干指向下个节点的指针； 1234class Node &#123; boolean isWord;//是否访问到单词的结尾 Map&lt;char, Node&gt; next;&#125; 4、Trie的局限性：最大的问题（空间！） 解决办法： 压缩字典树（Compressed Trie）； 三分搜索树（Ternary Search Trie）。 5、字符串模式识别：后缀树； 6、更多字符串问题： 子串查询（KMP、Boyer-Moore、Rabin-Karp）； 文件压缩（哈夫曼）； 模式匹配； 编译原理； DNA。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.TreeMap;public class Trie &#123; private class Node &#123; public boolean isWord; public TreeMap&lt;Character, Node&gt; next; public Node(boolean isWord) &#123; this.isWord = isWord; next = new TreeMap&lt;&gt;(); &#125; public Node() &#123; this(false); &#125; &#125; private Node root; private int size; public Trie() &#123; root = new Node(); size = 0; &#125; //获得Trie中存储的单词数量 public int getSize() &#123; return size; &#125; //向Trie中添加一个新的单词word public void add(String word) &#123; Node cur = root; for(int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); if(cur.next.get(c) == null) &#123; cur.next.put(c, new Node()); &#125; cur = cur.next.get(c); &#125; if(!cur.isWord) &#123; cur.isWord = true; size++; &#125; &#125; //查询单词word是否在Trie中 public boolean contains(String word) &#123; Node cur = root; for(int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); if(cur.next.get(c) == null) &#123; return false; &#125; cur = cur.next.get(c); &#125; return cur.isWord; &#125; //查询是否在Trie中有单词以prefix为前缀 public boolean isPrefix(String prefix) &#123; Node cur = root; for(int i = 0; i &lt; prefix.length(); i++) &#123; char c = prefix.charAt(i); if(cur.next.get(c) == null) &#123; return false; &#125; cur = cur.next.get(c); &#125; return true; &#125;&#125; 并查集（Union Find）1、一种很不一样的树形结构，孩子指向父亲，可以回答连接问题； 2、并查集（连接问题和路径问题）： 网络中节点间的连接状态：网络是个抽象的概念-用户之间形成的网络； 数学中的集合类实现。 回答连接问题比路径问题要回答的问题少。 3、对于一组数据，主要支持两个动作： union（p，q）； isConnected（p， q）。 4、并查集实现： Quick Find：unionElements(p, q)-O(n)、isConnected(p, q)- O(1) 5、并查集时间复杂度：O（log*n） 近乎是O（1）级别的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class UnionFind implements UF &#123; private int[] parent; private int[] rank; public UnionFind(int size) &#123; parent = new int[size]; rank = new int[size]; for(int i =0; i &lt; size; i++) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; //查找过程，查找元素p所对应的集合编号 //O（h）复杂度，h为树的高度 private int find(int p) &#123; if(p &lt; 0 || p &gt;= parent.length) &#123; throw new IllegalArgumentException(\"p is out of bound.\"); &#125; if(p != parent[p]) &#123; parent[p] = find(parent[p]); &#125; return parent[p]; &#125; //查看元素p和元素q是否所属一个集合 @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; //合并元素p和元素q所属的集合 //O(h)复杂度，h为树的高度 @Override public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if(pRoot == qRoot) &#123; return; &#125; //根据两个元素所在树的rank不同判断合并方向 //将rank低的集合合并到rank高的集合上 if(rank[pRoot] &lt; rank[qRoot]) &#123; parent[pRoot] = qRoot; &#125; else if(rank[pRoot] &gt; rank[qRoot]) &#123; parent[qRoot] = pRoot; &#125; else &#123; parent[pRoot] = qRoot; rank[qRoot] += 1; &#125; &#125;&#125; 平衡二叉树与AVL树1、AVL树是最经典的平衡二叉树，AVL发明人：G. M. Adelson-Velsky 和 E. M. Landis； 2、AVL树是最早的自平衡的二分搜索树结构； 3、平衡二叉树： 满二叉树一定是平衡二叉树； 完全二叉树、线段树也是平衡二叉树； AVL树中，对于任意一个节点，左子树和右子树的高度差不能超过1，平衡二叉树的高度和节点数量之间的关系是O（logn）的； 标注节点的高度，计算平衡因子：左右子树高度差。 4、右旋转：插入的元素在不平衡的节点的左侧的左侧； ​ 左旋转：插入的元素在不平衡的节点的右侧的右侧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279import com.map.Map;import java.util.ArrayList;public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; implements Map&lt;K, V&gt; &#123; private class Node &#123; public K key; public V value; public Node left, right; public int height; public Node(K key, V value) &#123; this.key = key; this.value = value; left = null; right = null; height = 1; &#125; &#125; private Node root; private int size; public AVLTree() &#123; this.root = null; this.size = 0; &#125; @Override public int getSize() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; //获得节点node的高度 public int getHeight(Node node) &#123; if(node == null) &#123; return 0; &#125; return node.height; &#125; //获得节点node的平衡因子 private int getBalanceFactor(Node node) &#123; if(node == null) &#123; return 0; &#125; return getHeight(node.left) - getHeight(node.right); &#125; //判断该二叉树是否是一棵二分搜索树 public boolean isBST() &#123; ArrayList&lt;K&gt; keys = new ArrayList&lt;&gt;(); inOrder(root, keys); for(int i = 1; i &lt; keys.size(); i++) &#123; if(keys.get(i - 1).compareTo(keys.get(i)) &gt; 0) &#123; return false; &#125; &#125; return true; &#125; private void inOrder(Node node, ArrayList&lt;K&gt; keys) &#123; if(node == null) &#123; return; &#125; inOrder(node.left, keys); keys.add(node.key); inOrder(node.right, keys); &#125; //判断该二叉树是否是一棵平衡二叉树 public boolean isBanlanced() &#123; return isBanlanced(root); &#125; //判断以Node为根的二叉树是否是一棵平衡二叉树，递归算法 private boolean isBanlanced(Node node) &#123; if(node == null) &#123; return true; &#125; int balanceFactor = getBalanceFactor(node); if(Math.abs(balanceFactor) &gt; 1) &#123; return false; &#125; return isBanlanced(node.left) &amp;&amp; isBanlanced(node.right); &#125; // 对节点y进行向右旋转操作，返回旋转后新的根节点x // y x // / \\ / \\ // x T4 向右旋转 (y) z y // / \\ - - - - - - - -&gt; / \\ / \\ // z T3 T1 T2 T3 T4 // / \\ // T1 T2 private Node rightRotate(Node y) &#123; Node x = y.left; Node T3 = x.right; //向右旋转过程 x.right = y; y.left = T3; //更新height y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1; x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1; return x; &#125; // 对节点y进行向左旋转操作，返回旋转后新的根节点x // y x // / \\ / \\ // T1 x 向左旋转 (y) y z // / \\ - - - - - - - -&gt; / \\ / \\ // T2 z T1 T2 T3 T4 // / \\ // T3 T4 private Node leftRotate(Node y) &#123; Node x = y.right; Node T2 = x.left; //左旋转 x.left = y; y.right = T2; //更新height y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1; x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1; return x; &#125; @Override public void add(K key, V value) &#123; root = add(root, key, value); &#125; private Node add(Node node, K key, V value) &#123; //向以node为根的二分搜索树中插入元素E，递归算法 //返回插入新节点后二分搜索树的根 if(node == null) &#123; size++; return new Node(key, value); &#125; if(key.compareTo(node.key) &lt; 0) &#123; node.left = add(node.left, key, value); &#125; if(key.compareTo(node.key) &gt; 0) &#123; node.right = add(node.right, key, value); &#125; if(key.compareTo(node.key) == 0) &#123; node.value = value; &#125; //更新height node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right)); //计算平衡因子 int balanceFactor = getBalanceFactor(node);// if(Math.abs(balanceFactor) &gt; 1) &#123;// System.out.println(\"unbalanced:\" + balanceFactor);// &#125; //平衡维护 //LL if(balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(node.left) &gt;= 0) &#123;//右旋转 return rightRotate(node); &#125; //RR if(balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(node.right) &lt;= 0) &#123; return leftRotate(node); &#125; //LR，先转化为LL情况 if(balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(node.left) &lt; 0) &#123; node.left = leftRotate(node.left); return rightRotate(node); &#125; //RL，先转化为RR情况 if(balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(node.right) &gt; 0) &#123; node.right = rightRotate(node.right); return leftRotate(node); &#125; return node; &#125; //返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node) &#123; if(node.left == null) &#123; return node; &#125; return minimum(node.left); &#125; //从二分搜索树中删除元素为e的节点 @Override public V remove(K key) &#123; Node node = getNode(root, key); if(node != null) &#123; root = remove(root, key); return node.value; &#125; return null; &#125; //删除以node为根的二分搜索树中键为key的节点，递归算法 //返回删除节点后新的二分搜索树的根 private Node remove(Node node, K key) &#123; if(node == null) &#123; return null; &#125; Node retNode; if(key.compareTo(node.key) &lt; 0) &#123; node.left = remove(node.left, key); retNode = node; &#125; else if(key.compareTo(node.key) &gt; 0) &#123; node.right = remove(node.right, key); retNode = node; &#125; else &#123;//key == node.key //待删节点左子树为空的情况 if(node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; retNode = rightNode; &#125; //待删节点右子树为空的情况 else if(node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; retNode = leftNode; &#125; //待删节点左右子树为均不为空的情况 //找到比待删节点大的最小节点，即待删除节点右子树的最小节点 //用这个节点顶替待删除节点的位置 else &#123; Node successor = minimum(node.right); successor.right = remove(node.right, successor.key); successor.left = node.left; node.left = node.right = null; retNode = successor; &#125; &#125; if(retNode == null) &#123; return null; &#125; //更新height retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right)); //计算平衡因子 int balanceFactor = getBalanceFactor(retNode); //平衡维护 //LL if(balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(retNode.left) &gt;= 0) &#123;//右旋转 return rightRotate(retNode); &#125; //RR if(balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(retNode.right) &lt;= 0) &#123; return leftRotate(retNode); &#125; //LR，先转化为LL情况 if(balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(retNode.left) &lt; 0) &#123; retNode.left = leftRotate(retNode.left); return rightRotate(retNode); &#125; //RL，先转化为RR情况 if(balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(retNode.right) &gt; 0) &#123; retNode.right = rightRotate(retNode.right); return leftRotate(retNode); &#125; return retNode; &#125; @Override public boolean contains(K key) &#123; return getNode(root, key) != null; &#125; @Override public V get(K key) &#123; Node node = getNode(root, key); return node == null ? null : node.value; &#125; @Override public void set(K key, V newValue) &#123; Node node = getNode(root, key); if(node == null) &#123; throw new IllegalArgumentException(key + \" doesn't exist!\"); &#125; node.value = newValue; &#125; //返回以node为根节点的二分搜索树中，key所在的节点 private Node getNode(Node node, K key) &#123; if(node == null) &#123; return null; &#125; if(key.compareTo(node.key) == 0) &#123; return node; &#125; else if(key.compareTo(node.key) &lt; 0) &#123; return getNode(node.left, key); &#125; else &#123; return getNode(node.right, key); &#125; &#125;&#125; 红黑树1、红黑树（是一棵二分搜索树）： 每个节点或者是红色的，或者是黑色的； 根节点是黑色的； 每一叶子节点（最后的空节点）是黑色的； 如果一个节点是红色的，那么它的孩子节点都是黑色的； 从任意一个节点到叶子节点，经过的黑色节点是一样的。 2、2-3树： 满足二分搜索树的基本性质； 节点可以存放一个元素或者两个元素； 每个节点有2个或者3个孩子（2-3树）； 2-3树是一棵绝对平衡的树(从根节点到任意一个叶子节点所经过的节点数量相同)。 3、红黑树： 红色：节点与父亲节点融合在一起； 红黑树是保持”黑平衡“的二叉树，严格意义上，不是平衡二叉树，最大高度2logn -&gt;O（logn）。 4、红黑树添加新元素： 维护的时机：和AVL树一样，添加节点后回溯向上维护。 5、红黑树的性能总结： 对于完全随机的数据，普通的二分搜索树很好用！ 缺点：极端情况退化成链表（或者高度不平衡）； 对于查询较多的使用情况，AVL树很好用！ 红黑树牺牲了平衡性（2logn的高度）； 统计性能更优（综合增删改查所有的操作）。 6、红黑树更多问题：红黑树中删除节点、左倾红黑树、右倾红黑树、另一种统计性能优秀的树结构：Splay Tree（伸展树）–&gt;局部性原理：刚被访问的内容下次高概率被再次访问、基于红黑树的Map和Set（java.util中的TreeMap和TreeSet基于红黑树）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193import java.util.ArrayList;public class RBTree&lt;K extends Comparable&lt;K&gt;, V&gt; &#123; private static final boolean RED = true; private static final boolean BLACK = false; private class Node&#123; public K key; public V value; public Node left, right; public boolean color; public Node(K key, V value)&#123; this.key = key; this.value = value; left = null; right = null; color = RED; &#125; &#125; private Node root; private int size; public RBTree()&#123; root = null; size = 0; &#125; public int getSize()&#123; return size; &#125; public boolean isEmpty()&#123; return size == 0; &#125; // 判断节点node的颜色 private boolean isRed(Node node)&#123; if(node == null) return BLACK; return node.color; &#125; // node x // / \\ 左旋转 / \\ // T1 x ---------&gt; node T3 // / \\ / \\ // T2 T3 T1 T2 private Node leftRotate(Node node)&#123; Node x = node.right; // 左旋转 node.right = x.left; x.left = node; x.color = node.color; node.color = RED; return x; &#125; // node x // / \\ 右旋转 / \\ // x T2 -------&gt; y node // / \\ / \\ // y T1 T1 T2 private Node rightRotate(Node node) &#123; Node x = node.left; //右旋转 node.left = x.right; x.right = node; x.color = node.color; node.color = RED; return x; &#125; //颜色翻转 private void flipColors(Node node) &#123; node.color = RED; node.left.color = BLACK; node.right.color = BLACK; &#125; // 向红黑树中添加新的元素(key, value) public void add(K key, V value)&#123; root = add(root, key, value); root.color = BLACK; // 最终根节点为黑色节点 &#125; // 向以node为根的红黑树中插入元素(key, value)，递归算法 // 返回插入新节点后红黑树的根 private Node add(Node node, K key, V value)&#123; if(node == null)&#123; size ++; return new Node(key, value); // 默认插入红色节点 &#125; if(key.compareTo(node.key) &lt; 0) node.left = add(node.left, key, value); else if(key.compareTo(node.key) &gt; 0) node.right = add(node.right, key, value); else // key.compareTo(node.key) == 0 node.value = value; // if(isRed(node.right) &amp;&amp; !isRed(node.left)) &#123; node = leftRotate(node); &#125; if(isRed(node.left) &amp;&amp; isRed(node.left.left)) &#123; node = rightRotate(node); &#125; if(isRed(node.left) &amp;&amp; isRed(node.right)) &#123; flipColors(node); &#125; return node; &#125; // 返回以node为根节点的二分搜索树中，key所在的节点 private Node getNode(Node node, K key)&#123; if(node == null) return null; if(key.equals(node.key)) return node; else if(key.compareTo(node.key) &lt; 0) return getNode(node.left, key); else // if(key.compareTo(node.key) &gt; 0) return getNode(node.right, key); &#125; public boolean contains(K key)&#123; return getNode(root, key) != null; &#125; public V get(K key)&#123; Node node = getNode(root, key); return node == null ? null : node.value; &#125; public void set(K key, V newValue)&#123; Node node = getNode(root, key); if(node == null) throw new IllegalArgumentException(key + \" doesn't exist!\"); node.value = newValue; &#125; // 返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node)&#123; if(node.left == null) return node; return minimum(node.left); &#125; // 删除掉以node为根的二分搜索树中的最小节点 // 返回删除节点后新的二分搜索树的根 private Node removeMin(Node node)&#123; if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; node.left = removeMin(node.left); return node; &#125; // 从二分搜索树中删除键为key的节点 public V remove(K key)&#123; Node node = getNode(root, key); if(node != null)&#123; root = remove(root, key); return node.value; &#125; return null; &#125; private Node remove(Node node, K key)&#123; if( node == null ) return null; if( key.compareTo(node.key) &lt; 0 )&#123; node.left = remove(node.left , key); return node; &#125; else if(key.compareTo(node.key) &gt; 0 )&#123; node.right = remove(node.right, key); return node; &#125; else&#123; // key.compareTo(node.key) == 0 // 待删除节点左子树为空的情况 if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; // 待删除节点右子树为空的情况 if(node.right == null)&#123; Node leftNode = node.left; node.left = null; size --; return leftNode; &#125; // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; &#125; &#125;&#125; 哈希表1、哈希表：每一个字符都和一个索引相对应 O(1)的查找操作！ 2、哈希函数：对于给定字符，将其转为索引的方法； 3、哈希冲突：每一个”键“通过哈希函数的转换对应相同的”索引“； 4、哈希表充分体现了算法设计领域的经典思想：空间换时间，哈希表是时间和空间之间的平衡； 5、哈希函数的设计：”键“通过哈希函数得到的”索引“分布越均匀越好； 6、大整数： 通常做法：取模（陷阱-&gt;分布不均匀）； 简单解决办法：模一个素数。 7、浮点型（转成整型处理）：在计算机中都是32位或者64位的二进制表示，只不过计算机解析成了浮点数； 8、字符串：转成整型处理； 9、复合类型：转成整型处理； 10、哈希函数设计原则： 一致性：如果a==b，则hash（a）= hash（b）； 高效性：计算高效简便； 均匀性：哈希值均匀分布。 11、Java默认的hash函数是根据对象的地址计算hashcode； 12、哈希冲突处理：链地址法（Separate Chaining）； 13、Java8之前，每个位置对应一个链表； ​ Java8开始，当哈希冲突达到一定程度，每一个位置从链表转成红黑树。 14、哈希表，链地址法时间复杂度： 总共有M个地址，如果放入哈希表的元素为N， 如果每个地址是链表：O(N/M)； 如果每个地址是平衡树：O(log(N/M))。 15、哈希表： 均摊复杂度为O（1）； 牺牲了顺序性。 16、集合、映射： 有序集合、有序映射（平衡树）； 无序集合、无序映射（哈希表）。 17、哈希冲突的处理方法： 开放地址法：开放（每个地址对任何元素开放）； 线性探测（遇到哈希冲突+1）、平方探测（遇到冲突 + 1+ 4 + 9 + 16）、二次哈希（遇到哈希冲突 + hash2（key））； 负载率：哈希表存储的元素分比 链地址法：封闭； 再哈希法：用另外哈希函数找索引； Coalesced Hashing：综合了Separate Chaining 和 Open Addressing。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.util.TreeMap;public class HashTable&lt;K, V&gt; &#123; private final int[] capacity = &#123;53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469, 12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457, 1610612741&#125;;//保证扩容缩容是素数 private static final int upperTol = 10; private static final int lowerTol = 2; private int capacityIndex = 0; private TreeMap&lt;K, V&gt;[] hashtable; private int M; private int size; public HashTable() &#123; this.M = capacity[capacityIndex]; size = 0; hashtable = new TreeMap[M]; for(int i = 0; i &lt; M; i++) &#123; hashtable[i] = new TreeMap&lt;&gt;(); &#125; &#125; private int hash(K key) &#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public int getSize() &#123; return size; &#125; public void add(K key, V value) &#123; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; if(map.containsKey(key)) &#123; map.put(key, value); &#125; else &#123; map.put(key, value); size++; if(size &gt;= upperTol * M &amp;&amp; capacityIndex + 1 &lt; capacity.length) &#123; capacityIndex++; resize(capacity[capacityIndex]); &#125; &#125; &#125; public V remove(K key) &#123; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; V ret = null; if(map.containsKey(key)) &#123; ret = map.remove(key); size--; if(size &lt; lowerTol * M &amp;&amp; capacityIndex - 1 &gt;= 0) &#123; capacityIndex--; resize(capacity[capacityIndex]); &#125; &#125; return ret; &#125; public void set(K key, V value) &#123; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; if(!map.containsKey(key)) &#123; throw new IllegalArgumentException(key + \" does't exist!\"); &#125; map.put(key, value); &#125; public boolean contains(K key) &#123; return hashtable[hash(key)].containsKey(key); &#125; public V get(K key) &#123; return hashtable[hash(key)].get(key); &#125; private void resize(int newM) &#123; TreeMap&lt;K, V&gt;[] newHashTable = new TreeMap[newM]; for(int i =0; i &lt; newM; i++) &#123; newHashTable[i] = new TreeMap&lt;&gt;(); &#125; int oldM = M; this.M = newM; for(int i = 0; i &lt; oldM; i++) &#123; TreeMap&lt;K, V&gt; map = hashtable[i]; for(K key : map.keySet()) &#123; newHashTable[hash(key)].put(key, map.get(key)); &#125; &#125; this.hashtable = newHashTable; &#125;&#125; 总结 线性结构：动态数组、普通队列、栈、链表、哈希表； 树形结构：二分搜索树、AVL树、红黑树（统计性能更高）、 堆、线段树、Trie、并查集； 图结构：邻接表、邻接矩阵。 抽象数据结构： 线性表：动态数组、链表； 栈、队列； 集合（有序、无序）、映射（有序、无序）。 参考资料：https://github.com/liuyubobobo/Play-with-Data-Structures","comments":true,"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"Java集合框架","date":"2019-06-07T11:51:45.000Z","path":"2019/06/07/Java集合框架/","text":"Java集合框架（List、Set、Map）总结。 About1、按照接口、实现、算法三个方面对集合框架中的数据结构进行分类： 接口：Collection、List、Map 组成了集合框架中所有具体实现类的接口，它们定义了子类必须实现的方法。 实现：所有实现了上述3个接口的类，都被称作集合框架，实际上就是数据结构。 算法：集合框架提供了很多可以直接调用的算法，比如求最大最小值、排序、填充等。 2、继承体系： 分为两大类，一类实现了 Collection 接口，一类实现了 Map 接口。 3、集合框架核心接口及实现类： Collection：根接口，大部分数据结构都实现了 Collection 接口中的方法； List：实现 List 接口的数据结构，允许重复元素，可通过 index 访问元素，例如 LinkedList、ArrayList、Vector； Set：实现 Set 接口的数据结构，不允许重复的元素，例如 HashSet、LinkedHashSet； SortedSet：实现 SortedSet 接口的数据结构，默认可按升序打印元素，例如 TreeSet； Map：实现 Map 接口的数据结构，存储键值对，不允许重复的 key，例如 HashMap、LinkedHashMap、Hashtable； SortedMap：继承了 Map 接口，存储键值对，不允许重复的 key，默认可按 key 升序打印元素，例如 TreeMap。 SortedSet 与 SortedMap 默认的排序是自然序，可通过 Comparator 或 Comparable 接口实现自定义排序。 4、在接口与具体的实现类之间还有一些抽象类： 这些抽象类为集合增加了很多功能： HashSet：实现 Set 接口，不允许重复的元素，底层数据结构 hash table； LinkedHashSet：实现 Set 接口，不允许重复的元素，底层数据结构 hash table 与双链表； TreeSet：实现 NavigableSet 接口，不允许重复的元素，底层数据结构红黑树； ArrayList：实现 List 接口，允许重复元素，底层数据结构可变数组； LinkedList：实现 List 接口，允许重复元素，底层数据结构双链表； Vector：实现 List 接口，允许重复元素，底层数据结构可变数组； HashMap：实现 Map 接口，不允许重复的 key，底层数据结构 hash table； LinkedHashMap：实现 Map 接口，不允许重复的 key，底层数据结构 hash table 与双链表； HashTable：实现 Map 接口，不允许重复的 key，底层数据结构 hash table； TreeMap：实现 SortedMap 接口，不允许重复的 key，底层数据结构红黑树。 List一个有序的Collection（也称序列），元素可以重复。列表通常允许满足e1.equals(e2)的元素对e1和e2，并且列表允许多个null元素。实现List的类有：ArrayList、LinkedList、Vector、Stack等。其中，最常用的是ArrayList和LinkedList。List接口是有序集合、元素可以重复，次序是List接口最重要的特点，它是以元素的添加的顺序作为集合的顺序。其中ArrayList底层是通过数组实现的，数组的初始长度为10，可以扩展数组。LinkedList底层是通过双向链表实现的，因此LinkedList可以在首尾添加删减元素，因此可以作为栈、队列、双端队列使用。 ArrayList1、概述： ArrayList实现了List接口，以数组实现，允许重复，允许放入null元素，非线程安全。超出限制时会增加50%的容量，每次扩容都底层采用System.arrayCopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建数组的大小为10。 size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。 为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。 2、方法剖析： set() 1234567//既然底层是一个数组，ArrayList的set()方法也就变得非常简单，直接对数组的指定位置赋值即可。public E set(int index, E element) &#123; rangeCheck(index);//下标越界检查 E oldValue = elementData(index); elementData[index] = element;//赋值到指定位置 return oldValue; &#125; get() 123456//get()方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。public E get(int index) &#123; rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index);//注意类型转换 &#125; add() 123456789101112//在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//原来的1.5倍 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);//扩展空间并复制&#125; 空间的问题解决后，插入过程就很容易。 add(int index, E e)需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。 addAll() addAll()方法能够一次添加多个元素，根据位置不同也有两个方法，一个是在末尾添加的addAll(Collection&lt;? extends E&gt; c)方法，一个是从指定位置开始插入的addAll(int index, Collection&lt;? extends E&gt; c)方法。跟add()方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。addAll()的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。 remove() 1234567891011//remove()方法也有两个版本，一个是remove(int index)删除指定位置的元素，另一个是remove(Object o)删除第一个满足o.equals(elementData[index])的元素。删除操作是add()操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, umMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 关于Java GC这里需要特别说明一下，有了垃圾收集器并不意味着一定不会有内存泄漏。对象能否被GC的依据是，是否还有引用指向它，上面代码中如果不手动赋null值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。 LinkedList1、概述： LinkedList以双向链表实现，允许重复，线程不安全。LinkedList同时实现了List接口和Deque接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（Queue），同时又可以看作一个栈（Stack）。这样看来，LinkedList简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用LinkedList，一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是，Java里根本没有一个叫做Queue的类（它是个接口名字）。关于栈或队列，现在的首选是ArrayDeque，它有着比LinkedList（当作栈或队列使用时）更好的性能。 双向链表的每个节点用内部类Node表示。LinkedList通过first和last引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候first和last都指向null。 1234567891011//Node内部类private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; LinkedList的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率LinkedList没有实现同步（synchronized）。 2、方法剖析： add() 123456789101112131415161718192021222324252627282930//add()方法有两个版本，一个是add(E e)，该方法在LinkedList的末尾插入元素，因为有last指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是add(int index, E element)，该方法是在指定下标处插入元素，需要先通过线性查找，找到具体位置，然后修改相关引用完成插入操作。public boolean add(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode;//原来链表为空，这是插入的第一个元素 else l.next = newNode; size++; return true;&#125;//add(int index, E element)的逻辑稍显复杂，可以分成两步，1.先根据index找到要插入的位置；2.修改引用，完成插入操作。public void add(int index, E element) &#123; checkPositionIndex(index);//index &gt;= 0 &amp;&amp; index &lt;= size; if (index == size)//插入位置是末尾，包括列表为空的情况 add(element); else&#123; Node&lt;E&gt; succ = node(index);//1.先根据index找到要插入的位置 //2.修改引用，完成插入操作。 final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null)//插入位置为0 first = newNode; else pred.next = newNode; size++; &#125;&#125; 上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件index &lt; (size &gt;&gt; 1)，也即是index是靠近前端还是后端。 remove() 123456789101112131415161718192021222324//remove()方法也有两个版本，一个是删除跟指定元素相等的第一个元素remove(Object o)，另一个是删除指定下标处的元素remove(int index)。//两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。在寻找被删元素引用的时候remove(Object o)调用的是元素的equals方法，而remove(int index)使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个revome()方法都是通过unlink(Node&lt;E&gt; x)方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。E unlink(Node&lt;E&gt; x) &#123;//删除一个Node // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123;//删除的是第一个元素 first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123;//删除的是最后一个元素 last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; get() 12345//get(int index)得到指定下标处元素的引用，通过调用上文中提到的node(int index)方法实现。public E get(int index) &#123; checkElementIndex(index);//index &gt;= 0 &amp;&amp; index &lt; size; return node(index).item;&#125; set() 12345678//set(int index, E element)方法将指定下标处的元素修改成指定值，也是先通过node(int index)找到对应下表元素的引用，然后修改Node中item的值。public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125; HashSet和HashMapSet几乎都是内部用一个Map来实现, 因为Map里的KeySet就是一个Set，而value是假值，全部使用同一个Object。Set的特征也继承了那些内部Map实现的特征。HashSet里面有一个HashMap（适配器模式）。 HashMap1、概述： HashMap实现了Map接口，允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。HashMap存储着Entry(hash, key, value, next)对象。除该类未实现同步外，其余跟Hashtable大致相同，跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。Java HashMap采用的是冲突链表方式。 如果选择合适的哈希函数，put()和get()方法可以在常数时间内完成。但在对HashMap进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设的过大。 有两个参数可以影响HashMap的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。Capacity的默认值为16，负载因子的默认值为0.75。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。 将对象放入到HashMap或HashSet中时，有两个方法需要特别关心：hashCode()和equals()。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到HashMap或HashSet中，需要@Override hashCode()和equals()方法。 2、方法剖析： get() 上图中hash(k)&amp;(table.length-1)等价于hash(k)%table.length，原因是HashMap要求table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将哈希值的高位全抹掉，剩下的就是余数了。 123456789101112131415//get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.getValue()。因此getEntry()是算法的核心。//算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过key.equals(k)方法来判断是否是要找的那个entry。final Entry&lt;K,V&gt; getEntry(Object key) &#123; ...... int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-1)];//得到冲突链表 e != null; e = e.next) &#123;//依次遍历冲突链表中的每个entry Object k; //依据equals()方法判断是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; put() 123456789101112//put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry，插入方式为头插法。void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);//自动扩容，并重新哈希 hash = (null != key) ? hash(key) : 0; bucketIndex = hash &amp; (table.length-1);//hash%table.length &#125; //在冲突链表头部插入新的entry Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; remove() 123456789101112131415161718192021//remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry（修改链表的相应指针）。查找过程跟getEntry()过程类似。final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; ...... int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length);//hash&amp;(table.length-1) Entry&lt;K,V&gt; prev = table[i];//得到冲突链表 Entry&lt;K,V&gt; e = prev; while (e != null) &#123;//遍历冲突链表 Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;//找到要删除的entry modCount++; size--; if (prev == e) table[i] = next;//删除的是冲突链表的第一个entry else prev.next = next; return e; &#125; prev = e; e = next; &#125; return e;&#125; HashSetHashSet是基于HashMap来实现的，操作很简单，更像是对HashMap做了一次“封装”，而且只使用了HashMap的key来实现各种特性，而HashMap的value始终都是PRESENT。HashSet不允许重复（HashMap的key不允许重复，如果出现重复就覆盖），允许null值，非线程安全。 12345678910111213public class HashSet&lt;E&gt; &#123; ...... private transient HashMap&lt;E,Object&gt; map;//HashSet里面有一个HashMap // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; ...... public boolean add(E e) &#123;//简单的方法转换 return map.put(e, PRESENT)==null; &#125; ...... LinkedHashSet 和 LinkedHashMapLinkedHashSet和LinkedHashMap在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说LinkedHashSet里面有一个LinkedHashMap（适配器模式）。 LinkedHashMap1、概述： LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素，非线程安全。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。可将LinkedHashMap看作采用linked list增强的HashMap。 事实上LinkedHashMap是HashMap的直接子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表（doubly-linked list）的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部（是一个哑元），该双向链表的迭代顺序就是entry的插入顺序。 除了可以保证迭代顺序，这种结构还有一个好处：迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可，也就是说LinkedHashMap的迭代时间就只跟entry的个数相关，而跟table的大小无关。 有两个参数可以影响LinkedHashMap的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。 将对象放入到LinkedHashMap或LinkedHashSet中时，有两个方法需要特别关心：hashCode()和equals()。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到LinkedHashMap或LinkedHashSet中，需要@OverridehashCode()和equals()方法。 12345//通过如下方式可以得到一个跟源Map迭代顺序一样的LinkedHashMapvoid foo(Map m) &#123; Map copy = new LinkedHashMap(m); ...&#125; 2、方法剖析： get() get(Object key)方法根据指定的key值返回对应的value。该方法跟HashMap.get()方法的流程几乎完全一样。 put() 123456789101112131415161718192021222324//put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于get()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry。//这里的插入有两重含义：1、从table的角度看，新的entry需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的entry插入到冲突链表的头部。2、从header的角度看，新的entry需要插入到双向链表的尾部。void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);// 自动扩容，并重新哈希 hash = (null != key) ? hash(key) : 0; bucketIndex = hash &amp; (table.length-1);// hash%table.length &#125; // 1.在冲突链表头部插入新的entry HashMap.Entry&lt;K,V&gt; old = table[bucketIndex]; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(hash, key, value, old); table[bucketIndex] = e; // 2.在双向链表的尾部插入新的entry e.addBefore(header); size++;&#125;//上述代码中用到了addBefore()方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。addBefore()的代码如下：// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this;&#125; remove() 1234567891011121314151617181920212223242526//remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry（修改链表的相应引用）。查找过程跟get()方法类似。//这里的删除也有两重含义：1、从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。2、从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; ...... int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length);// hash&amp;(table.length-1) Entry&lt;K,V&gt; prev = table[i];// 得到冲突链表 Entry&lt;K,V&gt; e = prev; while (e != null) &#123;// 遍历冲突链表 Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;// 找到要删除的entry modCount++; size--; // 1. 将e从对应bucket的冲突链表中删除 if (prev == e) table[i] = next; else prev.next = next; // 2. 将e从双向链表中删除 e.before.after = e.after; e.after.before = e.before; return e; &#125; prev = e; e = next; &#125; return e;&#125; LinkedHashSetLinkedHashSet允许null值，保留插入顺序，非线程安全。 1234567891011121314public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; ...... // LinkedHashSet里面有一个LinkedHashMap public LinkedHashSet(int initialCapacity, float loadFactor) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; ...... public boolean add(E e) &#123;//简单的方法转换 return map.put(e, PRESENT)==null; &#125; ......&#125; TreeMap和TreeSetTreeMap1、总体介绍： Java TreeMap实现了SortedMap接口，也就是说会按照key的大小顺序对Map中的元素进行排序，key大小的评判可以通过其本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator），TreeMap是非线程安全的。 TreeMap底层通过红黑树（Red-Black tree）实现，也就意味着containsKey(), get(), put(), remove()都有着log(n)的时间复杂度。 红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍。具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）： 每个节点要么是红色，要么是黑色； 根节点必须是黑色； 红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）； 对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。 在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的条件。 预备知识当查找树的结构发生改变时，红黑树的条件可能被破坏，需要通过调整使得查找树重新满足红黑树的条件。调整可以分为两类：一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，即改变检索树的结构关系。结构调整过程包含两个基本操作：左旋（Rotate Left），右旋（Rotate Right）。 左旋：将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 1234567891011121314151617private void rotateLeft(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; &#125;&#125; 右旋：将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 123456789101112131415private void rotateRight(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; &#125;&#125; 方法剖析get() 123456789101112131415161718//get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.value。因此getEntry()是算法的核心。算法思想是根据key的自然顺序（或者比较器顺序）对二叉查找树进行查找，直到找到满足k.compareTo(p.key) == 0的entry。final Entry&lt;K,V&gt; getEntry(Object key) &#123; ...... if (key == null)//不允许key值为null throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序 Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0)//向左找 p = p.left; else if (cmp &gt; 0)//向右找 p = p.right; else return p; &#125; return null;&#125; put() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束，还需要进行调整（旋转，改变某些节点的颜色）。//首先在红黑树上找到合适的位置，然后创建新的entry并插入（当然，新插入的节点一定是树的叶子）。难点是调整函数fixAfterInsertion()，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。public V put(K key, V value) &#123; ...... int cmp; Entry&lt;K,V&gt; parent; if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left;//向左找 else if (cmp &gt; 0) t = t.right;//向右找 else return t.setValue(value); &#125; while (t != null); Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);//创建并插入新的entry if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e);//调整 size++; return null;&#125;//调整函数fixAfterInsertion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况。private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123;//如果y为null，则视为BLACK setColor(parentOf(x), BLACK); // 情况1 setColor(y, BLACK); // 情况1 setColor(parentOf(parentOf(x)), RED); // 情况1 x = parentOf(parentOf(x)); // 情况1 &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); // 情况2 rotateLeft(x); // 情况2 &#125; setColor(parentOf(x), BLACK); // 情况3 setColor(parentOf(parentOf(x)), RED); // 情况3 rotateRight(parentOf(parentOf(x))); // 情况3 &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); // 情况4 setColor(y, BLACK); // 情况4 setColor(parentOf(parentOf(x)), RED); // 情况4 x = parentOf(parentOf(x)); // 情况4 &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); // 情况5 rotateRight(x); // 情况5 &#125; setColor(parentOf(x), BLACK); // 情况6 setColor(parentOf(parentOf(x)), RED); // 情况6 rotateLeft(parentOf(parentOf(x))); // 情况6 &#125; &#125; &#125; root.color = BLACK;&#125; remove() remove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entry&lt;K,V&gt; entry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束，因此有可能要进行调整。 寻找节点后继： 对于一棵二叉查找树，给定节点t，其后继（树种比大于t的最小的那个元素）可以通过如下方式找到： t的右子树不空，则t的后继是其右子树中最小的那个元素。 t的右孩子为空，则t的后继是其第一个向左走的祖先。 123456789101112131415161718static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.right != null) &#123;// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素 Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; &#125; else &#123;// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先 Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.right) &#123; ch = p; p = p.parent; &#125; return p; &#125;&#125; remove() getEntry()函数前面已经讲解过，这里重点放deleteEntry()上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用fixAfterDeletion(Entry&lt;K,V&gt; x)进行调整。 由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况： 删除点p的左右子树都为空，或者只有一棵子树非空。 删除点p的左右子树都非空。 对于上述情况1，处理起来比较简单，直接将p删除（左右子树都为空时），或者用非空子树替代p（只有一棵子树非空时）；对于情况2，可以用p的后继s（树中大于x的最小的那个元素）代替p，然后使用情况1删除s（此时s一定满足情况1，可以画画看）。 基于以上逻辑，红黑树的节点删除函数deleteEntry()代码如下： 1234567891011121314151617181920212223242526272829303132333435private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; if (p.left != null &amp;&amp; p.right != null) &#123;// 2. 删除点p的左右子树都非空。 Entry&lt;K,V&gt; s = successor(p);// 后继 p.key = s.key; p.value = s.value; p = s; &#125; Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123;// 1. 删除点p只有一棵子树非空。 replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; p.left = p.right = p.parent = null; if (p.color == BLACK) fixAfterDeletion(replacement);// 调整 &#125; else if (p.parent == null) &#123; root = null; &#125; else &#123; // 1. 删除点p的左右子树都为空 if (p.color == BLACK) fixAfterDeletion(p);// 调整 if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125;&#125; 上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数fixAfterDeletion()。首先请思考一下，删除了哪些点才会导致调整？只有删除点是BLACK的时候，才会触发调整函数，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。 跟上文中讲过的fixAfterInsertion()函数一样，这里也要分成若干种情况。记住，无论有多少情况，具体的调整操作只有两种：1.改变某些节点的颜色，2.对某些节点进行旋转。 上述图解的总体思想是：将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则：a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环（因为x为红色）；b).一旦进入情况3和情况4，一定会退出循环（因为x为root）。 删除后调整函数fixAfterDeletion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); // 情况1 setColor(parentOf(x), RED); // 情况1 rotateLeft(parentOf(x)); // 情况1 sib = rightOf(parentOf(x)); // 情况1 &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); // 情况2 x = parentOf(x); // 情况2 &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); // 情况3 setColor(sib, RED); // 情况3 rotateRight(sib); // 情况3 sib = rightOf(parentOf(x)); // 情况3 &#125; setColor(sib, colorOf(parentOf(x))); // 情况4 setColor(parentOf(x), BLACK); // 情况4 setColor(rightOf(sib), BLACK); // 情况4 rotateLeft(parentOf(x)); // 情况4 x = root; // 情况4 &#125; &#125; else &#123; // 跟前四种情况对称 Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); // 情况5 setColor(parentOf(x), RED); // 情况5 rotateRight(parentOf(x)); // 情况5 sib = leftOf(parentOf(x)); // 情况5 &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); // 情况6 x = parentOf(x); // 情况6 &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); // 情况7 setColor(sib, RED); // 情况7 rotateLeft(sib); // 情况7 sib = leftOf(parentOf(x)); // 情况7 &#125; setColor(sib, colorOf(parentOf(x))); // 情况8 setColor(parentOf(x), BLACK); // 情况8 setColor(leftOf(sib), BLACK); // 情况8 rotateRight(parentOf(x)); // 情况8 x = root; // 情况8 &#125; &#125; &#125; setColor(x, BLACK);&#125; TreeSetTreeSet是对TeeMap的简单包装，对TreeSet的函数调用都会转换成合适的TeeMap方法。TreeSet不允许重复，不允许null值（如果有基于null的比较器，就可以允许为null），默认按升序排列。 12345678910111213141516public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123; ...... private transient NavigableMap&lt;E,Object&gt; m; // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); public TreeSet() &#123; this.m = new TreeMap&lt;E,Object&gt;();// TreeSet里面有一个TreeMap &#125; ...... public boolean add(E e) &#123; return m.put(e, PRESENT)==null; &#125; ......&#125; 博客转自：https://www.cnblogs.com/CarpenterLee/p/5545987.html","comments":true,"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://yoursite.com/tags/Java集合框架/"}]},{"title":"常用Linux命令","date":"2019-06-06T08:00:00.000Z","path":"2019/06/06/常用Linux命令/","text":"Linux 常用命令及解释。 很多服务器上都是Linux系统，要和服务器机器交互，就要通过shell命令。 查找文件1、find / -name filename.txt 根据名称查找/目录下的filename.txt文件 2、find . -name “*.xml” 递归查找当前目录下所有的xml文件 3、find . -name “*.xml” | xargs grep “hello world” 递归查找当前目录下所有文件内容中包含hello world的xml文件 4、grep -H ‘spring’ *.xml 查找当前目录下所有包含spring的xml文件 5、find ./ -size 0 | xargs rm -f &amp; 删除文件大小为零的文件 6、ls -l | grep ‘.jar’ 查找当前目录中的所有jar文件 7、grep ‘test’ d* 显示当前目录下所有以d开头的文件中包含test的行 8、grep ‘test’ aa bb cc 显示在aa，bb，cc文件中匹配test的行 9、grep ‘[a-z]{5}‘ aa 显示所有包含每个字符串至少有5个连续小写字符的字符串的行 查看一个程序是否运行1、ps –ef | grep tomcat 查看所有有关tomcat的进程 2、ps -ef | grep –color java 高亮要查询的关键字 终止线程kill -9 20000 终止线程号为20000的进程 查看文件，包含隐藏文件ls -al 当前工作目录pwd 复制文件1、cp source 新文件名/目录， 复制文件 2、cp -r sourceFolder targetFolder 递归复制整个文件夹 3、scp sourecFile romoteUserName@remoteIp:remoteAddr 远程拷贝 创建目录mkdir newfolder 删除目录1、rmdir deleteEmptyFolder 删除空目录 2、rm -rf deleteFile 递归删除目录中所有内容 移动文件mv /temp/movefile /targetFolder 重命名mv oldNameFile newNameFile 切换用户su -username 修改文件权限chmod 777 file.java //file.java的权限-rwx，r表示读、w表示写、x表示可执行 压缩文件tar -czf test.tar.gz /test1 /test2 列出压缩文件列表tar -tzf test.tar.gz 解压文件tar -xvzf test.tar.gz 查看文件头10行head -n 10 example.txt 查看文件尾10行tail -n 10 example.txt 查看日志类型文件tail -f exmaple.log //这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）。 使用超级管理员身份执行命令sudo rm a.txt 使用管理员身份删除文件 查看端口占用情况netstat -tln | grep 8080 查看端口8080的使用情况 查看端口属于哪个程序lsof -i :8080 查看进程1、ps aux|grep java 查看java进程 2、ps aux 查看所有进程 以树状图列出目录的内容tree a 文件下载1、wget http://file.tgz 2、curl http://file.tgz 网络检测ping www.just-ping.com 远程登录ssh userName@ip 查看ip地址ifconfig -a 打印信息echo $JAVA_HOME 打印java home环境变量的值 java 常用命令java javac jps ,jstat ,jmap, jstack 其他命令svn、 git 、maven linux命令学习网站http://explainshell.com/ linux命令搜索引擎https://jaywcjlove.gitee.io/linux-command/ 博客转自：https://www.hollischuang.com/archives/800","comments":true,"tags":[{"name":"Linux常用命令","slug":"Linux常用命令","permalink":"http://yoursite.com/tags/Linux常用命令/"}]},{"title":"设计模式-单例模式","date":"2019-06-05T02:03:09.000Z","path":"2019/06/05/单例模式/","text":"单例模式介绍。 About1、模式定义：单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 单例模式的要点有三个： 某个类只能有一个实例； 它必须自行创建这个实例； 它必须自行向整个系统提供这个实例。 单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。 2、模式结构： 单例模式只有一个Singleton角色，并且这个类自行创建自己的实例，并向系统提供这个实例。 单例模式分为懒汉式的和饿汉式，登记式的单例模式，下面我们就来介绍一下这三种单例模式。 饿汉式的单例模式1、饿汉式单例模式是Java语言中实现起来最为简单的单例模式。 2、饿汉式：初始化类时，直接就创建唯一实例，天生线程安全。 3、三要素： 一个静态类变量； 一个私有构造方法； 一个全局静态的类方法。 4、代码实现： 12345678910public class EagerSingleton &#123; //直接创建一个本类的对象 private static EagerSingleton instance = new EagerSingleton(); //覆盖默认的构造方法，将默认的构造方法声明为私有的，防止其他类直接创建对象，将 new Singleton() 堵死 private EagerSingleton() &#123;&#125; //提供一个工厂方法来返回本类的唯一对象 public static EagerSingleton getInstance() &#123; return instance; &#125;&#125; 5、饿汉式单例模式就是一开始就自己创建一个私有的静态的本类对象，当这个类被加载时，静态变量instance就会被初始化，这时这个类的私有构造方法就会被调用。这个时候，单例类的唯一实例就被创建出来了。但需要获得单例类的对象是就调用getInstance方法。需要注意的一点就是单例类的构造方法一定要声明为私有的，否则其他类就可以利用构造方法直接创建对象，使单例类不再是只有一个唯一的实例。 由于构造方法是私有的，因此此类不能被继承。 饿汉式单例模式在自己加载时就将自己实例化，所以从资源利用效率的角度来讲，饿汉式单例模式不如懒汉式单例模式节省资源，但是饿汉式单例模式的速度更快一些。 懒汉式的单例模式1、懒汉式：加载类时，第一次调用方法获得实例为唯一的实例，线程不安全。 2、三要素： 一个静态类变量； 一个私有构造方法； 一个全局静态的类方法。 3、代码实现： 12345678910111213141516171819public class LazySingleton &#123; //单例类的唯一实例，但是不是加载时初始化 private static volatile LazySingleton instacnce = null; //构造函数私有为了保证在其他地方不能new该实例 private LazySingleton() &#123;&#125; //线程互斥的获取实例 public static LazySingleton getInstance() &#123;//获得实例 if(instacnce == null) &#123; // 加锁 synchronized (LazySingleton.class) &#123; // 这一次判断也是必须的，不然会有并发问题 if(instacnce == null) &#123; instacnce = new LazySingleton(); &#125; &#125; &#125; return instacnce; &#125;&#125; 4、懒汉式单例模式的创建对象是在第一次企图获得单例类的对象时。另外我们在getInstance方法中使用了synchronization关键字，这是防止出现race condition，使两个线程new出来两个单例类的实例。构造方法同样是私有的，这也决定了子类不能继承自这个类。 懒汉式单例模式与饿汉式单例模式相比，更节省资源，但是必须处理好在多个线程同时首次引用此类时的访问限制问题，特别是当单例类作为资源控制器在实例化时必然涉及资源初始化，而资源初始化很有可能耗费时间，这就意味着出现多个线程同时首次引用此类的几率变得较大。 登记式的单例模式1、为了克服饿汉式单例模式以及懒汉式单例模式类均不可继承的缺点，产生了一种新的模式——登记式单例模式。 登记式的单例模式中父类中有一个集合，用来存储所有的子类的实例，当一个子类创建时，必须在父类的中登记，也就是把自己的实例加入到父类的集合中，当其他类想要获取子类的实例时，就到父类的集合中查找，找到了就返回，如果找不到就创建这个子类的唯一实例。 2、父类代码： 12345678910111213141516171819202122232425262728293031package com.singleton;import java.util.HashMap;public class RegSingleton &#123; //建立一个HashMap来存储子类的完整类名和子类的实例 private static HashMap&lt;String, RegSingleton&gt; registry = new HashMap&lt;&gt;(); //首先将本类的实例加入到HashMap中 static &#123; RegSingleton x = new RegSingleton(); registry.put(x.getClass().getName(), x); &#125; //构造方法不再是private的了，所以子类可以继承了 protected RegSingleton() &#123; &#125; //根据子类传来的类名返回相应的实例 public static RegSingleton getInstance(String name) &#123; //提供默认的类 if(name == null) &#123; name = \"com.singleton.RegSingleton\"; &#125; //第一次引用这个类时创建类的实例，利用了反射机制 if(registry.get(name) == null) &#123; try &#123; registry.put(name, (RegSingleton)Class.forName(name).newInstance()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //返回子类想要的类的实例 return registry.get(name); &#125;&#125; 子类代码： 12345678910package com.singleton;public class RegSingletonChild extends RegSingleton &#123; //构造方法必须是公有的，否则父类无法产生子类的对象 public RegSingletonChild() &#123; &#125; //工厂方法，获取本类的唯一实例，实际上是借助了父类的getInstance方法 public static RegSingletonChild getInstance() &#123; return (RegSingletonChild) RegSingleton.getInstance(\"com.singleton.RegSingletonChild\"); &#125;&#125; 3、登记式的单例模式解决了懒汉式和饿汉式不能继承的缺点，但是子类中的构造方法变为了public的，所以其他类可以直接通过构造方法创建类的实例而不用向父类中登记，这是登记式单例模式最大的缺点。 总结1、什么情况下使用单例模式？ 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。 在一个系统中要求一个类只有一个实例时才应当使用单例模式。 2、单例模式的优点和缺点？ 优点： 提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。 允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。 缺点： 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。 参考博客：https://www.kancloud.cn/digest/xing-designpattern/143725","comments":true,"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"设计模式-工厂模式","date":"2019-06-04T13:31:48.000Z","path":"2019/06/04/工厂设计模式/","text":"简单工厂模式、工厂模式、抽象工厂模式介绍。 About在面向对象编程中, 最通常的方法是一个new操作符产生一个对象实例，new操作符就是用来构造对象实例的。但是在一些情况下，new操作符直接生成对象会带来一些问题。举例来说, 许多类型对象的创造需要一系列的步骤: 你可能需要计算或取得对象的初始设置；选择生成哪个子对象实例；或在生成你需要的对象之前必须先生成一些辅助功能的对象。 在这些情况，新对象的建立就是一个 “过程”，不仅是一个操作，像一部大机器中的一个齿轮传动。 模式的问题：你如何能轻松方便地构造对象实例，而不必关心构造对象实例的细节和复杂过程呢？ 解决方案：建立一个工厂来创建对象。 简单工厂模式1、模式定义：简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式（同属于创建型模式的还有工厂方法模式，抽象工厂模式，单例模式，建造者模式）。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 2、模式结构： 3、简单工厂模式由三部分组成：具体工厂、具体产品和抽象产品。 工厂类（Creator）角色：担任这个角色的是简单工厂模式的核心，含有与应用紧密相关的商业逻辑。工厂类在客户端的直接调用下创建产品对象，它往往由一个具体Java类实现。 抽象产品（AbstractProduct）角色：担任这个角色的类是由简单工厂模式所创建的对象的父类，或它们共同拥有的接口。抽象产品角色可以用一个Java接口或者Java抽象类实现。 具体产品（ConcreteProduct）角色：简单工厂模式所创建的任何对象都是这个角色的实例，具体产品角色由一个具体Java类实现。 4、代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//1、创建了一个Car接口，作为所有汽车的父类，具体的实现由子类来实现。public interface Car &#123; void run(); void stop();&#125;//2、BMW实现类public class BMW implements Car &#123; @Override public void run() &#123; System.out.println(\"宝马启动了！\"); &#125; @Override public void stop() &#123; System.out.println(\"宝马熄火了！\"); &#125;&#125;//3、Benz实现类public class Benz implements Car &#123; @Override public void run() &#123; System.out.println(\"奔驰启动了！\"); &#125; @Override public void stop() &#123; System.out.println(\"奔驰熄火了！\"); &#125;&#125;//4、创建一个工厂类，这个工厂类专门负责建造各种汽车//里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。public class CarFactory &#123; public static Car createCar(String type) &#123; Car car = null; if(\"BMW\".equals(type)) &#123; car = new BMW(); &#125; else if(\"Benz\".equals(type)) &#123; car = new Benz(); &#125; else &#123; return null; &#125; return car; &#125; &#125;//5、客户端public class Client &#123; public static void main(String[] args) &#123; Car car = CarFactory.createCar(\"BMW\"); if(car != null) &#123; car.run(); car.stop(); &#125; else &#123; System.out.println(\"造不了车了！\"); &#125; &#125;&#125; 5、优点与缺点： 优点： 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 当需要引入新的产品是不需要修改客户端的代码，只需要添加相应的产品类并修改工厂类就可以了，所以说从产品的角度上简单工厂模式是符合“开-闭”原则的。 缺点： 由于工厂类集中了所有产品创建逻辑，工厂类一般被我们称作“全能类”或者“上帝类”，因为所有的产品创建他都能完成，这看似是好事，但仔细想想是有问题的。比如全国上下所有的事情都有国家主义一个人干会不会有问题，当然有！一旦不能正常工作，整个系统都要受到影响。 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。所以说从工厂的角度来说简单工厂模式是不符合“开-闭”原则的。 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 工厂方法模式1、模式定义：工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 2、模式结构： 3、工厂方法模式一共分为四个部分： 抽象工厂（AbstractCreator）角色：担任这个角色的是工厂方法模式的核心，它是与应用程序无关的。任何在模式中创建对象的工厂类必须继承或者实现这个接口，在实际的系统中，这个角色常常由Java抽象类来实现。 具体工厂（ConcreteCreator）角色：担任这个角色的是实现了抽象工厂接口的具体Java类。具体工厂角色含有与应用密切相关的逻辑，并且受到应用程序的调用以创建产品对象。 抽象产品（AbstractProduct）角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。在实际应用中这个角色常常由Java的抽象类来实现。 具体产品（ConcreteProduct）角色：这个角色实现了抽象产品角色所声明的接口，工厂方法所创建的每一个对象都是某个具体产品角色的实例。 4、代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//1、创建了一个Car接口，作为所有汽车的父类，具体的实现由子类来实现。public interface Car &#123; void run(); void stop();&#125;//2、BMW实现类public class BMW implements Car &#123; @Override public void run() &#123; System.out.println(\"宝马启动了！\"); &#125; @Override public void stop() &#123; System.out.println(\"宝马熄火了！\"); &#125;&#125;//3、Benz实现类public class Benz implements Car &#123; @Override public void run() &#123; System.out.println(\"奔驰启动了！\"); &#125; @Override public void stop() &#123; System.out.println(\"奔驰熄火了！\"); &#125;&#125;//4、定义一个CarFactory接口，定义方法createCar；用来告诉具体的工厂如何来创造汽车。public interface CarFactory &#123; Car createCar();&#125;//5、每一种车都配一个专门的生产工厂。public class BMWFactory implements CarFactory &#123; @Override public Car createCar() &#123; return new BMW(); &#125;&#125;public class BenzFactory implements CarFactory &#123; @Override public Car createCar() &#123; return new Benz(); &#125;&#125;//6、客户端，创建对应的工厂类，让特定的工厂来生产特定的汽车。public class Client &#123; public static void main(String[] args) &#123; // 先选择一个具体的工厂 CarFactory carFactory = new BMWFactory(); // 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象 Car car = carFactory.createCar(); car.run(); car.stop(); &#125;&#125; 5、优点与缺点： 优点： 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 缺点： 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 抽象工厂模式1、模式定义：抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 当涉及到产品族（代表了组成某个产品的一系列附件的集合）的时候，就需要引入抽象工厂模式了。 2、产品族： 当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。 模式结构： 3、抽象工厂方法模式一共分为四个部分： 抽象工厂（AbstractFactory）角色：担任这个角色的是抽象工厂模式的核心，是与应用系统的商业逻辑无关的。通常使用Java接口或者抽象Java类实现。所有的具体工厂必须实现这个Java接口或继承这个抽象的Java类。 具体工厂（Factory）角色：这个角色直接在客户端的调用下创建产品的实例，这个角色含有选择合适的产品对象的逻辑，而这个逻辑是与应用系统商业逻辑紧密相关的。 抽象产品（AbstractProduct）角色：担任这个角色的类是抽象工厂模式所创建的对象的父类，或它们共同拥有的接口。通常使用Java接口或者抽象Java类实现这一角色。 具体产品（Product）角色：抽象工厂模式所创建的任何产品对象都是一个具体的产品类的实例。这是客户端最终需要的东西，其内部一定充满了应用系统的商业逻辑。通常使用具体Java类实现这个角色。 与工厂方法模式不同的是，抽象工厂模式中的具体工厂不再是只能创建一种产品，一个具体的工厂可以创建一个产品族的产品。 4、代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//1、创建CPU和MainBoard接口public interface CPU &#123; void show();&#125;public interface MainBoard &#123; void show();&#125;//2public class AmdCPU implements CPU &#123; @Override public void show() &#123; System.out.println(\"AMD CPU!\"); &#125;&#125;public class AmdMainBoard implements MainBoard &#123; @Override public void show() &#123; System.out.println(\"AMD MainBoard!\"); &#125;&#125;public class InterCPU implements CPU &#123; @Override public void show() &#123; System.out.println(\"Intel CPU!\"); &#125;&#125;public class IntelMainBoard implements MainBoard &#123; @Override public void show() &#123; System.out.println(\"Intel MainBoard!\"); &#125;&#125;//3、创建电脑工厂接口public interface ComputerFactory &#123; CPU makeCPU(); MainBoard makeMainBoard();&#125;//4public class AmdFactory implements ComputerFactory &#123; @Override public CPU makeCPU() &#123; return new AmdCPU(); &#125; @Override public MainBoard makeMainBoard() &#123; return new AmdMainBoard(); &#125;&#125;public class IntelFactory implements ComputerFactory &#123; @Override public CPU makeCPU() &#123; return new InterCPU(); &#125; @Override public MainBoard makeMainBoard() &#123; return new IntelMainBoard(); &#125;&#125;//5、客户端/** * 对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等， * 直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。 * */public class Client &#123; public static void main(String[] args) &#123; // 第一步就要选定一个“大厂” ComputerFactory cf = new AmdFactory(); // 从这个大厂造 CPU CPU cpu = cf.makeCPU(); // 从这个大厂造主板 MainBoard mainBoard = cf.makeMainBoard(); cpu.show(); mainBoard.show(); &#125;&#125; 5、优点与缺点： 优点： 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点： 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。 参考博客： https://www.kancloud.cn/digest/xing-designpattern https://javadoop.com/post/design-pattern","comments":true,"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Java反射","date":"2019-06-03T11:41:46.000Z","path":"2019/06/03/Java反射/","text":"Java反射总结。 No reflection，No most frameworks. 什么是反射？反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。 通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。 反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 .class 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。 反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。 Java 反射主要提供以下功能： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）； 在运行时调用任意一个对象的方法。 动态编译可以最大程度地支持多态，而多态最大的意义在于降低类的耦合性，因此反射的优点就很明显了：解耦以及提高代码的灵活性。 反射的优点缺点： 优点：运行期类型的判断，动态类加载：提高代码灵活度； 缺点：性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多； 反射的应用： JDBC 的数据库的连接： ​ 通过Class.forName()加载数据库的驱动程序 （通过反射加载，前提是引入相关了Jar包）； Spring 框架的使用： ​ Java的反射机制在做基础框架的时候非常有用，行内有一句这样的老话：反射机制是Java框架的基石。一般应用层面很少用，不过这种东西，现在很多开源框架基本都已经封装好了，自己基本用不着写。典型的除了hibernate之外，还有spring也用到很多反射机制。最经典的就是xml的配置模式。 Spring 通过 XML 配置模式装载 Bean 的过程： 将程序内所有 XML 或 Properties 配置文件加载入内存中； Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息； 使用反射机制，根据这个字符串获得某个类的Class实例； 动态配置实例的属性； Spring这样做的好处是： 不用每一次都要在代码里面去new或者做其他的事情； 以后要改的话直接改配置文件，代码维护起来就很方便了； 有时为了适应某些需求，Java类里面不一定能直接调用另外的方法，可以通过反射机制来实现。 反射基本功能获取反射中的Class对象在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。获取 Class 类对象有三种方法： 使用 Class 类的 forName 静态方法：知道该类的全路径名； 1Class.forName(); 直接获取某一个对象的 class：适合在编译前就知道操作的 Class； 1类名.class; 使用类对象的 getClass() 方法。 12类名 对象名 = new 类名();Class c = 对象名.getClass(); 通过反射创建类对象通过反射创建类对象主要有两种方式： 通过 Class 对象的 newInstance() 方法； 12Class c = 类名.class;类名 对象名 = (类名)c.newInstance(); 通过 Constructor 对象的 newInstance() 方法。 123Class c = 类名.class;Constructor constructor = c.getConstructor();类名 对象名 = (类名)constructor.newInstance(); 通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。 123Class c = 类名.class;Constructor constructor = c.getConstructor(String.class, int.class);类名 对象名 = (类名)constructor.newInstance(\"xxx\", 15); 获取类属性方法及构造器1、通过 Class 对象的 getFields() 方法可以获取所有 public 访问权限的属性(包括本类声明的和从父类继承的)； 12345678910Class c = 类名.class;Field[] fields = c.getFields();//遍历属性并输出属性信息for(Field field : fields) &#123; //获取访问权限并输出 int modifiers = field.getModifiers(); System.out.print(Modifier.toString(modifiers) + \" \"); //输出属性的类型及属性名 System.out.println(field.getType().getName() + \" \" + field.getName());&#125; 2、通过 Class 对象的 getDeclaredFields() 方法则可以获取所有本类声明的(不管访问权限)属性； 12Class c = 类名.class;Field[] fields = c.getDeclaredFields(); 3、通过 Class 对象的 getMethods() 方法可以获取所有 public 访问权限的方法(包括本类声明的和从父类继承的)； 12345678910111213141516171819202122232425Class c = 类名.class;Method[] methods = c.getMethods();//遍历属性并输出属性信息for(Method method : methods) &#123; //获取并输出方法的访问权限（Modifiers：修饰符） int modifiers = method.getModifiers(); System.out.print(Modifier.toString(modifiers) + \" \"); //获取并输出方法的返回值类型 Class returnType = method.getReturnType(); System.out.println(returnType.getName() + \" \" + method.getName() + \"(\"); //获取并输出方法的所有参数 Parameter[] parameters = method.getParameters(); for(Parameter parameter : parameters) &#123; System.out.print(parameter.getType().getName() + \" \" + parameter.getName() + \",\"); &#125; //获取并输出方法抛出的异常 Class[] exceptionTypes = method.getExceptionTypes(); if(exceptionTypes.length == 0) &#123; System.out.println(\")\"); &#125; else &#123; for(Class cla: exceptionTypes) &#123; System.out.println(\") throws \" + cla.getName()); &#125; &#125;&#125; 4、通过 Class 对象的 getDeclaredMethods() 方法可以获取所有本类声明的(不管访问权限)方法； 12Class c = 类名.class;Method[] methods = c.getDeclaredMethods(); 5、通过 Class 对象的 getConstructors() 方法可以获取所有 public 访问权限的构造方法； 123456789101112Class c = 类名.classConstructor[] constructors = c.getConstructors();for(Constructor constructor : constructors) &#123; //获取并输出构造方法的访问权限（Modifiers：修饰符） int modifiers = constructor.getModifiers(); System.out.print(Modifier.toString(modifiers) + \" \"); //获取并输出构造方法的所有参数 Parameter[] parameters = constructor.getParameters(); for(Parameter parameter : parameters) &#123; System.out.print(parameter.getType().getName() + \" \" + parameter.getName() + \",\"); &#125;&#125; 6、通过 Class 对象的 getDeclaredConstructors() 方法可以获取所有本类声明的(不管访问权限)构造方法； 12Class c = 类名.classConstructor[] constructors = c.getDeclaredConstructors(); 访问或操作类的私有变量和方法1、访问类的私有方法： 123456789101112131415161718192021//1. 获取 Class 类实例类名 对象名 = new 类名();Class c = 对象名.getClass(); //2. 获取私有方法/** * 第一个参数为要获取的私有方法的名称 * 第二个为要获取方法的参数的类型，参数为 Class...，没有参数就是null * 方法参数也可这么写 ：new Class[]&#123;String.class , int.class&#125; */Method privateMethod = c.getDeclaredMethod(\"私有方法名\", String.class, int.class);//3. 开始操作方法if(privateMethod != null) &#123; //获取私有方法的访问权(只是获取访问权，并不是修改实际权限) privateMethod.setAccessible(true); /** * 使用 invoke 反射调用私有方法 * privateMethod 是获取到的私有方法 * 类对象 要操作的对象 * 后面两个参数传实参 */ privateMethod.invoke(类对象, \"Java Reflect\", 666); 2、修改类的私有变量： 12345678910111213141516171819 //1. 获取 Class 类实例类名 对象名 = new 类名();Class c = 对象名.getClass(); //2. 获取私有变量Field privateField = c.getDeclaredField(\"私有属性名\");//3. 操作私有变量if(privateField != null) &#123; //获取私有变量的访问权 privateField.setAccessible(true); //修改私有变量，并输出以测试 System.out.println(\"Before Modify：私有属性名 = \" + 对象名.getXXX()); /** * 调用 set(object , value) 修改变量的值 * privateField 是获取到的私有变量 * 对象名 要操作的对象 * \"Modified\" 为要修改成的值 */ privateField.set(对象名, \"Modified\"); System.out.println(\"After Modify：私有属性名 = \" + testClass.getXXX()); 3、修改类的私有常量： 常量是指使用 final 修饰符修饰的成员属性，与变量的区别就在于有无 final 关键字修饰。Java 虚拟机（JVM）在编译 .java 文件得到 .class 文件时，会优化我们的代码以提升效率。其中一个优化就是：JVM 在编译阶段会把引用常量的代码替换成具体的常量值，如下所示。 1234567891011121314//编译前的 .java 文件：//注意是 String 类型的值private final String FINAL_VALUE = \"hello\";if(FINAL_VALUE.equals(\"world\"))&#123; //do something&#125;//编译后得到的 .class 文件（当然，编译后是没有注释的）：private final String FINAL_VALUE = \"hello\";//替换为\"hello\"if(\"hello\".equals(\"world\"))&#123; //do something&#125; 但是，并不是所有常量都会优化。经测试对于 int 、long 、boolean 以及 String 这些基本类型 JVM 会优化，而对于 Integer 、Long 、Boolean 这种包装类型，或者其他诸如 Date 、Object 类型则不会被优化。总结：对于基本类型的静态常量，JVM 在编译阶段会把引用此常量的代码替换成具体的常量值。 通过反射修改类的常量： 1234567891011121314151617//1. 获取 Class 类实例类名 对象名 = new 类名();Class c = 对象名.getClass();//2. 获取私有常量Field finalField = c.getDeclaredField(\"私有常量名\");//3. 修改常量的值if(finalField != null) &#123; //获取私有常量的访问权 finalField.setAccessible(true); //调用 finalField 的 getter 方法,输出 FINAL_VALUE 修改前的值 System.out.println(\"Before Modf: 私有常量名 = \" + finalField.get(对象名)); //修改私有常量 finalField.set(对象名, \"Modified\"); //调用 finalField 的 getter 方法,输出 FINAL_VALUE 修改后的值 System.out.println(\"After Modify：私有常量名 = \" + finalField.get(对象名)); //使用对象调用类的 getter 方法,获取值并输出 System.out.println(\"Actually ：私有常量名 = \" + testClass.getXXX); 结果是： 第一句打印修改前的值，没有异议； 第二句打印修改后常量的值，说明确实通过反射修改了； 第三句打印通过 getXXX() 方法获取的常量值，但还是初始值，导致修改无效！ 如果非要修改，类中在声明常量时不赋值，然后添加构造函数并为其赋值，即可修改。 参考博客： https://juejin.im/post/598ea9116fb9a03c335a99a4#heading-7 https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html","comments":true,"tags":[{"name":"Java反射","slug":"Java反射","permalink":"http://yoursite.com/tags/Java反射/"}]},{"title":"JUnit介绍","date":"2019-06-03T11:17:28.000Z","path":"2019/06/03/JUnit介绍/","text":"JUnit用到的设计模式介绍。 keep the bar green to keep the code clean. About1、JUnit最初由Erich Gamma 和Kent Beck所开发，是一个开源的java测试框架，它是Xuint测试体系架构的一种实现。在JUnit单元测试框架的设计时，设定了三个总体目标： 简化测试的编写，这种简化包括测试框架的学习和实际测试单元的编写； 使测试单元保持持久性； 可以利用既有的测试来编写相关的测试。 2、Junit的设计思想是通过从零开始来应用设计模式，然后一个接一个，直至获得最终合适的系统架构。 3、junit：判断程序执行的结果是否和我们所期待的结果一致。 ​ 测试之前是什么状态，测试之后就应该是什么状态，而不应该由于测试执行的原因导致状态发生了变化。 设计模式1、Template Method（模板方法）：需要复用的是算法的结构，也就是步骤，而步骤的实现可以在子类中完成。 问题：在实际的测试中，为了测试业务逻辑，必须构造一些参数或者一些资源，然后才可进行测试，最后必须释放这些系统资源。如测试数据库应用时，必须创建数据库连接Connection，然后执行数据库的操作，最后实现释放数据库的连接。 模式的选择：接下来要解决的问题是给开发者一个便捷的“地方”，用于放置他们的初始化代码，测试代码，和释放资源的代码，类似对象的构造函数，业务方法，析构函数一样。并且必须保证每次运行测试代码之前，都运行初始化代码，最后运行释放资源代码，并且每一个测试的结果都不会影响到其它的测试结果。这样就达到了代码的复用，提供了开发人员的效率。 Template Method（模板方法）比较好地涉及到我们的问题。摘引其意图，“定义一个操作中算法的骨架，并将一些步骤延迟到子类中。Template Method使得子类能够不改变一个算法的结构便可重新定义该算法的某些特定步骤。”这完全恰当。这样可以使测试者能够分别来考虑如何编写初始化和释放代码，以及如何编写测试代码。不管怎样，这种执行的次序对于所有测试都将保持相同，而不管初始化代码如何编写，或测试代码如何编写。 组成： 父类角色：提供模板（抽象类）； 子类角色：为模板提供实现。 在JUnit中的应用：Before()，Test()，After()。 123456789101112131415161718// JUnit在TestCase类中应用了模板方法模式。//具体的模板方法，定义出逻辑骨架public void runBare() throws Throwable &#123; Throwable exception = null; setUp(); try &#123; runTest(); &#125; catch (Throwable running) &#123; exception = running; &#125; finally &#123; try &#123; tearDown(); &#125; catch (Throwable tearingDown) &#123; if (exception == null) exception = tearingDown; &#125; &#125; if (exception != null) throw exception;&#125; 效果： 在各个测试用例中的公共的行为（初始化信息和释放资源等）被提取出来，可以避免代码的重复，简化了开发人员的工作； 在TestCase中实现一个算法的不变部分，并且将可变的行为留给子类来实现。增强了系统的灵活性。使JUnit框架仅负责算法的轮廓和骨架，而测试的开发人员则负责给出这个算法的各个逻辑步骤。 2、Command（命令）模式。 问题：JUnit是一个测试framework，测试人员只需开发测试用例。然后把这些测试用例组成请求(有时可能是一个或者多个)，发送到JUnitFrameWork，然后由JUnit执行测试，最后报告详细测试结果。其中包括执行的时间，错误方法，错误位置等。这样测试用例的开发人员就不需知道JUnit内部的细节，只要符合它定义的请求格式即可。从JUnit的角度考虑，它并不需要知道请求TestCase的操作信息，仅把它当作一种命令来执行，然后把执行测试结果发给测试人员。这样就使JUnit 框架和TestCase的开发人员独立开来，使得请求的一方不必知道接收请求一方的详细信息，更不必知道是怎样被接收，以及怎样被执行的，实现系统的松耦合。 模式的选择：Command（命令）模式能够比较好地满足需求。摘引其意图，将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求进行排队或记录请求日志…Command告诉我们可以为一个操作生成一个对象并给出它的一个execute（执行）方法。 在JUnit中的应用。 12345678910111213141516171819202122232425//为了实现Command模式，首先定义了一个接口Test,其中Run便是Command的Execute方法。public interface Test &#123; /** * Counts the number of test cases that will be run by this test. */ public abstract int countTestCases(); /** * Runs a test and collects its result in a TestResult instance. */ public abstract void run(TestResult result);&#125;//TestCase是该接口的抽象实现，它增加了一个测试名称，因为每一个TestCase在创建时都要有一个名称，因此若一个测试失败了，你便可识别出是哪个测试失败。public abstract class TestCase extends Assert implements Test &#123; /** * the name of the test case */ private String fName; /** * Runs the test case and collects the results in TestResult. */ public void run(TestResult result) &#123; result.run(this); &#125;&#125; 效果： Command模式将实现请求的一方（TestCase开发）和调用一方（JUnit Fromwork）进行解藕； Command模式使新的TestCase很容易的加入，无需改变已有的类，只需继承TestCase类即可，这样方便了测试人员； Command模式可以将多个TestCase进行组合成一个复合命令，实际你将看到TestSuit就是它的复合命令，当然它使用了Composite模式； Command模式容易把请求的TestCase组合成请求队列，这样使接收请求的一方（Junit Fromwork）,容易的决定是否执行请求，或者一旦发现测试用例失败或者错误可以立刻停止进行报告。 3、Composite（组合）。 问题：通过我们使用Command模式，JUnit能够方便的运行一个单独的测试案例之后产生测试结果。可是在实际的测试过程中，需要把多个测试用例进行组合成为一个复合的测试用例，当作一个请求发送给JUnit。这样JUnit就为面临一个问题，必须考虑测试请求的类型，是一个单一的TestCase还是一个复合的TestCase，甚至于要区分到底有多少个TestCase。怎样设计JUnit才可以实现不需要区分单个TestCase还是复合TestCase，把它们统一成相同的请求？ 模式的选择：当测试调用者不必关心其运行的是一个或多个测试案例的请求时，能够轻松地解决这个问题模式就是Composite（组合）模式。摘引其意图，将对象组合成树形结构以表示部分-整体的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。在这里部分-整体的层次结构是解决问题的关键，可以把单个的TestCase看作部分，而把复合的TestCase(TestSuit)看作整体。这样我们使用该模式便可以恰到好处得解决这个难题。 组成： Component：这是一个抽象角色，它给参加组合的对象规定一个接口。这个角色，给出共有的接口和默认的行为。其实就我们的Test接口，它定义出run方法； Composite：实现共有接口并维护一个测试的集合。就是我们的复合TestCase，TestSuit； Leaf：代表参加组合的对象，它没有下级子对象，仅定义出参加组合的原始对象的行为，其实就是单一的测试用例TestCase，它仅实现Test接口的方法。 在JUnit中的应用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//composite模式中的Component角色public interface Test &#123; public abstract int countTestCases(); public abstract void run(TestResult result);&#125;//composite模式中的Leaf角色public abstract class TestCase extends Assert implements Test &#123; /** * Runs the test case and collects the results in TestResult. */ public void run(TestResult result) &#123; result.run(this); &#125;&#125;/***下面，列出Composite源码。将其取名为TestSuit类。TestSuit有一个属性fTests (Vector类型)中保存了*其子测试用例（child test），提供addTest方法来实现增加子对象TestCase ,并且还提供testCount 和*tests等方法来操作子对象。最后通过run()方法实现对其子对象进行委托（delegate），最后还提供*addTestSuite方法实现递归，构造成树形。*/public class TestSuite implements Test &#123; private Vector&lt;Test&gt; fTests = new Vector&lt;Test&gt;(10); public void addTest(Test test) &#123; fTests.add(test); &#125; public int testCount() &#123; return fTests.size(); &#125; public Enumeration&lt;Test&gt; tests() &#123; return fTests.elements(); &#125; /** * Runs the tests and collects their result in a TestResult. */ public void run(TestResult result) &#123; for (Test each : fTests) &#123; if (result.shouldStop()) &#123; break; &#125; runTest(each, result); &#125; &#125; /** * Adds the tests from the given class to the suite */ public void addTestSuite(Class&lt;? extends TestCase&gt; testClass) &#123; addTest(new TestSuite(testClass)); &#125;&#125;/***所有上面的代码是对Test接口进行实现的。由于TestCase和TestSuit两者都符合Test接口，我们可以通过*addTestSuite递归地将TestSuite再组合成TestSuite，这样将构成树形结构。所有开发者都能够创建他们自*己的TestSuit。测试人员可创建一个组合了这些套件的TestSuit来运行它们所有的TestCase。*/ 效果： 简化了JUnit的代码JUnit可以统一处理组合结构TestSuite和单个对象TestCase。使JUnit开发变得简单容易，因为不需要区分部分和整体的区别，不需要写一些充斥着if else的选择语句； 定义了TestCase对象和TestSuite的类层次结构 基本对象TestCase可以被组合成更复杂的组合对象TestSuite，而这些组合对象又可以被组合，这样不断地递归下去。客户代码中，任何使用基本对象的地方都方便的使用组合对象，大大简化系统维护和开发； 使得更容易增加新的类型的TestCase。 4、dapter（适配器）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 问题：如果实现一个测试用例，就必须实现继承Testcase，然后实现run方法，实际是（testRun），然而这样我们就把所有的测试用例都实现相同类的不同方法，这样的结果就会造成产生大量的子类，使系统的测试维护相当困难，并且setUp和tearDown仅为这个testRun服务，其他的测试也必须完成相应的代码，从而增加了开发人员的工作量，怎样解决这个问题？ 为了避免类的急剧扩散，试想一个给定的测试用例类（testcase class）可以实现许多不同的方法，每一个方法都有一个描述性的名称，如testMoneyEquals或testMoneyAdd。这样测试案例并不符合简单的command接口。因此又带来另外一个问题就是，使所有测试方法从测试调用者的角度（JUnit框架）上看都是相同的。怎样解决这个问题？ 模式的选择：Adapter具有以下意图“将一个类的接口转换成客户希望的另外一个接口”。这听起来非常适合。把具有一定规则的描述性方法如testMoneyEquals，转化为JUnit框架所期望的Command（TestCase的run）从而方便框架执行测试。Adapter模式又分为类适配器和对象适配器。类适配器是静态的实现在这里不适合使用，于是使用了对象适配器。 组成： 目标抽象角色（Target）：定义客户要用的特定领域的接口； 适配器（Adapter）-中介：调用另一个接口，作为一个转换器； 适配器（Adaptee）：定义一个接口，Adapter需要接入； 客户端（Client）：协同对象符合Adapter适配器。 在JUnit中的应用：testXXX()。 1234567891011121314151617181920212223242526//junit在TestCase类中应用了适配器模式protected void runTest() throws Throwable &#123; assertNotNull(\"TestCase.fName cannot be null\", fName); // Some VMs crash when calling getMethod(null,null); Method runMethod = null; try &#123; // use getMethod to get all public inherited // methods. getDeclaredMethods returns all // methods of this class but excludes the // inherited ones. runMethod = getClass().getMethod(fName, (Class[]) null); &#125; catch (NoSuchMethodException e) &#123; fail(\"Method \\\"\" + fName + \"\\\" not found\"); &#125; if (!Modifier.isPublic(runMethod.getModifiers())) &#123; fail(\"Method \\\"\" + fName + \"\\\" should be public\"); &#125; try &#123; runMethod.invoke(this); &#125; catch (InvocationTargetException e) &#123; e.fillInStackTrace(); throw e.getTargetException(); &#125; catch (IllegalAccessException e) &#123; e.fillInStackTrace(); throw e; &#125;&#125; 在runBare方法中，通过runTest方法将我们自己编写的testXXX方法进行了适配，使得junit可以执行我们自己编写的Test Case。 在runTest方法中，首先获得我们自己编写的testXXX方法所对应的Method对象（不带参数），然后检查该Method所对应的方法是否是Public的，如果是则调用Method对象的invoke方法来去执行我们自己编写的testXXX方法。 效果： 使用Adapter模式简化测试用例的开发，通过按照方法命名的规范来开发测试，不需要进行大量的类继承，提高代码的复用，减轻测试人员的工作量； 使用Adapter可以重新定义Adaptee的部分行为，如增强异常处理等。 参考博客：http://www.voidcn.com/article/p-uxchkbof-ez.html","comments":true,"tags":[{"name":"Java单元测试框架","slug":"Java单元测试框架","permalink":"http://yoursite.com/tags/Java单元测试框架/"}]},{"title":"排序算法（二）","date":"2019-06-02T10:48:51.000Z","path":"2019/06/02/SortAlgorithm/","text":"排序算法（快速排序、希尔排序、堆排序、归并排序）的Java实现。 快速排序About快速排序是一种交换排序 。 思想通过一趟排序将要排序的数据分割成独立的两部分：分割点左边都是比它小的数，右边都是比它大的数。 然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 动态效果 Java实现123456789101112131415161718192021222324252627282930313233343536import java.util.Arrays;public class QuickSort &#123; public static void sort(int[] arr, int left, int right) &#123; if(left &gt; right) &#123; return; &#125; else &#123; int base = divide(arr, left, right); sort(arr, left, base - 1); sort(arr, base + 1, right); &#125; &#125; public static int divide(int[] arr, int left, int right) &#123;//重新找基准数 int base = arr[left]; //以最左边的数（left）为基准 while (left &lt; right) &#123; while (left &lt; right &amp;&amp; arr[right] &gt;= base) &#123;// 从数组右端开始，向左遍历，直到找到小于base的数 right--; &#125; arr[left] = arr[right];// 找到了比base小的元素，将这个元素放到最左边的位置 while (left &lt; right &amp;&amp; arr[left] &lt;= base) &#123;// 从数组左端开始，向右遍历，直到找到大于base的数 left++; &#125; arr[right] = arr[left];// 找到了比base大的元素，将这个元素放到最右边的位置 &#125; // 最后将base放到left位置。此时，left位置的左侧数值应该都比left小,而left位置的右侧数值应该都比left大。 arr[left] = base; return left; &#125; public static void main(String[] args) &#123; int[] n = &#123;6, 4, 8, 9, 2, 3, 1&#125;; QuickSort.sort(n, 0, 6); System.out.println(Arrays.toString(n)); &#125;&#125; 算法分析 希尔排序About希尔(Shell)排序又称为缩小增量排序，它是一种插入排序。它是直接插入排序算法的一种威力加强版。 思想步长的选择是希尔排序的重要部分。算法最开始以一定的步长进行排序，然后会继续以更小的步长进行排序，最终算法以步长为 1 进行排序。当步长为 1 时，算法变为直接插入排序，这就保证了数据一定会被全部排序。 图示效果 Java实现12345678910111213141516171819202122232425import java.util.Arrays;public class ShellSort &#123; public static void sort(int[] arr) &#123; int increment = arr.length / 2; while (increment &gt; 0) &#123; for(int i = increment; i &lt; arr.length; i++) &#123; int j = i - increment; int temp = arr[i]; while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) &#123; arr[j + increment] = arr[j]; j -= increment; &#125; arr[j + increment] = temp; &#125; increment /= 2; &#125; &#125; public static void main(String[] args) &#123; int[] n = &#123;50, 123, 543, 187, 49, 30, 0, 2, 11, 100&#125;; sort(n); System.out.println(Arrays.toString(n)); &#125;&#125; 算法分析 堆排序About堆排序是一种选择排序。 思想堆是一种特殊的树形数据结构，其每个节点都有一个值，通常提到的堆都是指一颗完全二叉树，根结点的值小于（或大于）两个子节点的值，同时，根节点的两个子树也分别是一个堆。 堆排序是利用堆的性质进行的一种选择排序。 图示效果构建初始堆：构造了初始堆后，堆排序处理： Java实现123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Arrays;public class HeadSort &#123; public static void buildHeap(int[] arr, int parent, int length) &#123; for(int child = 2 * parent + 1; child &lt; length; child = 2 * child + 1) &#123; if(child + 1 &lt; length &amp;&amp; arr[child] &lt; arr[child + 1]) &#123;// 让child先指向子节点中最大的节点 child++; &#125; if(arr[parent] &lt; arr[child]) &#123;// 如果发现子节点更大，则进行值的交换 swap(arr, parent, child); // 下面就是非常关键的一步了 // 如果子节点更换了，那么，以子节点为根的子树会不会受到影响呢？ // 所以，循环对子节点所在的树继续进行判断 parent = child; &#125; else &#123; break; &#125; &#125; &#125; public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; public static void sort(int[] arr)&#123; for(int parent = arr.length / 2 - 1; parent &gt;= 0; parent--) &#123;//构建最大堆 buildHeap(arr, parent, arr.length); &#125; for(int i = arr.length - 1; i &gt; 0; i--) &#123;//把最大的元素扔在最后面 swap(arr, 0, i); buildHeap(arr, 0, i);//将arr中前i - 1个记录重新调整为最大堆 &#125; &#125; public static void main(String[] args) &#123; int a[] = &#123;6, 4, 8, 9, 2, 3, 1&#125;; sort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 算法分析 归并排序About归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 思想该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 图示效果 分阶段： 治阶段： Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Arrays;public class MergeSort &#123; public static void sort(int[] arr, int low, int high) &#123; int mid = (low + high) / 2; if(low &lt; high) &#123; sort(arr, low, mid);//左 sort(arr, mid + 1, high);//右 merge(arr, low, mid, high);//左右归并 &#125; &#125; public static void merge(int[] arr, int low, int mid, int high) &#123; int[] temp = new int[high - low + 1]; int i = low;//左指针 int j = mid + 1;//右指针 int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= high) &#123;// 把较小的数先移到新数组中 if(arr[i] &lt; arr[j]) &#123; temp[k++] = arr[i++]; &#125; else &#123; temp[k++] = arr[j++]; &#125; &#125; // 把左边剩余的数移入数组 while (i &lt;= mid) &#123; temp[k++] = arr[i++]; &#125; // 把右边剩余的数移入数组 while (j &lt;= high) &#123; temp[k++] = arr[j++]; &#125; // 新数组中的数覆盖arr数组 k = 0; while (low &lt;= high) &#123; arr[low++] = temp[k++]; &#125; &#125; public static void main(String[] args) &#123; int arr[] = &#123;6, 4, 8, 9, 2, 3, 1&#125;; sort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); &#125;&#125; 算法分析 参考博客： https://cuijiahua.com/blog/2018/01/alogrithm_9.html https://blog.csdn.net/jianyuerensheng/article/category/6203559","comments":true,"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://yoursite.com/tags/排序算法/"}]},{"title":"排序算法（一）","date":"2019-05-31T06:27:07.000Z","path":"2019/05/31/排序算法/","text":"排序算法（冒泡排序、直接插入排序、选择排序）的Java实现。 排序分类 算法分析 冒泡排序About冒泡排序是一种交换排序，两两比较待排序的关键字，并交换不满足次序要求的那对数，直到整个数组都满足次序要求为止。 思想它重复地走访要排序的数组，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数组的工作是重复地进行直到没有再需要交换，也就是说该数组已经排序完成。 这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数组的顶端，故名冒泡排序。 动态效果 Java实现12345678910111213141516171819202122232425import java.util.Arrays;public class bubbleSort &#123; //大的往后调 public static void sort(int[] num) &#123; if(num == null || num.length == 0) &#123; return; &#125; for(int i = 0; i &lt; num.length - 1; i++) &#123; for(int j = 0; j &lt; num.length - i - 1; j++) &#123; if(num[j] &gt; num[j + 1]) &#123; int temp = num[j]; num[j] = num[j + 1]; num[j + 1] = temp; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] n = &#123;6, 4, 8, 9, 2, 3, 1&#125;; bubbleSort.sort(n); System.out.println(Arrays.toString(n)); &#125;&#125; 优化当冒泡中途发现已经为正序了，便无需继续比对下去。 改进：12345678910111213141516171819202122232425262728293031import java.util.Arrays;public class bubbleSortOptimize &#123; //对冒泡排序常见的改进方法是加入标志性变量，用于标志某一趟排序过程中是否有数据交换。 public static void sort(int[] num) &#123; if(num == null || num.length == 0) &#123; return; &#125; boolean flag; for(int i = 0; i &lt; num.length; i++) &#123; flag = false; for(int j = 0; j &lt; num.length - 1 - i; j++) &#123; if(num[j] &gt; num[j + 1]) &#123; int temp = num[j]; num[j] = num[j + 1]; num[j + 1] = temp; flag = true; &#125; &#125; if(flag == false) &#123; break; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] n = &#123;6, 4, 8, 9, 2, 3, 1&#125;; bubbleSortOptimize.sort(n); System.out.println(Arrays.toString(n)); &#125;&#125; 算法分析 直接插入排序About直接插入排序（Insertion Sort）是一种最简单的插入排序。 思想每一趟将一个待排序的记录，按照其关键字的大小插入到有序队列的合适位置里，直到全部插入完成。 动态效果 Java实现123456789101112131415161718192021222324import java.util.Arrays;public class InsertSort &#123; public static void sort(int[] arr) &#123; //第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列 for(int i = 1; i &lt; arr.length; i++) &#123; //取出第i个数，和前i-1个数比较，插入合适位置 int temp = arr[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) &#123;//如果要插入的数小于第j个数，将第j个数后移 arr[j + 1] = arr[j]; j--; &#125; arr[j + 1] = temp; &#125; &#125; public static void main(String[] args) &#123; int[] n = &#123;6, 4, 8, 9, 2, 3, 1&#125;; InsertSort.sort(n); System.out.println(Arrays.toString(n)); &#125;&#125; 注意：此处第二个循环不可替换为for循环，否则会出现逻辑❌。如果替换为for循环，变量变化得写在大括号里。 算法分析 选择排序About每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列头部，直到全部排序结束为止。 思想 从待排序序列中，找到关键字最小的元素； 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换； 从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。 动态效果 Java实现12345678910111213141516171819202122import java.util.Arrays;public class SelectSort &#123; //每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列头部，直到全部排序结束为止。 public static void sort(int[] arr) &#123; for(int i = 0; i &lt; arr.length - 1; i++) &#123; for(int j = i + 1; j &lt; arr.length; j++) &#123; if(arr[i] &gt; arr[j]) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] n = &#123;6, 4, 8, 9, 2, 3, 1&#125;; SelectSort.sort(n); System.out.println(Arrays.toString(n)); &#125;&#125; 算法分析 参考博客：https://cuijiahua.com/blog/2018/01/alogrithm_9.html","comments":true,"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://yoursite.com/tags/排序算法/"}]},{"title":"测试基础理论（二）","date":"2019-04-27T09:42:02.000Z","path":"2019/04/27/软件测试实例/","text":"软件测试实例分析 1、给你一个字符串，你怎么判断是不是ip地址？ ​ IP的格式：(1~255).(0~255).(0~255).(0~255) 123456789101112131415161718192021222324public class IpLegal &#123; //正则表达式 public static boolean isIpLegal(String ipStr) &#123; String ipRegEx = \"^([1-9]|([1-9][0-9])|(1[0-9][0-9])|(2[0-4][0-9])|(25[0-5]))\" + \"(\\\\.([0-9]|([1-9][0-9])|(1[0-9][0-9])|(2[0-4][0-9])|(25[0-5])))&#123;3&#125;$\"; Pattern pattern = Pattern.compile(ipRegEx); Matcher matcher = pattern.matcher(ipStr); if (matcher.matches()) &#123; return true; &#125; else &#123; return false; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); String ipStr = scanner.next(); boolean ipLegal = isIpLegal(ipStr); if(ipLegal) &#123; System.out.println(ipStr + \"合法\"); &#125; else &#123; System.out.println(ipStr + \"非法\"); &#125; &#125;&#125; 2、进行测试用例设计：一串数字，闰年的判别？ 判断闰年的标准是:能整除4且不能整除100，能整除400。设定合法的年份为1-9999 1234567891011121314public class LeapYear &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int year = in.nextInt(); if(year &lt;= 0 &amp;&amp; year &gt; 9999) &#123; System.out.println(\"请输入正确的年份\"); &#125; if((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0) &#123; System.out.println(\"闰年\"); &#125; else &#123; System.out.println(\"不是闰年\"); &#125; &#125;&#125; 测试用例： 3、请说一说简单用户界面登录过程都需要做哪些分析？ 4、对朋友圈点赞功能进行测试？ 是否可以正常点赞和取消； 点赞的人是否在可见分组里； 点赞状态是否能即时更新显示； 点赞状态，共同好友是否可见； 性能检测，网速快慢对其影响； 点赞显示的是否正确，一行几个； 点赞是否按时间进行排序，头像对应的是否正确； 是否能在消息列表中显示点赞人的昵称； 不同手机，系统显示界面如何； 可扩展性测试，点赞后是否能发表评论； 是否在未登录时可查看被点赞的信息。 5、如果做一个杯子的检测，如何测试？ 6、如何对一个页面进行测试？ UI测试：页面布局、页面样式检查、控件长度是否够长；显示时，是否会被截断；支持的快捷键，Tab键切换焦点顺序正确性等； 功能测试：页面上各类控件的测试范围，测试点。结合控件的实际作用来补充检查点： 比如， 密码框是否*显示， 输入是否做trim处理等； 安全测试：输入特殊字符，sql注入，脚本注入测试。后台验证测试，对于较重要的表单 ，绕过js检验后台是否验证；数据传输是否加密处理，比如， 直接请求转发，地址栏直接显示发送字符串； 兼容性测试； 性能测试。 7、 如何对淘宝搜索框进行测试？ 8、如何对一瓶矿泉水进行测试？ 界面测试:查看外观是否美观； 功能：查看水瓶漏不漏；瓶中水能不能被喝到； 安全性：瓶子的材质有没有毒或细菌； 可靠性：从不同高度落下的损坏程度； 可移植性：再不同的地方、温度等环境下是否都可以正常使用； 兼容性：是否能够容纳果汁、白水、酒精、汽油等； 易用性：是否烫手、是否有防滑措施、是否方便饮用； 用户文档：使用手册是否对的用法、限制、使用条件等有详细描述； 疲劳测试：将盛上水（案例一）放24小时检查泄漏时间和情况；盛上汽油（案例二）放24小时检查泄漏时间和情况等； 压力测试：用根针并在针上面不断加重量，看压强多大时会穿透； 跌落测试:测试在何种高度跌落会破坏水瓶。 9、请说一下购物车的测试用例？ 10、请问web测试如何写的？ 功能测试，主要做链接测试，表单测试，cookies测试，设计语言测试等； 性能测试，考虑连接速度测试，以及负载测试，例如：Web应用系统能允许多少个用户同时在线？如果超过了这个数量，会出现什么现象？Web应用系统能否处理大量用户对同一个页面的请求？还有压力测试； 可用性测试，比如导航测试，图形测试，内容测试，整体界面测试等； 兼容性测试，市场上有很多不同的操作系统类型，最常见的有Windows、Unix、Macintosh、Linux等。Web应用系统的最终用户究竟使用哪一种操作系统，取决于用户系统的配置。这样，就可能会发生兼容性问题，同一个应用可能在某些操作系统下能正常运行，但在另外的操作系统下可能会运行失败。因此，在Web系统发布之前，需要在各种操作系统下对Web系统进行兼容性测试； 安全性测试； 11、如何测试手机开机键？ 功能测试：按下开机键，屏幕能否亮起； 性能测试：按下开机键，屏幕能否在规定时间内亮起； 压力测试：连续多次按下开机键，观察屏幕是否能一直亮起，到多久时间失灵； 健壮性测试：给定一个中了病毒的手机或者是淘汰许久的老机子，安歇开机键观察屏幕能否亮起； 可靠性测试：连续按下开机键有限次数，比如1万次，记录屏幕未亮起的次数； 可用性测试：开机键按下费不费力，开机键的形状设计是否贴合手指，开机键的位置设计是否方便。 12、接口测试出现bug的原因有哪些？ 特殊值处理不当导致程序异常退出或者崩溃； 类型边界溢出，导致数据独处和写入不一致； 取值边界外未返回正确的错误信息； 权限未处理，可以访问其他用户的信息； 逻辑校验不完善，可以利用漏洞获取非正当利益； 状态处理不当，导致逻辑出现错误； 数组类型item个数为0或者item重复时程序异常退出。 13、请你设计一个微信朋友圈点赞的测试用例？ 功能测试：点赞某条朋友圈，验证是否成功； 接口测试：点赞朋友圈，验证朋友能否收到提示信息； 性能测试：点赞朋友圈，是否在规定时间显示结果，是否在规定时间在朋友手机上进行提示； 兼容性测试：在不同的终端比如ipad,手机上点赞朋友圈，验证是否成功。","comments":true,"tags":[{"name":"测试基础知识","slug":"测试基础知识","permalink":"http://yoursite.com/tags/测试基础知识/"}]},{"title":"测试基础理论（一）","date":"2019-04-26T02:20:40.000Z","path":"2019/04/26/测试基础理论/","text":"软件测试基础知识 1、单元测试、集成测试、系统测试、回归测试、验收测试介绍： 单元测试：完成最小的软件设计单元（模块）的验证工作，目标是确保模块被正确的编码，使用过程设计描述作为指南，对重要的控制路径进行测试以发现模块内的错误，通常情况下是白盒的，对代码风格和规则、程序设计和结构、业务逻辑等进行静态测试，及早的发现和解决不易显现的错误。 集成测试：通过测试发现与模块接口有关的问题。目标是把通过了单元测试的模块拿来，构造一个在设计中所描述的程序结构，应当避免一次性的集成（除非软件规模很小），而采用增量集成。 自顶向下集成：模块集成的顺序是首先集成主模块，然后按照控制层次结构向下进行集成，隶属于主模块的模块按照深度优先或广度优先的方式集成到整个结构中去。 自底向上集成：从原子模块开始来进行构造和测试，因为模块是自底向上集成的，进行时要求所有隶属于某个给顶层次的模块总是存在的，也不再有使用稳定测试桩的必要。 系统测试：是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件。系统测试是针对整个产品系统进行的测试，目的是验证系统是否满足了需求规格的定义，找出与需求规格不相符合或与之矛盾的地方。系统测试的对象不仅仅包括需要测试的产品系统的软件，还要包含软件所依赖的硬件、外设甚至包括某些数据、某些支持软件及其接口等。因此，必须将系统中的软件与各种依赖的资源结合起来，在系统实际运行环境下来进行测试。 回归测试：回归测试是指在发生修改之后重新测试先前的测试用例以保证修改的正确性。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。根据修复好了的缺陷再重新进行测试。回归测试的目的在于验证以前出现过但已经修复好的缺陷不再重新出现。一般指对某已知修正的缺陷再次围绕它原来出现时的步骤重新测试。 验收测试：验收测试是指系统开发生命周期方法论的一个阶段，这时相关的用户或独立测试人员根据测试计划和结果对系统进行测试和接收。它让系统用户决定是否接收系统。它是一项确定产品是否能够满足合同或用户所规定需求的测试。验收测试包括Alpha测试和Beta测试。 Alpha测试：是由用户在开发者的场所来进行的，在一个受控的环境中进行。 Beta测试：由软件的最终用户在一个或多个用户场所来进行的，开发者通常不在现场，用户记录测试中遇到的问题并报告给开发者，开发者对系统进行最后的修改，并开始准备发布最终的软件。 2、单元测试、集成测试、系统测试、验收测试、回归测试这几步中最重要的是哪一步？ ​ 这些测试步骤分别在软件开发的不同阶段对软件进行测试，对软件完整功能进行测试的系统测试很重要，因为此时单元测试和集成测试已完成，能够对软件所有功能进行功能测试，能够覆盖系统所有联合的部件，是针对整个产品系统进行的测试，能够验证系统是否满足了需求规格的定义，因此系统测试很重要。 3、集成测试和系统测试的区别，以及它们的应用场景主要是什么？ 区别： 计划和用例编制的先后顺序：从V模型来讲，在需求阶段就要制定系统测试计划和用例，HLD的时候做集成测试计划和用例，有些公司的具体实践不一样，但是顺序肯定是先做系统测试计划用例，再做集成。 用例的粒度：系统测试用例相对很接近用户接受测试用例，集成测试用例比系统测试用例更详细，而且对于接口部分要重点写，毕竟要集成各个模块或者子系统。 执行测试的顺序：先执行集成测试，待集成测试出的问题修复之后，再做系统测试。 应用场景： 集成测试：完成单元测试后，各模块联调测试；集中在各模块的接口是否一致、各模块间的数据流和控制流是否按照设计实现其功能、以及结果的正确性验证等等；可以是整个产品的集成测试，也可以是大模块的集成测试；集成测试主要是针对程序内部结构进行测试，特别是对程序之间的接口进行测试。集成测试对测试人员的编写脚本能力要求比较高。测试方法一般选用黑盒测试和白盒测试相结合。 系统测试：针对整个产品的全面测试，既包含各模块的验证性测试（验证前两个阶段测试的正确性）和功能性（产品提交个用户的功能）测试，又包括对整个产品的健壮性、安全性、可维护性及各种性能参数的测试。系统测试测试软件《需求规格说明书》中提到的功能是否有遗漏，是否正确的实现。做系统测试要严格按照《需求规格说明书》，以它为标准。测试方法一般都使用黑盒测试法。 4、黑盒测试与白盒测试： 黑盒测试也称功能测试或数据驱动测试，是在已知产品所应具有的功能，通过测试来检测每个功能是否都能正常使用，在测试时，把程序看作一个不能打开的黑盆子，在完全不考虑程序内部结构和内部特性的情况下，测试者在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数锯而产生正确的输出信息，并且保持外部信息（如数据库或文件）的完整性。 “黑盒”法着眼于程序外部结构、不考虑内部逻辑结构、针对软件界面和软件功能进行测试； “黑盒”法是穷举输入测试，只有把所有可能的输入都作为测试情况使用，才能以这种方法查出程序中所有的错误； 实际上测试情况有无穷多个，因此不仅要测试所有合法的输入，而且还要对那些不合法但是可能的输入进行测试。 白盒测试也称为结构测试或逻辑驱动测试，根据程序的控制结构设计测试用例，主要用于软件或程序验证。白盒测试法检查程序内部逻辑结构，对所有的逻辑路径进行测试，是一种穷举路径的测试方法，但即使每条路径都测试过了，但仍然有可能存在错误：穷举路径测试无法检查出程序本身是否违反了设计规范、穷举路径测试不可能检查出程序因为遗漏路径而出错、穷举路径测试不可能检查出程序因为遗漏路径而出错。 5、手动测试与自动化测试： 手工测试 ： 优点：测试人员具有经验和对错误的猜测能力、测试人员具有审美能力和心理体验、测试人员具有是非判断和逻辑推理能力。 缺点：重复的手工回归测试，代价昂贵、容易出错；依赖于软件测试人员的能力。 自动化测试： 优点：对程序的回归测试更方便、可以运行更多更繁琐的测试、可以执行一些手工测试困难或不可能进行的测试、更好地利用资源、测试具有一致性和可重复性。 缺点：不能取代手工测试、手工测试比自动测试发现的缺陷更多、对测试质量的依赖性极大、测试自动化不能提高有效性、工具本身并无想像力。 6、测试和开发需要怎么结合才能使软件的质量得到更好的保障？ ​ 测试和开发应该按照W模型的方式进行结合，测试和开发同步进行，能够尽早发现软件缺陷，降低软件开发的成本。W模型强调：测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、设计等同样要测试，也就是说，测试与开发是同步进行的。W模型有利于尽早地全面的发现问题。例如，需求分析完成后，测试人员就应该参与到对需求的验证和确认活动中，以尽早地找出缺陷所在。同时，对需求的测试也有利于及时了解项目难度和测试风险，及早制定应对措施，这将显著减少总体测试时间，加快项目进度。 7、测试的相关流程：需求测试-&gt;概要设计测试-&gt;详细设计测试-&gt;单元测试-&gt;集成测试-&gt;系统测试-&gt;验收测试。 8、如何写测试用例？ 测试人员尽早介入，彻底理解清楚需求，这个是写好测试用例的基础； 清楚输入、输出的各种可能性，以及各种输入的之间的关联关系，理解清楚需求的执行逻辑，通过等价类、边界值、判定表等方法找出大部分用例； 找到需求相关的一些特性，补充测试用例； 根据自己的经验分析遗漏的测试场景； 多总结类似功能点的测试点，才能够写出质量越来越高的测试用例。 9、测试项目具体工作是什么？ 搭建测试环境 撰写测试用例 执行测试用例 写测试计划，测试报告 测试，并提交BUG表单 跟踪bug修改情况 执行自动化测试，编写脚本，执行，分析，报告 进行性能测试，压力测试等其他测试，执行，分析，调优，报告 10、如果想进行bug的测评，怎么去评测bug？ Bug的priority（）和severity（）是两个重要属性，通常人员在提交bug的时候，只定义severity，而将priority交给leader定义，通常bug管理中，severity分为四个等级blocker、critical、major、minor/trivial，而priority分为五个等级immediate、urgent、high、normal、low。 Severity： blocker：即系统无法执行，崩溃，或严重资源不足，应用模块无法启动或异常退出，无法测试，造成系统不稳定。常见的有严重花屏、内存泄漏、用户数据丢失或破坏、系统崩溃/死机/冻结、模块无法启动或异常退出、严重的数值计算错误、功能设计与需求严重不符、其它导致无法测试的错误， 如服务器500错误。 critical：即映像系统功能或操作，主要功能存在严重缺陷，但不会映像到系统稳定性。常见的有：功能未实现，功能错误、系统刷新错误、数据通讯错误、轻微的数值计算错误、影响功能及界面的错误字或拼写错误。 major：即界面、性能缺陷、兼容性，常见的有：操作界面错误，边界条件错误，提示信息错误，长时间操作无进度提示，系统未优化，兼容性问题。 minor/trivial：即易用性及建议性问题。 Priority immediate：即马上解决 urgent：急需解决 high：高度重视，有时间要马上解决 normal：正常处理” low：在系统发布前解决，或确认可以不用解决 11、app性能测试的指标？ 内存：内存消耗测试节点的设计目标是为了让应用不占用过多的系统资源，且及时释放内存，保障整个系统的稳定性。当然关于内存测试，在这里我们需要引入几个概念：空闲状态、中等规格、满规格。空闲状态指打开应用后，点击home键让应用后台运行，此时应用处于的状态叫做空闲；中等规格和满规格指的是对应用的操作时间的间隔长短不一，中等规格时间较长，满规格时间较短。 CPU： 使用Android提供的view plaincopy在CODE上查看代码片派生到我的代码片 adbshell dumpsys CPUinfo |grep packagename &gt;/address/CPU.txt来获取； 使用top命令view plaincopy在CODE上查看代码片派生到我的代码片 adbshell top |grep packagename&gt;/address/CPU.txt来获取。 流量： 网络流量测试是针对大部分应用而言的，可能还有部分应用会关注网速、弱网之类的测试。 流量测试包括以下测试项：应用首次启动流量提示、应用后台连续运行2小时的流量值、应用高负荷运行的流量峰值。 电量： 测试手机安装目标APK前后待机功耗无明显差异； 常见使用场景中能够正常进入待机，待机电流在正常范围内； 长时间连续使用应用无异常耗电现象。 启动速度： 第一类：首次启动–应用首次启动所花费的时间； 第二类：非首次启动–应用非首次启动所花费的时间； 第三类：应用界面切换–应用界面内切换所花费的时间。 滑动速度、界面切换速度 与服务器交互的网络速度 12、bug的周期，以及描述一下不同类别的bug？ New:（新的） 当某个“bug”被第一次发现的时候，测试人员需要与项目负责人沟通以确认发现的的确是一个bug，如果被确认是一个bug，就将其记录下来，并将bug的状态设为New Assigned（已指派的） 当一个bug被指认为New之后，将其反馈给开发人员，开发人员将确认这是否是一个bug，如果是，开发组的负责人就将这个bug指定给某位开发人员处理，并将bug的状态设定为“Assigned” Open（打开的） 一旦开发人员开始处理bug的时候，他（她）就将这个bug的状态设置为“Open”，这表示开发人员正在处理这个“bug” Fixed（已修复的） 当开发人员进行处理（并认为已经解决）之后，他就可以将这个bug的状态设置为“Fixed”并将其提交给开发组的负责人，然后开发组的负责人将这个bug返还给测试组 Pending Reset（待在测试的） 当bug被返还到测试组后，我们将bug的状态设置为Pending Reset” Reset(再测试) 测试组的负责人将bug指定给某位测试人员进行再测试，并将bug的状态设置为“Reset” Closed（已关闭的） 如果测试人员经过再次测试之后确认bug 已经被解决之后，就将bug的状态设置为“Closed” Reopen（再次打开的） 如果经过再次测试发现bug（指bug本身而不是包括因修复而引发的新bug）仍然存在的话，测试人员将bug再次传递给开发组，并将bug的状态设置为“Reopen” Pending Reject（拒绝中） 如果测试人员传递到开发组的bug被开发人员认为是正常行为而不是bug时，这种情况下开发人员可以拒绝，并将bug的状态设置为“Pending Reject” Rejected(被拒绝的) 测试组的负责人接到上述bug的时候，如果他（她）发现这是产品说明书中定义的正常行为或者经过与开发人员的讨论之后认为这并不能算作bug的时候，开发组负责人就将这个bug的状态设置为“Rejected” Postponed（延期） 有些时候，对于一些特殊的bug的测试需要搁置一段时间，事实上有很多原因可能导致这种情况的发生，比如无效的测试数据，一些特殊的无效的功能等等，在这种情况下，bug的状态就被设置为“Postponed“ Bug类型：代码错误、界面优化、设计缺陷、配置相关、安装部署、安全相关、性能问题、标准规范、测试脚本和其他。 13、web测试和app测试的不同点？ 系统架构方面：web项目，一般都是b/s架构，基于浏览器的 app项目，则是c/s的，必须要有客户端，用户需要安装客户端。 web测试只要更新了服务器端，客户端就会同步会更新。App项目则需要客户端和服务器都更新。 性能方面: web页面主要会关注响应时间 而app则还需要关心流量、电量、CPU、GPU、Memory这些。 它们服务端的性能没区别，都是一台服务器。 兼容方面： web是基于浏览器的，所以更倾向于浏览器和电脑硬件，电脑系统的方向的兼容 app测试则要看分辨率，屏幕尺寸，还要看设备系统。 web测试是基于浏览器的所以不必考虑安装卸载。 而app是客户端的，则必须测试安装、更新、卸载。除了常规的安装、更新、卸载还要考虑到异常场景。包括安装时的中断、弱网、安装后删除安装文件 。 此外APP还有一些专项测试：如网络、适配性。 14、自动化测试框架？ 模块化测试框架：在一个组件上方建立一个抽象层使其在余下的应用中隐藏起来，这是众所周知的编程技巧。这样应用同组件中的修改隔离开来，提供了程序设计的模块化特性。模块化测试脚本框架使用这一抽象或者封装的原理来提高自动测试组合的可维护性和可升级性。 测试库框架：测试库框架把待测应用程序分解为过程和函数而不是脚本。这个框架需要创建描述模块、片断以及待测应用程序的功能库文件。 关键字驱动或表驱动的测试框架：在一个关键字驱动测试中，把待测应用程序的功能和每个测试的执行步骤一起写到一个表中。这个测试框架可以通过很少的代码来产生大量的测试用例。同样的代码在用数据表来产生各个测试用例的同时被复用。 数据驱动测试框架：测试的输入和输出数据是从数据文件中读取（数据池，ODBC源，CSV文件，EXCEL文件，ADO对象等）并且通过捕获工具生成或者手工生成的代码脚本被载入到变量中。在数据驱动测试中，数据文件中只包含测试数据。这个框架意图减少需要执行所有测试用例所需要的总的测试脚本数。数据驱动需要很少的代码来产生大量的测试用例，这与表驱动极其类似。 混合测试自动化（Hybrid Test Automation）框架：最普遍的执行框架是上面介绍的所有技术的一个结合，取其长处，弥补其不足。 15、黑盒测试和白盒测试有哪些方法？ 黑盒测试方法有等价类划分，边界值分析，错误推测，因果图法 白盒测试方法有逻辑覆盖法，程序插桩技术，基本路径法，符号测试，错误驱动测试 16、怎么看待测试，知道哪些测试的类型？ 测试是软件开发中不可或缺的一环，测试通过经济，高效的方法，捕捉软件中的错误，从而达到保重软件内在质量的目的。测试分为功能测试和非功能测试，非功能测试又可以分为性能测试、压力测试、容量测试、健壮性测试、安全性测试、可靠性测试、恢复性测试、备份测试、协议测试、兼容性测试、可用性测试、配置测试、GUI测试。","comments":true,"tags":[{"name":"测试基础知识","slug":"测试基础知识","permalink":"http://yoursite.com/tags/测试基础知识/"}]},{"title":"计算机网络总结","date":"2019-04-19T08:26:10.000Z","path":"2019/04/19/计算机网络总结/","text":"计算机网络基础总结 计算机网络体系结构 1、五层协议： 应用层（用户对用户） 任务：提供系统与用户的接口功能：文件传输、访问和管理、电子邮件服务协议：FTP、SMTP、POP3、HTTP、DNS 传输层（应用对应用、进程对进程） 传输单位：报文段（TCP）或用户数据报（UDP）任务：负责主机中两个进程之间的通信功能：为端到端连接提供可靠的传输服务；为端到端连接提供流量控制、差错控制、服务质量等管理服务协议：TCP、UDP 网络层（主机对主机） 传输单位：数据报所实现的硬件：路由器任务：将传输层传下来的报文段封装成分组；选择适当的路由，使传输层传下来的分组能够交付到目的主机协议：ICMP、ARP、RARP、IP、IGMP 数据链路层 传输单位 ：帧所实现的硬件：交换机、网桥任务：将网络层交下来的IP数据报组装成帧功能：链路连接的建立拆除、分离；帧定界和帧同步；差错检测 物理层 传输单位：比特所实现的硬件：集线器、中继器任务：透明地传输比特流功能：为数据端设备提供传送数据通路 2、OSI： 表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题； 会话层 ：建立及管理会话； 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理； 3、TCP/IP： 将五层协议中数据链路层和物理层合并为网络接口层； TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层； 物理层1、物理层的作用：实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异； 2、透明传送比特流：表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的； 3、数据传输方式： 电路交换：通信之前要在通信双方之间建立一条被双方独占的物理通路； 报文交换：采用存储转发的传输方式； 分组交换：采用存储转发的传输方式，可能出现失序、丢失或重复分组现象； 数据链路层1、数据链路层（链路层）：两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧； 2、数据链路层：封装成帧、透明传输、差错检测； 2、封装成帧：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束； 3、透明传输：当两个主机互相传送信息时，网络层的分组必须封装成帧，并以帧的格式进行传送； 帧定界：将一段数据的前后分别添加首部和尾部，就构成了帧，首部和尾部中含有很多控制信息，这些信息的重要作用之一是确定帧的界限； 4、差错检测：目前数据链路层广泛使用循环冗余检验（CRC）来检查比特差错； 5、信道复用技术： 频分复用：所有主机在相同的时间占用不同的频率带宽资源； 时分复用：所有主机在不同的时间占用相同的频率带宽资源； 统计时分复用：是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送； 波分复用：光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波； 码分复用：为每个用户分配 m bit 的码片，并且所有的码片正交； 6、CSMA/CD（载波监听多路访问 / 冲突检测）协议：每个站在发送数据报之前要先检测一下总线上是否有其他计算机在发送数据，若有，则暂时不发送数据，以免发生冲突；若没有，则发送数据。计算机在发送数据的同时检测信道上是否有冲突发生，若有，则采用截断二进制指数类型退避算法来等待一段随机时间后再次重发。（先听后发、边听边发、冲突停发、随机重发）； 7、PPP点对点协议：互联网用户通常需要连接到某个 ISP （互联网服务提供商）之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议； 8、MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）； 9、局域网：局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限； 10、广域网：由一些结点交换机以及连接这些交换机的链路组成； 11、以太网：采用总线拓扑结构，所有计算机共享一条总线，信息以广播方式发送； 12、交换机（多端口的网桥）：具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射，由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容； 网络层1、网络层：负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫IP数据报，简称数据报； 2、网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络； 3、与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protocol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） 4、IP数据报格式： 5、IP地址编址方式： 分类：由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的； IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 子网划分：从主机号借用若干个比特作为子网号（子网号绝不能全1和全0），而主机号也就相应减少了若干个比特，网络号不变，把两级 IP 地址划分为三级 IP 地址； IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 子网掩码：1对应于IP地址中的网络号和子网号，0对应于主机号，子网掩码与IP地址逐位“与”可得到网络地址； 无分类编址（CIDR）：为解决IP地址耗尽，使用各种长度的“网络前缀”来代替分类编址中的网络号和子网号； IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} 6、地址解析协议ARP：将IP地址转为物理（MAC）地址，每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表； 7、网际控制报文协议ICMP：检测出错误的路由器或主机都能把这些错误报告通过一些控制消息告诉发送数据的主机，ICMP分为两种：ICMP差错报告报文和ICMP询问报文； 8、路由器：从功能上可以划分为：路由选择和分组转发，分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口； 9、路由选择协议： 自治系统内部的路由选择：RIP 和 OSPF； RIP（UDP） 是一种基于距离向量的路由选择协议。距离是指跳数（范围限制在15跳之内），超过 15 表示不可达； 三要素： 仅和相邻路由器交换信息；交换的信息是当前本路由器所知道的全部信息，即自己的路由表；按固定的时间间隔交换路由信息； OSPF（IP）：链路状态协议； 三要素： 向本自治系统中所有路由器发送信息；发送的信息是否是与本路由器相邻的所有路由器的链路状态；只有当链路状态发生变化时，路由器才用洪犯法向所有路由器发送此信息； 自治系统间的路由选择：BGP（TCP），路径-向量路由选择协议； 总结： 主要特点 RIP OSPF BGP 网关协议 内部 内部 外部 路由表内容 目的网络，下一跳，距离 目的网络，下一跳，距离 目的网络，完整路径 最优通路依据 跳数 费用 的多种有关策略 算法 距离–向量协议 链路状态协议 路径-向量协议 传送方式 UDP IP数据报 TCP 10、NAT：将专用网内部使用的本地IP地址转换为有效的外部全球IP地址； 运输层1、运输层：负责向两台主机进程之间的通信提供通用的数据传输服务； 2、网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道； 3、UDP（一般用于即时通信，比如QQ语音 、QQ视频 、直播）主要特点： UDP是无连接的； UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）； UDP是面向报文的； UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）； UDP支持一对一、一对多、多对一和多对多的交互通信； UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短； 4、TCP（一般用于文件传输、发送和接收邮件、远程登录等场景）主要特点： TCP是面向连接的；（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）； 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）； TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达； TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据； 面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流； 5、TCP三次握手： 为什么要三次握手？ 三次握手的目的是建立可靠的通信信道，防止报文段在传输连接建立过程中出现差错； 6、TCP四次挥手： 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接； 7、TCP协议保证可靠传输： 超时重传： 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段； 利用滑动窗口实现流量控制的机制：发送窗口里面的序号表示允许发送的序号。如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收； 拥塞控制：在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载； 流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度； TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复； 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口； 慢开始（呈指数增长）：当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍； 拥塞避免（线性增长）：让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1； 快重传与快恢复：在TCP/IP中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有FRR，如果数据包丢失了，TCP将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作； 应用层1、应用层：通过应用进程间的交互来完成特定网络应用； 2、域名系统（DNS）：DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。这里的分布式数据库是指，每个站点只保留它自己的那部分数据； 3、文件传送协议：FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件； 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答； 数据连接：用来传送一个文件数据； 4、电子邮件协议： 一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议； 邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP； SMTP：SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则； POP3：只要用户从服务器上读取了邮件，就把该邮件删除，但是目前改进的 POP3 已经全面支持下载而不删除原邮件。 它的另一个主要特点是：无论你在客户端做了任何操作（如移动、标记），都不会反映到服务器上，也就是只能单方面地从服务器“读取”； IMAP：客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被自动删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 同时它与 POP3 的本质区别在于，在客户端的操作（包括删除）都会反映到服务器上，是一个双向的通信； 5、常用端口： 6、HTTP协议：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法； 7、浏览器输入url地址，显示主页的过程： 8、各种协议与HTTP协议之间的关系： 9、HTTP长连接、短连接： 在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话； 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码： 1Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接； 10、状态码： 11、HTTP和HTTPS的基本概念： HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少； HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL； HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性； 12、HTTP和HTTPS的区别： https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用； http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议； http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443； http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全； 参考博文链接：这篇和这篇～ 附图TCP、UDP互联网协议： TCP 三次握手和四次挥手： 从浏览器 URL 输入到页面显示经历过程： HTTPS与HTTP的区别，以及HTTP2： 附图来源： https://github.com/Joe19970619/Learning-materials/tree/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84","comments":true,"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"利用西门子数据集获取函数调用序列","date":"2019-04-12T08:07:10.000Z","path":"2019/04/12/利用西门子数据集获取函数调用序列/","text":"利用pvtrace工具获取测试集 replace 的函数调用关系图 About西门子数据集的目录结构参见此篇博文，本篇博文主要介绍根据需求编写测试脚本，利用pvtrace工具动态的将测试用例传入程序并获取函数调用关系图。由于在西门子的7个子测试集中，replace测试集含有的函数最多，因此本篇博文选用replace测试集作为例子，其他数据集也一样操作。 测试脚本范例理解上篇博文已经介绍replace数据集给我们提供了范例脚本，存储在scripts目录中，该脚本用于运行source.alt / source.orig 目录中被测程序的正确原型，但是研究软件缺陷定位不可能只运行正确的程序，将测试用例动态传入错误版本的程序并分析其运行结果更为重要，下面我们介绍如何利用套件中已经给出的范例脚本修改得到自己需要的运行脚本。 打开scripts目录下的runall.sh脚本，部分截图如下： 可以看出，该脚本的功能： 遍历inputs文件夹下的所有测试用例（replace测试集的inputs文件夹下包含3个子文件夹，里面的测试用例共计5542个）； 将每个测试用例依次传入被测程序中，并指定输出结果存放的路径； 如果想要将该脚本修改为执行错误版本程序的脚本，我们需要修改： 可执行程序的路径； 程序执行结果存放的路径； 手工修改该脚本中5542个路径显然不可行，需要手工编写程序使其自动修改路径，生成新的脚本文件。 在实际情况中，仅仅获取被测程序的运行结果通过与否是不足够的，根据需求还应获取程序执行信息（这里我示范的是获取程序的函数调用关系图）。 我们还需要了解pvtrace工具的使用，这个工具可以获取程序的函数调用关系，通过Graphviz 可以将函数调用关系可视化展示，下面介绍下pvtrace和Graphviz的安装： 安装pvtrace： 12345678#进入fl文件目录下：wget http://www.mtjones.com/developerworks/pvtrace.zip#解压下载包，如果出现命令找不到，需下载压缩工具yum install -y unzip zip 或者 sudo apt-get install zipunzip pvtrace.zipcd pvtracemakesudo make install 安装Graphviz： 1yum install graphviz 这里给出pvtrace和Graphviz的使用介绍链接： http://www.voidcn.com/article/p-xlemghrq-xb.html https://www.ibm.com/developerworks/cn/linux/l-graphvis/ 如果需要获取函数调用关系，为了避免路径出错，我们直接将pvtrace路径下的instrument.c文件拷贝到跟源码文件同级目录下，在GCC编译代码文件时需要加入指定编译选项即可： 1gcc -g -finstrument-functions replace.c instrument.c -o replace.exe 简单获取函数动态调用关系图示例这里先简单介绍下，如何获取函数动态调用关系图： 将pvtrace路径下的instrument.c文件拷贝到source.alt / source.orig目录下，然后将源程序代码replace.c和instrument.c一起编译，命令如下： 12cd source.alt/source.origgcc -g -finstrument-functions replace.c instrument.c -o replace.exe 将scripts目录中的脚本进行修改（命名为runV1.sh），这里示例一个测试用例，后面写代码批量修改路径： 12replace.exe '-?' 'a&amp;' &lt; ../../inputs/temp-test/1.inp.1.1 &gt; ../../outputs/t1pvtrace replace.exe 执行脚本文件： 1source ./runV1.sh source.alt / source.orig目录下生成graph.dot文件，用graphviz将它可视化： 1dot -Tpng graph.dot -o graph.png 执行命令后会报错，打开graph.dot文件将第一行的graph.dot改为graph即可，再执行上面命令； 执行完后，目录下会生成一个graph.png的图，这个图就是程序replace.c在传入t1这个测试用例生成的函数调用关系图： 从上图还可以看到函数之间调用的次数，当然，我们如果需要数据处理的话，利用graph.dot文件就够了，这个文件里包含函数之间调用关系，调用顺序，调用次数，这些信息根据需要自己进行处理； 生成测试脚本下面我参考这篇博文根据范例脚本生成错误版本执行的脚本，脚本生成使用lua语言实现。 首先初始化，指定子套件名称”replace”，测试用例个数5542和错误版本程序个数32； 12345678910SUITE_NAME = \"replace\"CASE_NUM = 5542VERSION_NUM = 32 --should be 32 in replace--VARIABLES--buff = &#123;&#125;i = 0j = 0k = 0line_num = 0tmp = \"\" 接着我们要将范例给的的runall.sh 读入，以便在下一步的文本分析中可以按行进行文本匹配，下面的程序段完成了将范例给出的runall.sh 文本读入，并按行存储至一个缓冲字符串数组buff 中： 12345678--SAVE ORIG SCRIPT INTO BUFFER--file = io.open(\"runall.sh\", \"r\")for line in file:lines() do i = i + 1; buff[i] = lineendline_num = ifile:close() 最后就是将buff 数组中的每一行进行文本匹配，将”/source.alt/source.orig/”字段全部替换为”/../../versions.alt/versions.orig/vX/”(其中”X”为相应的错误版本号)，将”/inputs/”字段全部替换为”/../../inputs/”，将”/outputs/”字段全部替换为”/../../newoutputs/vX”(其中”X”为相应的错误版本号)，其余保持不变，实现代码如下： 12345678910111213141516171819--GENERATE RUN SCRIPT FOR VERSIONS--for i = 1, VERSION_NUM do k = 1 file = io.open(\"run_v\"..i..\".sh\", \"w\") for j = 1, line_num do tmp = buff[j] if string.find(tmp, \"/source.alt/source.orig/\") ~=nil then tmp = string.gsub(tmp,\"/source.alt/source.orig/\", \"/../../versions.alt/versions.orig/v\"..i..\"/\") --modefy paths-- tmp = string.gsub(tmp,\"/inputs/\", \"/../../inputs/\") tmp = string.gsub(tmp,\"/outputs/\", \"/../../newoutputs/v\"..i..\"/\") tmp = tmp..\"\\ncd ../../../versions.alt/versions.orig/v\"..i..\" &amp;&amp; pvtrace replace.exe\" tmp = tmp..\"\\nmv trace.txt ./tra\"..k.. \" &amp;&amp; mv graph.dot ./tra\"..k k = k + 1 end file:write(tmp..\"\\n\") tmp = \"\" end file:close()end 上面这段代码为每次错误版本都生成了一个名为run_vX.sh 的运行脚本，其中X为相应的错误版本号。并且在每个测试用例执行之后，进入错误版本目录下运行命令pvtrace replace.exe，生成函数调用关系trace.txt和graph.dot文件，因为每个测试用例运行生成的dot文件名都是graph、txt文件名都是trace，因此为了避免覆盖需要将各个版本的每个测试用例生成的dot和txt文件移入对应的文件夹（下面需要在每个版本文件夹下建立5542个名为traX的文件夹—X为相对应执行的测试用例）； 123456789101112#下面是用python代码在每个错误版本程序文件夹下生成5542个存放dot和txt的文件夹#make_dir.pyimport osimport shutildir = os.getcwd()for index1 in range(1, 33): if index1 &gt; 0: new_dir = dir + '/v'+ str(index1) for index2 in range(5543): if index2 &gt; 0: os.mkdir(new_dir + '/tra' + str(index2)) pass 执行命令：python make_dir.py即可生成文件夹； 接着在versions.alt/versions.orig目录下建立一个存放shell脚本的文件夹sh，并将范例脚本runall.sh拷贝至sh目录下； 最后我们就可以执行前面的lua程序了，完整代码链接如下： 链接：https://pan.baidu.com/s/1aEO52uidTEVSKNJuzg2_mg 提取码：kqyz 12#运行make_sh.lua程序lua make_sh.lua 运行完后，可以在sh目录下发现生成的错误版本相对应的32个sh脚本，如下图： 批量编译在执行错误版本的测试脚本之前，首先需要对错误版本的代码进行自动批量编译，在这里，我们使用makefile 进行自动编译，makefile的结构如下： 12replace: gcc -g -finstrument-functions replace.c instrument.c -o replace.exe 由于我对makefile还不熟悉，因此采用的笨办法，将这个makefile文件在每个错误版本文件夹下拷贝一份，然后再写代码自动编译（在编译之前需要修改程序源码使其编译通过，修改方式参考这篇博文。","comments":true,"tags":[{"name":"软件缺陷定位","slug":"软件缺陷定位","permalink":"http://yoursite.com/tags/软件缺陷定位/"}]},{"title":"软件缺陷定位西门子数据集介绍","date":"2019-04-08T01:25:03.000Z","path":"2019/04/08/软件缺陷定位西门子数据集介绍/","text":"Siemens suite 的下载及使用详细步骤 AboutSiemens suite是软件缺陷定位领域研究中最常用的测试套件，可从SIR（software infrastructurerepository）下载，这个测试套件被很多有关软件缺陷定位的文献中使用。 Siemens suite下载进入SIR网址，如下图： 此时需要注册经审核后才可以登录下载，点即Get Access进入登录注册界面： 点击Register进入注册界面，注册需要填写自己所在机构或公司（我填的是学校名称），还有关于自己研究方向的简短描述，填完基本信息后，经过审核就可以登录进行下载了。 登录后，可以点击Download Objects进行下载： 这里我把Siemens suite包含的7个测试集都下载好了，链接如下： 链接：https://github.com/xuexuehan/Siemens-suite Siemens suite使用首先看下Siemens suite包含的7个测试集主要信息： Program Description Lines of Code Faulty versions Test cases print_tokens lexical analyzer 565 7 4130 print_tokens2 lexical analyzer 510 10 4115 schedule priority scheduler 412 9 2650 schedule2 priority scheduler 307 10 2710 replace pattern replacement 563 32 5542 tcas altitude separation 173 41 1608 tot_info information measure 406 23 1052 这几个测试集的文件组织结构和使用方法基本雷同，只要掌握一个，其他也是一样的方法。接下来主要以replace测试集为例介绍下该套件的目录组织结构： 首先建立一个存放测试集的文件夹fl，将下载的replace测试集放在fl文件夹下，在此目录下解压： 1tar zxvf replace_2.1.tar.gz 解压完成后，会在解压目录下生成replace文件夹，打开文件夹可以看到其目录组织结构： 在这些目录中，我们需要用到的有inputs、newoutputs、outputs、scripts、source.alt、versions.alt，这里面source和versions文件夹是空的，可以忽略； 先看source.alt / source.orig里面有replace.c这个被测程序的代码文件，在执行测试程序以前，需要将其提前编译为replace.exe 的二进制文件以供测试程序调用。进入source.alt / source.orig目录下，利用Linux平台上 GCC编译器编译被测代码，使用命令： 1gcc -O2 replace.c -o replace.exe 注意：”-O2”中是大写字母”O”而不是数字”0”,表示使用2级优化，而后面的”-o”中是小写字母”o”,表示指定输出文件名。执行命令后可以看到： 可以看到编译器弹出警告，这是由于Siemens Suite 套件中，代码大多完成于90年代，而我们使用的GCC 编译器的版本较新。在此期间，C语言的国际标准发生了很大变化，在replace中，如果想要编译器编译通过，需要修改replace.c代码文件： 主要修改的还是将一些库函数加入到include中，把内置函数和关键字重命名： 首先将 ctype.h 和 stdlib.h 头文件加入到include中； 将函数名为getline的全部替换为get_line（因为getline函数在stdio.h中已经定义，重命名即可）； 将# define NULL 0 修改为 define NUL 0（因为NULL是关键字，提示重复定义）； 此时，修改完毕，再继续编译，即可通过，会在同目录下生成replace.exe； 这里放上我修改后的replace.c代码文件链接： 链接：https://pan.baidu.com/s/1c4mKAcqNegs7kMBa_abVdg 提取码：upkh 在编译其他测试套件代码文件时也会弹出警告，甚至报出错误无法编译，需要按照相应的提示修改代码文件； versions.alt / versions.orig 目录中保存了该被测程序的每个错误版本（在正确的程序之中，随机植入若干错误，产生的错误代码供大家测试），打开versions.alt / versions.orig 目录可以看到replace的32个错误版本文件夹（里面的replace.c里有植入错误，同理按照上面的步骤修改使其编译通过）： 在这32个错误版本中，错误产生的地方在代码文件中有注释标明； inputs / input 目录里保存了所有的测试用例的输入； outputs 目录用于保存被测程序的正确原型（即source.alt / source.orig 目录中的replace.c代码）对于每个测试用例给出的预期输出，在测试含有错误的版本时用于比较相同测试用例得到的执行结果是否相同。在未执行任何测试程序之前，outputs 目录暂时为空； newoutputs 目录用于保存被测程序的每个错误版本对于每个测试用例得到的实际输出，在测试含有错误的版本时用于比较相同测试用例得到的执行结果是否相同。在未执行任何测试程序之前，newoutputs 目录暂时为空； scripts 目录中保存了子测试套件给出的测试脚本范例，打开scripts 目录后可以看到该目录下有一个名为runall.sh 的shell 脚本文件，该脚本文件用于运行source.alt / source.orig目录中被测程序正确原型，将测试用例输入到被测程序正确原型中后，将执行结果输出到replace 中outputs 目录下，按每个测试用例组织文件，runall.sh 中共定义了5542 个测试用例（replace 子套件共有5542 个测试用例），在scripts 目录中输入命令 source ./runall.sh 即可运行该脚本文件，在运行该脚本之前，需要先将source.alt / source.orig 中的replace.c代码文件编译并且修改runall.sh脚本文件replace.exe存放的路径。因为现在新版的套件replace.c程序文件在source.alt / source.orig目录下而非source目录下，将脚本文件中所有的 ../source 替换为 ../source.alt/source.orig； 这里给出我修改后的runall.sh脚本文件链接： 链接：https://pan.baidu.com/s/1efga4E3dI5uh7tk2YFZJWA 提取码：6tan 当运行完runall.sh脚本后，在outputs目录下可以看到这5542个测试用例执行后的结果文件，下图是部分截图： 至此，西门子测试集的子套件目录结构介绍完毕。 参考博文：https://blog.csdn.net/mangoer_ys/article/details/25974067#commentBox （这个博主写的真详细，我基本就是参考这个博文了解的西门子测试集使用方法）","comments":true,"tags":[{"name":"软件缺陷定位","slug":"软件缺陷定位","permalink":"http://yoursite.com/tags/软件缺陷定位/"}]},{"title":"阿里云部署SpringBoot项目","date":"2019-04-07T09:07:25.000Z","path":"2019/04/07/阿里云部署SpringBoot项目/","text":"阿里云部署Spring Boot 项目详细步骤 购买云服务器首先需要在阿里云购买云服务器，进入链接后选择弹性计算，选择所需的类型购买（如果是学生党，完成学生认证后，有学生专享优惠，9.5/月，不能再划算了…），购买完成后，点击控制台就可看到自己购买云服务器的详情； 设置密码，这个密码就是用ssh连接云服务器的密码； 这里我使用了两个软件：SecureCRT（用来连接云服务器） 和 WinSCP（用来从本机给云服务器上传文件）； WinSCP图形化界面如下： 左边面板显示的是本机文件目录，右边是云服务器文件目录；（如果目录不显示压缩包的话，记得在传输选项里的配置里在面板选项去掉“默认目录是主目录”）； 这两个软件下载地址：https://pan.baidu.com/s/1zUnhqBffaqiDG3wYFM6dpg 提取码：1zxb 然后就开始在云服务器上安装配置MySQL和JDK； 安装配置MySQL这里安装配置需要细心，因为有挺多需要修改的配置文件，当然用docker安装配置更加方便，这里用的常规安装配置； 首先将MySQL安装包用WinSCP从本机上传至云服务器； 这里提供我安装MySQL所使用的版本： 链接：https://pan.baidu.com/s/1t8wBXQy89AF-XYxeN3Et1g提取码：az6k 具体安装配置步骤如下面链接文档所示（因为步骤有点多，直接提供文档，步骤很详细）： 链接：https://pan.baidu.com/s/1eLal9b3j5Aca_vcA0VCf0A 提取码：gfxy链接里的配置文档主要操作就是安装MySQ、添加用户组和用户、授权、配置环境变量、修改密码、关闭防火墙…，在修改了配置文件后需要flush privileges，最后就是需要在阿里云添加安全组规则，开放MySQL端口号3306； 安装配置JDK首先将JDK安装包用WinSCP从本机上传至云服务器，我上传到云服务器/opt目录里面； 这里提供我安装JDK所使用的版本： 链接：https://pan.baidu.com/s/1IyQqgMepQj4kQthiE9FITA 提取码：uizg 解压文件： 12cd /opttar -zxvf jdk的文件名 将jdk移动到/home目录：mv jdk1.8.0_171/ /home/ 配置环境变量： vim /etc/profile 在末尾行添加，打开后按 i 编辑, 按 ctrl+c 停止编辑，然后 :wq 保存退出 12export JAVA_HOME=/home/jdk1.8.0_171export PATH=$PATH:$JAVA_HOME/bin: 使更改的配置立即生效：source /etc/profile java -vsion查看JDK版本信息，如果显示出1.8.0证明成功 阿里云发布项目将打包后的项目用WinSCP从本机上传至云服务器，然后向mysql云服务器执行项目sql脚本，在阿里云添加安全组规则，开放端口号8080和80，进入上传项目的目录下执行命令： 12//后台进程执行项目nohup java -jar spring-boot-10-bill-0.0.1-SNAPSHOT.jar --serverport=80 &amp; 停止运行项目： 1234//查看进程ps -ef|grep java//找到项目的进程id，杀死该进程kill -9 进程id 至此，项目部署完毕，可以通过云服务器的ip地址访问项目。当然如果买了域名，挂到云服务器的ip地址下，就可以解析ip，直接通过域名访问。 MySQL中文乱码部署完项目，访问时可能会出现中文乱码问题，首先登录mysql； 12#查看数据库编码：show variables like '%char%'; 如果character_set_database 和 character_set_server显示字符编码为latin1,此时修改mysql配置文件/etc/my.cnf： 123456[mysqld]character-set-server=utf8 [client]default-character-set=utf8 [mysql]default-character-set=utf8 然后再重启，登录mysql，查看字符编码： 1show variables like '%char%'; 出现如上图字符编码为utf-8,则成功。 参考博客链接：https://blog.csdn.net/u012410733/article/details/61619656","comments":true,"tags":[{"name":"Spring-Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot基础总结","date":"2019-04-03T06:53:02.000Z","path":"2019/04/03/Spring-Boot基础总结/","text":"关于Spring Boot一些基础总结 About1、尽快启动和运行，使用“习惯优于配置”（项目中存在大量的配置，而 Spring Boot 内置一个习惯性的配置，让你无须手动进行配置）的理念让项目快速运行起来； 2、Spring Boot 优点 ： 快速构建独立运行的Spring项目； 无须依赖外部Servlet容器，应用无需打成WAR包；项目可以打成jar包独自运行； 提供一系列 starter pom 来简化 Maven 的依赖加载； 大量的自动配置，对主流开发框架的无配置集成； 无须配置XML，开箱即用，简化开发，同时也可以修改默认值来满足特定的需求； Spring Boot 并不是对 Spring 功能上的增强，而是提供了一种快速使用 Spring 的方式； 极大提高了开发、部署效率 ； 入门1、两种启动方式： 直接main； 打成jar包，在dos命令下java -jar 项目名称； 2、Spring Boot底层依赖： 123456789101112131415161718192021222324252627282930 /* spring-boot-starter-parent：是当前项目的父依赖 spring-boot-starter-parent继承spring-boot-dependencies spring-boot-dependencies里面定义了很多组件版本号，我们引用对应依赖时，不需要写&lt;version&gt; */&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; /* spring-boot-starter-web：构建web项目，比如：Tomcat、SpringMVC spring-boot-starter：它是SpringBoot的场景启动器，针对不同场景定义了很多不同的场景启动器 你的项目需要哪些场景启动器，则直接依赖对应的启动器就可以了 */ &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; //将当前项目打成一个jar包运行 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 3、Spring Boot底层源码： 1234567891011121314/** * @SpringBootApplication 用于标识为引导类,说明当前是一个SpringBoot项目 * @SpringBootConfiguration * @Configuration 它属于spring中的一个注解，定义配置类，等价于配置文件 * @Component 添加到spring容器中，表示是一个组件 * @EnableAutoConfiguration * @AutoConfigurationPackage 将引导类所在包及其子包下面所有的组件添加到spring容器中 * @Import(&#123;AutoConfigurationImportSelector.class&#125;) * 1、将所有组件以全类名的方式返回，并且添加到spring容器中 * 2、会给容器中导入非常多的自动配置类（*****AutoiConfiguration），就是导入并配置好很多当 前项目中所需要的组件 * 省去我们手动编写配置然后注入到组件中 * @ComponentScan 被该注解标识的类，会被spring容器进行管理 **/@SpringBootApplication//组合注解 核心配置1、spring boot全局配置： application.properts application.yml 2、YAML： YAML不是一个标记语言； 以数据为中心，配置数据的时候具有面向对象的特征；比json、xml更适合做配置文件； 3、YAML语法格式： YAML基本语法： key: value 表示一对键值对（冒号后面必须有空格）； 使用空格缩进表示层级关系； 左侧缩进的空格数目不重要，只要同一层级的元素左侧对齐即可 ； key 与 value大小写敏感； YMAL常用写法： 字面量： 数值，字符串，布尔，日期； 字符串默认不用加上引号： “ ” 使用双引号会转义特殊字符，特殊字符最终会转成本来想表示含义输出； ‘ ‘ 使用单引号不会转义特殊字符，特殊字符当作一个普通的字符串输出； 对象 &amp; Map ： key: value value存储对象，每个值换一行写，注意值要左对齐； 1234emp: lastName: xiaomeng age: 22 salary: 10000 行内写法： 1emp: &#123;lastName: xiaomeng, age: 22, salary: 10000&#125; 数组（List、Set）： 用 - 值表示数组中的一个元素： 1234fortes: - java - python - hadoop 行内写法： 1fortes: [java, python, hadoop] ​4、YAML全局配置文件注入值： 12345/** ConfigurationProperties: 告诉spring boot将配置文件中的对应属性值，映射到这个组件类中，进行一一绑定* prefix = \"emp\": 配置文件中的前缀名，配置了哪个前缀就会与下面的所有属性进行一一映射* @Component: 将当前组件作为springboot中的一个组件来使用，这样才会纳入容器中管理* */ 5、@Value注解获取注入值： 1234567/** * 类似于spring框架中使用配置文件中的数据注入方式 * &lt;bean class=\"Emp\"&gt; * &lt;property name=\"lastName\" value=\"字面量/#&#123;SpEL&#125; spring表达式/$&#123;key&#125;从配置文件获取\"&gt; &lt;/property&gt; * &lt;/bean&gt; * */ @Value(\"$&#123;emp.last-name&#125;\") 6、比较@Value和@ConfigurationProperties获取值： @ConfigurationProperties @Value 示例 实现功能 批量注入配置文件的属性值 一个一个指定 松散绑定（松散语法） 支持 不支持 last_name == lastNamelast-name == lastName SpEL 不支持 支持 #{10*2} 复杂类型封装 支持 不支持 ${emp.map} JSR303数据校验 支持 不支持 使用场景： 如果只是在某个业务逻辑中需要获取配置文件中的某个属性值，就使用 @Value； 如果专门使用javaBean和配置文件进行映射，就使用 @ConfigurationProperties； 7、加载局部配置文件： 1@PropertySource(value = &#123;\"classpath:emp.properties\"&#125;) 8、加载XML配置文件： 12//用于导入spring的配置文件，并将它加载到容器中@ImportResource(locations = &#123;\"classpath:spring01.xml\"&#125;) 9、自定义配置类： 123456789101112131415/***@Configuration: 它属于spring中的一个注解,用于标识当前类是一个配置类，来表示对应spring配置文件**/@Configurationpublic class EmpConfig &#123; /** * @Bean 标识的方法用于向容器中注入组件 * 1、返回值就是注入容器中组件对象 * 2、方法名就是这个组件的 id 值 * */ @Bean public EmpService empService2() &#123; System.out.println(\"EmpService 组件注入成功\"); return new EmpService(); &#125; 10、多环境项目配置支持： 12345678910111213141516171819//properties#激活profile文件spring.profiles.active=prod//ymlserver: port: 8081 #默认配置的端口号spring: profiles: active: dev #激活哪个profile---server: port: 8082spring: profiles: dev #指定属于哪个环境，dev环境使用---server: port: 8088spring: profiles: prod #指定属于哪个环境，prod环境使用 程序参数、命令行（jar包运行时）：–spring.profiles.active=prod； 虚拟机指定参数：-Dspring.profiles.active=prod； 11、配置文件加载位置： 配置文件位置 说明 file: ./config/ 当前项目的config目录下（最高级别） file: ./ 当前项目的根目录下（第三级别） classpath: /config/ 类路径的config目录下（第二级别） classpath: / 类路径的根目录下（最低级别） 按照优先级从低到高的顺序，将所有位置的配置文件全部加载，高优先级的配置内容会覆盖低优先级的配置内容； 日志配置1、日志框架： 日志抽象层 日志实现 jboss-logging（不适合企业项目开发使用）JCL（Jakarta Commons Logging）—2014年后不再维护SLF4j（Simple Logging Facade for Java）—与log4j、Logback同一个人开发 JUL（java.util.logging）—担心被抢市场，推出的Log4j（存在性能问题）Logback（Log4j同一个人开发的新框架，做了重大升级）Log4j2（apache开发的很强大，借了log4j的名，但当前很多框架未适配上） Spring Boot 采用了 slf4j+logback 的组合形式，Spring Boot也提供对JUL、log4j2、Logback提供了默认配置； 2、log五大日志级别：（由低到高） 12345678910111213//1、下面定义的都是日志级别，由低到高：trace &lt; debug &lt; info &lt; warn &lt; error//2、spring boot默认设定的是 info 级别日志（日志默认级别也称为root级别）//3、可以通过配置文件进行修改 日志级别，设置某一个级别后，就只打印这个级别及后面更高级别的日志信息，没有指定级别的就用springBoot默认规定的级别，root级别//跟踪运行信息logger.trace(\"这是 trace 日志信息\");//调试信息logger.debug(\"这是 debug 日志信息\");//自定义信息logger.info(\"这是 info 日志信息\");//警告信息logger.warn(\"这是 warn 日志信息\");//错误信息logger.error(\"这是 error 日志信息\"); 1234//调整指定包的日志级别logging.level.com.xx=debug//修改springboot的root级别（默认级别）logging.level.root=debug 3、修改日志默认配置： 修改日志文件生成路径： 1234//输出到当前项目根路径下的springboot.log文件中logging.file=springboot.log//输出到当前项目所在磁盘根路径下的/springboot/log目录中的spring.log文件中 E:\\springboot\\log\\spring.loglogging.path=/springboot/log 修改日志输出的格式： 1234567891011/**日志输出格式说明：* %d 输出日期时间，* %thread 输出当前线程名，* %-5level 输出日志级别，左对齐5个字符宽度# %logger&#123;50&#125; 输出全类名最长50个字符，超过按照句点分割# %msg 日志信息# %n 换行符 *///修改控制台输出的日志格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; == [%thread] %-5level %logger&#123;50&#125; - %msg%n//修改文件中输出的日志格式logging.pattern.file=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-5level &gt;&gt;&gt; %logger&#123;50&#125; - %msg%n 4、自定义日志配置： logback.xml ：是直接就被日志框架加载了； logback-spring.xml：配置项不会被日志框架直接加载，而是由 SpringBoot 解析日志配置文件，进而可以使用 SpringBoot 的 Profile 特殊配置 ； 使用日志profile特殊配置，可根据不同的环境激活不同的日志配置： 1234567891011&lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; //根据不同的环境要求进行配置不同的日志信息 &lt;springProfile name=\"dev\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; === [%thread] === %-5level === %logger&#123;50&#125; === %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-5level &gt;&gt;&gt; %logger&#123;50&#125; &gt;&gt;&gt; %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; 5、切换日志框架： 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; //采用log4j2的日志框架 //将spring-boot-starter-logging移除 &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; web开发1、springboot web启动器包括嵌入的Servlet容器和SpringMVC； 2、springboot对静态资源（webjars/静态文件）的映射： 123456789101112public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;if (!this.resourceProperties.isAddMappings()) &#123;logger.debug(\"Default resource handling disabled\");&#125; else &#123;Duration cachePeriod =this.resourceProperties.getCache().getPeriod();CacheControl cacheControl =this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123;//收到 /webjars/**请求后 ，会去classpath:/META-INF/resources/webjars/ 查找资源文件this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;\"/webjars/**\"&#125;).addResourceLocations(new String[]&#123;\"classpath:/METAINF/resources/webjars/\"&#125;).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); 访问 localhost:8080/webjars/jquery/3.3.1/jquery.js 会在下面路径中查找： 123456//引入jquery webjars&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt; 当接受到 /** 请求访问资源时, 会被映射到下面4个 类路径下的静态资源目录中查找 ： 1234classpath:/META-INF/resources/classpath:/resources/classpath:/static/classpath:/public/ 访问 localhost:8080/style.css 会在上面四个静态资源路径中查找文件 ； 3、欢迎页的映射： 会从 4个静态资源目录 + 根路径 / 中 查找 index.html 页面： 12345classpath:/META-INF/resources/classpath:/resources/classpath:/static/classpath:/public//: 当前项目根路径下 会在 静态资源目录下 与 根路径查找 (按该顺序) index.html页面； 收到 “/**” 请求映射； 访问 localhost:8080/ 会在上面5个目录中查找 index.html页面（因为/也属于/**）； 4、项目ico图标的映射： Spring Boot 会在静态资源目录下 与 根路径(按该顺序) 查找 faicon.ico 页面； 如果存在这样的文件，springboot会自动将其设置为应用图标； 5、Thymeleaf模板引擎： 嵌入式tomcat默认不支持jsp； Spring Boot 官方推荐使用 Thymeleaf 作为模板引擎， 因为 Thymeleaf 提供了完美的 SpringMVC 的支持； pom.xml 加入 Thymeleaf 启动器： 12345//thymeleaf 模板启动器&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 模板文件放在哪里 ? DEFAULT_PREFIX = “classpath:/templates/“； 将 HTML 页面放到 classpath:/templates/ 目录下， Thymeleaf 就能自动渲染； 在 html 页面加上以下名称空间, 使用 Thymeleaf 时就有语法提示 ： 1&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt; 6、Thymeleaf语法： 常用属性： 标准表达式语法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273一、Simple expressions（表达式语法） 1. Variable Expressions(变量表达式): $&#123;...&#125; （参考： 4.2 Variables） 1)、获取变量值；使用OGNL表达式； 2）、获取对象的属性, 调用方法 3）、使用内置的基本对象： #ctx : the context object.(当前上下文对象) #vars: the context variables.(当前上下文里的变量) #locale : the context locale. (当前上下文里的区域信息) 下面是Web环境下的隐式对象 #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. 示例: $&#123;session.foo&#125; (用法参考: 18 Appendix A: Expression Basic Objects) 4）、使用内置的工具对象：(用法参考: 19 Appendix B: Expression Utility Objects) #execInfo : information about the template being processed. #messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration) 2. Selection Variable Expressions(选择表达式): *&#123;...&#125; （参考：4.3 Expressions on selections） 1）、和$&#123;&#125;在功能上是一样， 额外新增：配合 th:object 使用 &lt;div th:object=\"$&#123;session.user&#125;\"&gt; 省得每次写$&#123;session.user.firstName&#125;, 直接取出对象，然后写对象名即可 &lt;p&gt;Name: &lt;span th:text=\"*&#123;firstName&#125;\"&gt;Sebastian&lt;/span&gt; &lt;/p&gt; &lt;p&gt;Email: &lt;span th:text=\"*&#123;email&#125;\"&gt;Saturn&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; 3. Message Expressions（获取国际化内容）: #&#123;...&#125; （参考：4.1 Messages） 4. Link URL Expressions（定义URL）: @&#123;...&#125; （参考：4.4 Link URLs） 5. Fragment Expressions（片段引用表达式）: ~&#123;...&#125; （参考：4.5 Fragments） &lt;div th:insert=\"~&#123;commons :: main&#125;\"&gt;...&lt;/div&gt;二、Literals（字面量） （参考： 4.6 Literals） 1. Text literals: 'one text' , 'Another one!' ,… 2. Number literals: 0 , 34 , 3.0 , 12.3 ,… 3. Boolean literals: true , false 4. Null literal: null 5. Literal tokens: one , sometext , main, ... 三、Text operations（文本操作） （参考： 4.7 Appending texts） 1. String concatenation: + 2. Literal substitutions: |The name is $&#123;name&#125;|四、Arithmetic operations（数学运算） （参考： 4.9 Arithmetic operations） 1. Binary operators: + , - , * , / , % 2. Minus sign (unary operator): -五、Boolean operations（布尔运算） 1. Binary operators: and , or 2. Boolean negation (unary operator): ! , not六、Comparisons and equality（比较运算） （参考： 4.10 Comparators and Equality） 1. Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) 2. Equality operators: == , != ( eq , ne )七、Conditional operators(条件表达式;三元运算符) （参考： 4.11 Conditional expressions） 1. If-then: (if) ? (then) 2. If-then-else: (if) ? (then) : (else) 3. Default: (value) ?: (defaultvalue)八、Special tokens（特殊操作） (参考： 4.13 The No-Operation token) 1. No-Operation: - 12345678&lt;!-- th:insert 和 th:replace的区别 th:insert和th:replace都可以引入片段，两者的区别在于 th:insert： 保留引入时使用的标签 th:replace：不保留引入时使用的标签, 将声明片段直接覆盖当前引用标签 --&gt; &lt;div th:replace=\"header :: #header_common_id\" class=\"success\"&gt;&lt;/div&gt; &lt;h2 th:insert=\"header :: #header_common_id\"&gt;&lt;/h2&gt; 17、迭代(th:each)： 12345678910111213141516171819202122 &lt;!--th:each作用在哪个标签上面，对应的就会根据它的值迭代多少次--&gt; &lt;!-- user : 第1个值,代表每次迭代出对象,名字任意取 iterStat : 第2个值,代表每次迭代器内置对象, 名字任意取, 并有如下属性: index : 当前迭代下标 0 开始 count : 当前迭代下标 1 开始 size : 获取总记录数 current : 当前迭代出的对象 even/odd : 当前迭代是偶数还是奇数 (1开始算,返回布尔值) first : 当前是否为第一个元素 last : 当前是否为最后一个元素 --&gt; &lt;tr th:each=\"user, iterStat: $&#123;userList&#125;\"&gt; &lt;td th:text=\"$&#123;iterStat.count&#125;\"&gt;000&lt;/td&gt; &lt;td th:text=\"$&#123;user.username&#125;\"&gt;xxx&lt;/td&gt; &lt;td th:text=\"$&#123;user.gender == 1 ? '男' : '女'&#125;\"&gt;1&lt;/td&gt; &lt;td th:text=\"$&#123;iterStat.size&#125;\"&gt;xxx&lt;/td&gt; &lt;td th:text=\"$&#123;iterStat.even&#125;? '偶数' : '奇数'\"&gt;xxx&lt;/td&gt; &lt;td th:text=\"$&#123;iterStat.first&#125;\"&gt;xxx&lt;/td&gt; &lt;td th:text=\"$&#123;iterStat.last&#125;\"&gt;xxx&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 8、条件判断： 1234567&lt;h3 th:if=\"not $&#123;#lists.isEmpty(userList)&#125;\"&gt;显示出来则userList集合不为空&lt;/h3&gt;&lt;h3 th:unless=\"$&#123;#lists.isEmpty(userList)&#125;\"&gt;显示出来则userList集合不为空&lt;/h3&gt;&lt;div th:switch=\"$&#123;sex&#125;\"&gt; &lt;p th:case=\"$&#123;man&#125;\"&gt;男&lt;/p&gt; &lt;p th:case=\"2\"&gt;女&lt;/p&gt; &lt;p th:case=\"*\"&gt;未知&lt;/p&gt;&lt;/div&gt; 9、显示标签体内容： 1234&lt;!--不转义字符--&gt;&lt;div th:text=\"$&#123;desc&#125;\"&gt;&lt;/div&gt;&lt;!--转义字符--&gt;&lt;div th:utext=\"$&#123;desc&#125;\"&gt;&lt;/div&gt; 显示对象： 12345&lt;div th:object=\"$&#123;session.user&#125;\"&gt; &lt;!--上面已经将对象获取出来，下面直接写属性值即可获取到值--&gt; &lt;p&gt;姓名：&lt;span th:text=\"*&#123;username&#125;\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;性别：&lt;span th:text=\"*&#123;gender&#125; == 1 ? '男' : '女'\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt; 10、springboot热部署： 12345678//开发环境建议关闭thymeleaf缓存spring.thymeleaf.cache=false//热部署依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;//Ctrl + F9 编译 11、扩展springmvc功能： 1234567891011121314151617/** * 1、创建一个WebMvcConfigurer类型的子类 * 2、类上用@Configuration标识它是一个配置类 * 3、不能@EnableWebMvc标识 * 原理： * 1、@Import(&#123;WebMvcAutoConfiguration.EnableWebMvcConfiguration.class&#125;) * 2、public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration * */@Configurationpublic class MySpringConfigurer implements WebMvcConfigurer &#123; //增加视图控制 @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //发送 /xuexue 请求来到 success.html registry.addViewController(\"/xuexue\").setViewName(\"success\"); &#125;&#125; 12、全面控制springmvc： 在自定义的Web配置类上添加 @Configuration 和 @EnableWebMvc 注解； 总结SpringMVC 配置： 在Spring Boot中自已配置组件的时候，先看容器中有没有公司自已配置的（@Bean、@Component）,如果 有就用公司自已配置的; 如果没有，才自动配置； 在Spring Boot中会有非常多的xxxConfigurer帮助我们进行扩展配置； 在Spring Boot中会有很多的xxxCustomizer帮助我们进行定制配置； Spring Boot Restful架构Restful架构：通过HTTP请求方式区别对资源CRUD操作，请求URI是/资源名称/资源标识； 普通CRUD RestfulCRUD 查询 getPrvider provider —GET 添加 addProvider?xxx provider —POST 修改 updateProvider?id=xxx provider /{id} —PUT 删除 deleteProvider?id=1 provider /{id} —DELETE springboot错误处理机制1、几种常见错误（状态码）： 浏览器发送一个不存在的请求时，会报404； 500； 2、timestamp：时间戳， status：状态码， error：错误提示， exception：异常对象， message：异常消息， errors：JSR303数据校验出现的错误； 嵌入式Sevlet容器自定义配置1、注册Servlet三大组件 Servlet/Filter/Listener： ServletRegistrationBean ：注册自定义Servlet ； FilterRegistrationBean：注册自定义Filter； ServletListenerRegistrarionBean：注册自定义Listener； 2、修改嵌入式servlet 容器配置： 123456//修改服务相关的配置server.port=8081//修改关于servlet的相关配置server.servlet.context-path=/servlet//修改tomcat相关配置server.tomcat.max-connections=8000 3、自定义定制器修改嵌入式servlet容器配置： 12345678910111213@Beanpublic WebServerFactoryCustomizer webServerFactoryCustomizer() &#123; return new WebServerFactoryCustomizer() &#123; @Override public void customize(WebServerFactory factory) &#123; ConfigurableServletWebServerFactory factory1 = (ConfigurableServletWebServerFactory)factory; //修改端口号，如果配置文件中与定制器中的配置冲突，默认采用定制器的配置 factory1.setPort(8082); factory1.setContextPath(\"/servlet2\"); &#125; &#125;;&#125; 事务管理123//默认创建表类型是MyISAM，是非事务安全的，所以无法实现事物回滚//指定如下方言: 创建的表类型是Innodb，才可以进行对事物的回滚database-platform: org.hibernate.dialect.MySQL57Dialect 事务管理步骤： 在启动类上 ，使用 @EnableTransactionManagement 开启注解方式事务支持； 在 Service层方法上添加 @Transactional 进行事务管理； 定时任务使用的注解： @EnableScheduling 启动类上开启基于注解的定时任务 ； @Scheduled 标识的方法会进行定时处理 ； 需要通过 cron 属性来指定 cron 表达式： 秒 分 时 日 月 星期几； 在线cron表达式生成器：http://cron.qqe2.com/ 附windows环境下Redis软件下载： https://pan.baidu.com/s/1TPsFnoVJ3e0UhUR5y4K2sw 提取码：qa25 Spring Boot参考文档： https://pan.baidu.com/s/1ai0azTuXtwGSOKEbefIOHw 提取码：hqlv Thymeleaf模板引擎参考文档： https://pan.baidu.com/s/1wymLJ8gbWzzWQG1SRH3NQw 提取码：j5pp ​","comments":true,"tags":[{"name":"Spring-Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Python基础","date":"2019-03-23T05:52:00.000Z","path":"2019/03/23/Python基础/","text":"Python一些基础语法概念 About1、实践、练习 ​ 实践、认识、再实践、再认识 2、实践、实践、实践 基本语法1、程序设计基本方法： 计算机与程序设计：计算机发展按照摩尔定律发展； 编译和解释： 编译：将源代码一次性转为目标代码； 解释：将源代码逐条转成目标代码同时逐条运行的过程； 程序的基本编写方法：IPO（input、process、output）； 2、编程解决问题的步骤： 分析问题：分析问题的计算部分，想清楚； 划分边界：划分问题的功能边界，规划IPO； 设计算法：设计问题的求解算法，关注算法； 编写程序：编写问题的计算程序，编程序； 调试测试：调试程序使正确运行，运行调试； 升级维护：适应问题的升级维护，更新完善； 3、程序语法元素： 注释：单行#，多行’‘’ ‘’‘ 命名（大小写敏感）与保留字（python有33个保留字）；数据类型：字符串（编号索引从0开始）–正向递增序号和反向递减序号、数字类型（整数、浮点数）、列表（有序序列）–使用in判断一个元素是否在列表中； 字符串的使用：使用[]获取字符串中一个或多个字符； 索引：返回字符串中单个字符； 切片：返回字符串中一段字符子串； 语句与函数：赋值语句、分支语句、eval()评估函数–去掉参数最外侧引号并执行余下语句的函数； python程序的输入输出：输入（input—从控制台获取用户输入）、输出（print—以字符形式向控制台输出结果）； 基本图形绘制1、编程语言的多样初心（600多种）： c语言：（指针、内存、数据类型）；语言本质：理解计算机系统结构；解决问题：性能； java：（对象、跨平台、运行时）；语言本质：理解主客体关系；解决问题：跨平台； c++：（对象、多态、继承）；语言本质：理解主客体关系；解决问题：大规模程序； VB：（对象、按钮、文本框）；语言本质：理解交互逻辑；解决问题：桌面应用； python：（编程逻辑、第三方库）；语言本质：理解问题求解；解决问题：各类问题； 2、python语言特点：（通用、脚本、开源、跨平台、多模型）： 特点与优势：强制可读性、较少的底层语法元素、多种编程方式、支持中文字符、（语法简洁）， &gt;13万第三方库、快速增长的计算生态、避免重复造轮子、开放共享、跨操作系统平台、（生态高产） 3、turtle库的使用： turtle（海龟）库基本介绍：python语言的标准库之一，入门级的函数绘制库； python计算生态 = 标准库 + 第三方库 标准库：随解释器直接安装到操作系统中的功能模块 第三方库：需要经过安装才能使用的功能模块 库Library、包Package、模块Module，统称模块 turtle绘图窗体布局：最小单位是像素； 1turtle.setup(width, height, startx, starty) turtle空间坐标体系： 1turtle.goto(x, y) turtle角度坐标体系： 1turtle.seth(angle)#seth()只改变方向但不行进 RGB色彩体系： 1turtle.colormde(mode) 基本数据类型1、数字类型及操作：（整数类型、浮点数类型、复数类型、数值运算操作符、数值运算函数） 整数类型：可正可负，无取值范围限制；pow（x， y）-&gt;计算x的y次方；表示形式（十进制、二进制、八进制、十六进制）； 浮点数类型：带有小数点及小数的数字；浮点数间运算存在不确定尾数，不是bug；round（x， d）-&gt;对x四舍五入，d是小数截取位数；可采用科学计数法表示-&gt;使用字母e或E作为幂的符号； 复数类型：z.real获得实部；z.imag获得虚部； 数值运算操作符：+、-、*、/、//（整数除）； 数值运算函数： 2、天天向上的力量：（GRIT：perseverance and passion for long-term goals） pow(1.01, 365) = 37.78 pow(1.019, 365) = 962.89 GRIT，坚毅，对长期目标的持续激情及持久耐力； 3、字符串类型及操作; 字符串类型的表示：由一对单引号或一对双引号表示； 字符串是字符的有序序列，可以对其中的字符进行索引；字符串两个重要操作：索引（返回字符串中单个字符）和切片（返回字符串中一段字符子串）； 12#使用[M:N:K]根据步长对字符串切片“o一二三四五六七八九十” [::-1] “十九八七六五四三二一o” 转义符（\\）：表达特定字符的本意；转义符形成一些组合，表达一些不可打印的含义； 字符串（由0个或多个字符组成的有序字符序列）操作符： 字符串处理函数： 字符串处理方法： 123\"A, B, C\".split(\",\") #['A', 'B', 'C']\"= python= \".strip(\" =np\") #\"ytho\"\",\".join(\"12345\") #\"1, 2, 3, 4, 5\" 字符串类型的格式化：使用.format()方法 12#字符串中槽&#123;&#125;的默认顺序 = format()中参数的顺序\"&#123;&#125;:计算机&#123;&#125;的CPU占有率为&#123;&#125;%\".format(\"2018-10-10\", \"C\", 10) 4、time库（python中处理时间的标准库）的使用： 时间获取：time（）、ctime（）、gmtime（）； 时间格式化：strftime（）、strptime（）； %Y：年份，%m：月份，%B：月份名称，%b：月份名称缩写，%d：日期，%A：星期，%a：星期缩写， %H：小时（24h制），%h：小时（12h制），%p：上/下午，%M：分钟，%S：秒 程序计时：sleep（）、perf_counter（）； 程序控制结构1、程序的分支结构： 单分支结构：if 二分支结构：if-else（紧凑形式：&lt;表达式1&gt; if &lt;条件&gt; else &lt;表达式2&gt;） 多分支结构：if-elif-else 条件判断及组合：判断（&lt;、&lt;=、&gt;=、&gt;、==、！=），组合（and, or, not） 程序的异常处理：try-except-else-finally 2、程序的循环结构： 遍历循环（遍历某个结构形成的循环运行方式）：for &lt;循环变量&gt; in &lt;遍历结构&gt;: ​ &lt;语句块&gt; 从遍历结构中逐一提取元素，放在循环变量中；由保留字for和in组成，完整遍历所有元素后结束；每次循环，所获得元素放入循环变量，并执行一次语句块；应用：计数循环、字符串遍历循环、文件遍历循环； 无限循环（由条件控制的循环运行方式）： while &lt;条件&gt;： ​ &lt;语句块&gt; 反复执行语句块，直到条件不满足时结束； 循环控制保留字： break：跳出并结束当前整个循环，执行循环后的语句（仅跳出当前最内层循环）； continue：结束当次循环，继续执行后续次数循环； 循环的高级用法（与break有关）：循环与else 当循环没有被break语句退出时，执行else语句块； else语句块作为“正常”完成循环的奖励； 这里else的用法与异常处理中else用法相似； 3、random库（使用随机数的python标准库）的使用： 4、程序运行有80%的时间花在不到10%的代码上（二八法则）； 理解方法思维： 数学思维：找到公式，利用公式求解； 计算思维：抽象一种过程，用计算机自动化求解； 函数和代码复用1、函数的定义与使用： 函数的理解和定义： 函数是一段具有特定功能的、可重用的语句组； 函数是一种功能的抽象，一般函数表达特定功能； 两个作用：降低编程难度、代码复用； 函数是一段代码的表示：def &lt;函数名&gt;(&lt;参数（0个或多个）&gt;): ​ &lt;函数体&gt; ​ return &lt;返回值&gt; —函数定义时，所指定的参数是一种占位符； —函数定义后，如果不经过调用，不会被执行； —函数定义时，参数是输入、函数体是处理、结果是输出（IPO）； 函数的使用及调用过程： 调用是运行函数代码的方式：调用时要给出实际参数；实际参数替换定义中的参数；函数调用后得到返回值； 函数的参数传递： 参数个数：函数可以有参数，也可以没有，但必须保留括号； 可选参数传递：函数定义时可以为某些参数指定默认值，构成可选参数； def &lt;函数名&gt;(&lt;非可选参数&gt;, &lt;可选参数&gt;)： ​ &lt;函数体&gt; return &lt;返回值&gt; 可变参数传递：函数定义时可以设计可变数量参数，既不确定参数总数量； def &lt;函数名&gt;(&lt;参数&gt;, *b)： ​ &lt;函数体&gt; return &lt;返回值&gt; 参数传递的两种方式 ：函数调用时，参数可以按照位置或名称方式传递； 函数的返回值：（函数可以返回0个或多个结果） return保留字用来传递返回值； 函数可以有返回值，也可以没有，可以有return，也可以没有； return可以传递0个返回值，也可以传递任意多个返回值； 局部变量和全局变量：局部变量和全局变量是不同变量； —局部变量是函数内部的占位符，与全局变量可能重名但不同； —函数运算结束后，局部变量被释放； —可以使用global保留字在函数内部使用全局变量； 局部变量为组合数据类型且未创建，等同于全局变量；使用规则： —基本数据类型，无论是否重名，局部变量与全局变量不同； —可以通过global保留字在函数内部声明全局变量； —组合数据类型，如果局部变量未真实创建，则是全局变量； lambda函数（返回函数名作为结果）：lambda函数是一种匿名函数，即没有名字的函数；—使用lambda保留字定义，函数名是返回结果；—lambda函数用于定义简单的、能够在一行内表示的函数； &lt;函数名&gt; = lambda &lt;参数&gt; : &lt;表达式&gt; 等价于 def &lt;函数名&gt; (&lt;参数&gt;) : ​ &lt;函数体&gt; ​ return &lt;返回值&gt; 谨慎使用lambda函数： —lambda函数主要用作一些特定函数或方法的参数； —lambda函数有一些固定使用方式，建议逐步掌握； —一般情况，建议使用def定义的普通函数； 2、理解方法思维： 模块化思维：确定模块接口，封装功能； 规则化思维：抽象过程为规则，计算机自动执行； 化繁为简：将大功能变为小功能组合，分而治之； 3、代码复用与函数递归： 代码复用与模块化设计： 代码复用（把代码当成资源进行抽象）： —代码资源化：程序代码是一种用来表达计算的“资源”； —代码抽象化：使用函数等方法对代码赋予更高级别的定义； —代码复用：用一份代码在需要时可以被重复使用； 函数和对象是代码复用的两种主要形式； 模块化设计（分而治之）： —通过函数或对象封装将程序划分为模块及模块间的表达； —具体包括：主程序、子程序和子程序间关系； —分而治之：一种分而治之、分层抽象、体系化的设计思想； 模块内部紧耦合、模块之间松耦合； 函数递归（函数定义中调用自身的方式）：类似数学归纳法1） 递归是数学归纳法编程的一种体现； 两个关键特征：链条（计算过程存在递归链条）、基例（存在一个或多个不需要再次递归的基例）； 函数递归的调用过程： 递归的实现：函数 + 分支语句 —递归本身是一个函数，需要函数定义方式描述； —函数内部，采用分支语句对输入参数进行判断； —基例和链条，分别编写对应代码； 函数递归实例解析：字符串反转：s[::-1]，斐波那契数列，汉诺塔； 4、PyInstaller库（将.py源代码转换成无需源代码的可执行文件）使用：pyinstaller -F &lt;文件名.py&gt; 组合数据类型1、集合类型及操作： 集合类型定义：集合是多个元素的无序组合；—集合类型与数学中的集合概念一致；—集合元素之间无序，每个元素唯一，不存在相同元素；—集合元素不可更改，不能是可变数据类型；—集合用大括号{}表示，元素间用逗号分隔；—建立集合类型用{}或set();—建立空集合类型，必须使用set(); 集合操作符：6个操作符： 4 个增强操作符： 集合处理方法： 集合类型应用场景：包含关系比较、数据去重（集合类型所有元素无重复）； 2、序列类型及操作： 序列类型定义：序列是具有先后关系的一组元素；—序列是一维元素向量，元素类型可以不同；—类似数学元素序列：s0， S1, … , Sn-1;—元素间由序号引导，通过下标访问序列的特定元素；序列是一个基类类型（字符串类型、元组类型、列表类型）； 序列处理函数及方法：6个操作符： 5个函数和方法： 元组类型及操作：元组是序列类型的一种扩展；—元组是一种序列类型，一旦创建就不能被修改；—使用小括号（）或tuple（）创建，元素间用逗号，分隔；—可以使用或不使用小括号；元组继承序列类型的全部通用操作；元组因为创建后不能修改，因此没有特殊操作；使用或不使用小括号； 列表类型及操作：列表是序列类型的一种扩展，十分常用；—列表是一种序列类型，创建后可以随意被修改；—使用方括号[]或list（）创建，元素间用逗号，分隔；—可以使用或不使用小括号；方括号[]真正创建一个列表，赋值仅传递引用；列表类型操作函数和方法：序列类型应用场景： 元组用于元素不改变的应用场景，更多用于固定搭配场景（数据保护：如果不希望数据被程序所改变，转换成元组类型）； 列表更加灵活，它是常见的序列类型； 最主要作用：表示一组有序数据，进而操作它们； 3、字典类型及操作： 字典类型定义：理解”映射“：映射是一种键（索引）和值（数据）的对应；—字典类型是“映射”的体现；—键值对：键是数据索引的扩展；—字典是键值对的集合，键值对之间无序；—采用大括号{}和dict（）创建，键值对用冒号：表示；{&lt;键1&gt; : &lt;值1&gt;, &lt;键2&gt; : &lt;值2&gt;, …, &lt;键n&gt; : &lt;值ni&gt;}在字典变量中，通过键获得值：&lt;字典变量&gt; = {&lt;键1&gt; : &lt;值1&gt;, … , &lt;键n&gt; : &lt;值n&gt;}&lt;值&gt; = &lt;字典变量&gt; [&lt;键&gt;] &lt;字典变量&gt; [&lt;键&gt;] = &lt;值&gt;[] 用来向字典变量中索引或增加元素； 字典处理函数及方法： 字典类型应用场景：—映射无处不在，键值对无处不在；—例如：统计数据出现的次数，数据是键，次数是值；—最主要作用：表达键值对数据，进而操作它们； 4、jieba库（优秀的中文分词第三方库）的使用： jieba分词依靠中文词库：利用一个中文词库，确定汉字之间的关联概率；汉字间概率大的组成词组，形成分词结果；除了分词，用户还可以添加自定义的词组； 使用说明：精确模式（把文本精确的切分开，不存在冗余单词）；全模式（把文本中所有可能的词语都扫描出来，有冗余）；搜索引擎模式（在精确模式基础上，对长词再次切分）； 文件和数据格式化1、文件操作基础： 文件是数据的抽象和集合（展现形态：文本文件和二进制文件）； 文本文件：由单一特定编码组成的文件（txt、.py）； 二进制文件：直接由0和1组成，无统一的字符编码（.png、视频等）； 文件的打开关闭：打开-操作-关闭； 123#文件的打开 &lt;变量名&gt; = open(&lt;文件名&gt;, &lt;打开模式&gt;)#打开模式：只读（‘r’）、覆盖写（’w‘）、创建写（’x‘）、追加写（‘a’）、二进制文件模式（‘b’）、文本文件模式（‘t’）、与r/w/x/a一同使用，在原有功能基础上增加同时读写功能（‘+’）#文件的关闭 &lt;变量名&gt;.close() 文件的读取： 文件的写入： 2、自动化思维（数据和功能分离，数据驱动的自动进行）、接口化设计（格式化设计接口，清晰明了）； 3、一维数据格式化： 一维数据（由对等关系的有序或无序数据构成，采用线性方式组织）-对应列表、数组和集合等概念；二维数据（由多个一维数据构成，是一维数据的组合形式）-表格是典型的二维数据； 数据的操作周期：存储（存储格式）-表示（数据类型）-操作（操作方式）； 一维数据的表示： 如果数据间有序：使用列表类型； 如果数据间无序：使用集合类型； 一维数据的存储： 空格分隔（数据中不能存在空格）； 逗号分隔； 其他方式（使用其他符号或符号组合分隔，建议采用特殊符号）； 一维数据的处理： 将存储的数据读入程序 将程序表示的数据写入文件； 4、二维数据格式化： 二维数据的表示： 列表类型可以表达二维数据； 使用二维列表； CSV格式与二维数据的存储：CSV（Comma-Separated Values）数据存储格式： 每行一个一维数据，采用逗号分隔，无空行； 如果某个元素缺失，逗号仍要保留； 逗号为英文半角逗号，逗号与数据之间无额外空格； 二维数据的存储： 按行存或者按列存都可以，具体由程序决定； 一般索引习惯，先行后列； 二维数据的处理：for循环 + .split() 和 .join() 5、wordcloud库：是优秀的词云展示第三方库； 词云以词语为基本单位，更加直观和艺术的展示文本； 库基本使用： wordcloud.WordCloud()代表一个文本对应的词云； 可以根据文本中词语出现的频率等参数绘制词云； 绘制词云的形状、尺寸和颜色都可以设定； 配置参数、加载文本、输出文件； python的wordcloud默认字体不支持中文； 程序设计方法学 1、自顶向下的设计思维：分而治之；自底向上的执行思维：模块化集成； 2、计算思维：抽象问题的计算过程，利用计算机自动化求解； 3、用户体验：进度展示、异常处理等； 4、os库的基本使用： 123os.path.abspath(path)#返回path在当前系统中的绝对路径；os.getcwd()#返回程序的当前路径； 总结python基础语法： 基本数据类型：整数、浮点数、复数、字符串； 程序的控制结构：分支结构与异常处理、遍历循环、无限循环； 函数和代码复用：函数定义和使用、函数递归； 组合数据类型：集合类型、序列类型（元组和列表）、字典类型； 文件和数据格式化：文件的使用、一二维数据的表示存储和处理。 参考：MOOC北京理工大学嵩天老师课程笔记","comments":true,"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"SQL必知必会","date":"2019-03-22T06:22:36.000Z","path":"2019/03/22/SQL必知必会/","text":"SQL必知必会总结 About1、数据库是一个以某种有组织的方式存储的数据集合；表是一种结构化的文件，可用来存储某种特定类型的数据；模式 ：关于数据库和表的布局及特性的信息 ； 2、主键（primary key）：一列（或一组列），其值能够唯一标识表中每一行 ； 任意两行都不具有相同的主键值 ； 每一行都必须具有一个主键值（主键列不允许NULL值）； 主键列中的值不允许修改或更新； 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）； ​ 主键通常定义在表的一列上，但并不是必需这么做，也可以一起使用多个列作为主键。在使用多列作为主键时，上述条件必须应用到所有列， 所有列值的组合必须是唯一的（但单个列的值可以不唯一）； 3、SQL是结构化查询语言（Structured Query Language）的缩写，SQL是一种专门用来与数据库沟通的语言； 检索数据1、SQL语句不区分大小写 ； 检索单个列 SELECT prod_name FROM Products; 检索多个列 SELECT prod_id, prod_name, prod_price FROM Products; 检索所有列 SELECT * FROM Products; 检索不同的值 （ DISTINCT） SELECT DISTINCT vend_id FROM Products; 限制结果（LIMIT） SELECT prod_name FROM Products LIMIT 5; LIMIT 5 OFFSET 5 SELECT prod_name FROM Products LIMIT 5 OFFSET 5; 2、总结： 一般而言，除非你确实需要表中的每一列，否则最好别使用*通配符。虽然使用通配符能让你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能； 不能部分使用DISTINCT ：DISTINCT关键字作用于所有的列，不仅仅是跟在其后的那一列； LIMIT 5指示MySQL等DBMS返回不超过5行的数据，LIMIT 5 OFFSET 5 （LIMIT 5, 5）指示MySQL等DBMS返回从第5行起的5行数据。第一个数字是指从哪儿开始，第二个数字是检索的行数。第一个被检索的行是第0行，而不是第1行 ； 排序检索数据1、ORDER BY子句，根据需要排序检索出的数据； 排序数据 SELECT prod_name FROM Products ORDER BY prod_name; 按多个列排序 SELECT prod_id, prod_price, prod_name FROM Products ORDER BY prod_price, prod_name; 按列位置排序 SELECT prod_id, prod_price, prod_name FROM Products ORDER BY 2, 3; 指定排序方向 SELECT prod_id, prod_price, prod_name FROM Products ORDER BY prod_price DESC; 2、总结： ORDER BY子句的位置 ：在指定一条ORDER BY子句时，应该保证它是SELECT语句中最后一条子句。如果它不是最后的子句，将会出现错误消息； 通过非选择列进行排序： 通常，ORDER BY子句中使用的列将是为显示而选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的； 按列位置排序：指定的是选择列的相对位置而不是列名 ； 数据排序不限于升序排序（从A到Z），这只是默认的排序顺序。还可以使用ORDER BY子句进行降序（从Z到A）排序。为了进行降序排序，必须指定DESC关键字； 在多个列上降序排序： 如果想在多个列上进行降序排序，必须对每一列指定DESC关键字；（DESC是DESCENDING的缩写，与DESC相对的是ASC（或ASCENDING），升序是默认的 ）； 过滤数据1、WHERE子句指定搜索条件 ； 检查单个值 SELECT prod_name, prod_price FROM Products WHERE prod_price = 3.49; 检查单个值 SELECT prod_name, prod_price FROM Products WHERE prod_price &lt; 10; 不匹配检查 SELECT vend_id, prod_name FROM Products WHERE vend_id ！= ‘DLL01’; 范围值检查 SELECT prod_name, prod_price FROM Products WHERE prod_price BETWEEN 5 AND 10; 空值检查 SELECT prod_name FROM Products WHERE prod_price IS NULL; 2、总结： WHERE子句的位置 ：在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后，否则将会产生错误； 在使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用AND关键字分隔。BETWEEN匹配范围 中所有的值，包括指定的开始值和结束值； NULL和非匹配 ：通过过滤选择不包含指定值的所有行时，你可能希望返回含NULL值的行。但是这做不到。因为未知（unknown）有特殊的含义，数据库不知道它们是否匹配，所以在进行匹配过滤或非匹配过滤时，不会返回这些结果； 高级数据过滤1、为了进行更强的过滤控制，SQL允许给出多个WHERE子句。这些子句有两种使用方式，即以AND子句或OR子句的方式使用 ； 2、求值顺序 ： SQL（像多数语言一样）在处理OR操作符前，优先处理AND操作符。在WHERE子句中使用圆括号 ：任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符 ； 3、IN操作符 ：用来指定条件范围，范围中的每个条件都可以进行匹配。IN取一组由逗号分隔、括在圆括号中的合法值； 12345SELECT prod_name, prod_priceFROM ProductsWHERE vend_id IN ( &apos;DLL01&apos;, &apos;BRS01&apos; )ORDER BY prod_name;#IN操作符完成了与OR相同的功能 IN操作符优点为 ： 在有很多合法选项时，IN操作符的语法更清楚，更直观 ； 在与其他AND和OR操作符组合使用IN时，求值顺序更容易管理； IN操作符一般比一组OR操作符执行得更快； IN的最大优点是可以包含其他SELECT语句，能够更动态地建立WHERE子句； 4、NOT操作符：否定其后所跟的任何条件； 1234SELECT prod_nameFROM ProductsWHERE NOT vend_id = &apos;DLL01&apos;ORDER BY prod_name; 用通配符进行过滤1、LIKE操作符 ：为在搜索子句中使用通配符，必须使用LIKE操作符（后跟的搜索模式利用通配符匹配而不是简单的相等匹配进行比较 ） ；利用通配符，可以创建比较特定数据的搜索模式； 通配符搜索只能用于文本字段（串），非文本数据类型字段不能使用通配符搜索； 百分号（%）通配符 ：%表示任何字符出现任意次数； 除了能匹配一个或多个字符外，%还能匹配0个字符。%代表搜索模式中给定位置的0个、1个或多个字符。 注意NULL ：通配符%看起来像是可以匹配任何东西，但有个例外，这就是NULL； 123SELECT prod_id, prod_nameFROM ProductsWHERE prod_name LIKE &apos;Fish%&apos;; 下划线（_）通配符：只匹配单个字符，而不是多个字符； 通配符搜索一般比前面讨论的其他搜索要耗费更长的处理时间 ； —不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符； —在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的； —仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据； 创建计算字段1、计算字段：计算字段并不实际存在于数据库表中，计算字段是运行时在SELECT语句内创建的； 2、拼接字段 ： 拼接（concatenate）：将值联结到一起（将一个值附加到另一个值）构成单个值—concat()； 123SELECT CONCAT(TRIM(vend_name),&apos; (&apos;,TRIM(vend_country),&apos;)&apos;)#TRIM()---去掉左右两边空格FROM VendorsORDER BY vend_name; 别名（alias）是一个字段或值的替换名。别名用AS关键字赋予； 12345SELECT CONCAT(TRIM(vend_name),&apos; (&apos;,TRIM(vend_country),&apos;)&apos;)AS vend_titleFROM VendorsORDER BY vend_name; #计算字段之后跟了文本AS vend_title，它指示SQL创建一个包含指定计算结果的名为vend_title的计算字段，现在列名为vend_title，任何客户端应用都可以按名称引用这个列，就像它是一个实际的表列一样。 AS通常可选：AS关键字是可选的，不过最好使用它，这被视为一条最佳实践 ； 别名的其他用途：常见的用途包括在实际的表列名包含不合法的字符（如空格）时重新命名它，在原来的名字含混或容易误解时扩充它； 3、执行算术计算：计算字段的另一常见用途是对检索出的数据进行算术计算； 123SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_priceFROM OrderItemsWHERE order_num = 20008; 使用数据处理函数1、SQL也可以用函数来处理数据。函数一般是在数据上执行的，为数据的转换和处理提供了方便； 2、大多数SQL实现支持以下类型的函数： 用于处理文本字符串（如删除或填充值，转换值为大写或小写）的文本函数； 用于在数值数据上进行算术操作（如返回绝对值，进行代数运算）的数值函数； 用于处理日期和时间值并从这些值中提取特定成分（如返回两个日期之差，检查日期有效性）的日期和时间函数； 返回DBMS正使用的特殊信息（如返回用户登录信息）的系统函数； 文本处理函数 SELECT vend_name, UPPER(vend_name) AS vend_name_upcase 日期和时间处理函数 SELECT order_num FROM Orders WHERE YEAR(order_date) = 2012; 数值处理函数 SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法，SOUNDEX考虑了类似的发音字符和音节，使得能对字符串进行发音比较而不是字母比较 ； 123SELECT cust_name, cust_contactFROM CustomersWHERE SOUNDEX(cust_contact) = SOUNDEX(&apos;Michael Green&apos;) 汇总数据1、聚集函数：汇总数据而不用把它们实际检索出来，为此SQL提供了专门的函数。使用这些函数，SQL查询可用于检索数据，以便分析和报表生成； 聚集函数（aggregate function） 对某些行运行的函数，计算并返回一个值 ； AVG（）：返回某列的平均值—通过对表中行数计数并计算其列值之和，求得该列的平均值； 只用于单个列：AVG()只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个AVG()函数。 12SELECT AVG(prod_price) AS avg_priceFROM Products; COUNT（）：确定表中行的数目或符合特定条件的行的数目； COUNT()函数有两种使用方式： 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值； 使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值； 123456#利用COUNT(*)对所有行计数，不管行中各列有什么值SELECT COUNT(*) AS num_custFROM Customers;#COUNT(cust_email)对cust_email列中有值的行进行计数SELECT COUNT(cust_email) AS num_custFROM Customers; MAX（）：返回某列的最大值，要求指定列名 ； 123#MAX()函数忽略列值为NULL的行SELECT MAX(prod_price) AS max_priceFROM Products; MIN（）：返回某列的最小值，要求指定列名 ； 123#MIN()函数忽略列值为NULL的行SELECT MIN(prod_price) AS min_priceFROM Products; SUM（）：返回指定列值的和（总计）； 12345678#SUM()函数忽略列值为NULL的行SELECT SUM(quantity) AS items_orderedFROM OrderItemsWHERE order_num = 20005;#SUM()也可以用来合计计算值SELECT SUM(item_price*quantity) AS total_priceFROM OrderItemsWHERE order_num = 20005; 2、聚集不同值：只包含不同的值，指定DISTINCT参数； 1234SELECT AVG(DISTINCT prod_price) AS avg_priceFROM ProductsWHERE vend_id = &apos;DLL01&apos;;#DISTINCT不能用于COUNT(*)，DISTINCT必须使用列名 3、组合聚集函数： 12345SELECT COUNT(*) AS num_items,MIN(prod_price) AS price_min,MAX(prod_price) AS price_max,AVG(prod_price) AS price_avgFROM Products; 分组数据1、数据分组 ：使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算； 2、创建分组：使用SELECT语句的GROUP BY子句建立的； 123SELECT vend_id, COUNT(*) AS num_prodsFROM ProductsGROUP BY vend_id; GROUP BY子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组； 如果在GROUP BY子句中嵌套了分组，数据将在最后指定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）； GROUP BY子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子 句中指定相同的表达式。不能使用别名； 大多数SQL实现不允许GROUP BY列带有长度可变的数据类型（如文本或备注型字段）； 除聚集计算语句外，SELECT语句中的每一列都必须在GROUP BY子句中给出 ； 如果分组列中包含具有NULL值的行，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组； GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前 ； 3、过滤分组 ：HAVING子句 ，WHERE过滤行，而HAVING过滤分组； 1234SELECT cust_id, COUNT(*) AS ordersFROM OrdersGROUP BY cust_idHAVING COUNT(*) &gt;= 2; HAVING和WHERE的差别：WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤； 123456#第一行是使用了聚集函数的基本SELECT语句，WHERE子句过滤所有prod_price至少为4的行，然后按vend_id分组数据，HAVING子句过滤计数为2或2以上的分组。SELECT vend_id, COUNT(*) AS num_prodFROM ProductsWHERE prod_price &gt;= 4GROUP BY vend_idHAVING COUNT(*) &gt;= 2 使用HAVING和WHERE：HAVING与WHERE非常类似，如果不指定GROUP BY，则大多数DBMS会同等对待它们。不过，使用HAVING时应该结合GROUP BY子句，而WHERE子句用于标准的行级过滤； 4、分组和排序：GROUP BY和ORDER BY经常完成相同的工作，但它们非常不同； ORDER BY GROUP BY 对产生的输出排序 对行分组，但输出可能不是分组的顺序 任意列都可以使用（甚至非选择的列也可以使用） 只可能使用选择列表达式，而且必须使用每个选择列表达式 不一定需要 如果与聚集函数一起使用列（或表达式），则必须使用 不要忘记ORDER BY：一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据； 12345SELECT order_num, COUNT(*) AS itemsFROM OrderItemsGROUP BY order_numHAVING COUNT(*) &gt;= 3ORDER BY items, order_num; 5、SELECT子句顺序： 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 使用子查询1、子查询：嵌套在其他查询中的查询； 2、利用子查询进行过滤： 1234567SELECT cust_name, cust_contactFROM CustomersWHERE cust_id IN (SELECT cust_idFROM OrdersWHERE order_num IN (SELECT order_numFROM OrderItemsWHERE prod_id = &apos;RGAN01&apos;)); 在WHERE子句中使用子查询能够编写出功能很强且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多的子查询； 只能是单列：作为子查询的SELECT语句只能查询单个列。企图检索多个列将返回错误； 子查询和性能：这里给出的代码有效，并且获得了所需的结果。但是，使用子查询并不总是执行这类数据检索的最有效方法； 3、作为计算字段使用子查询：使用子查询的另一方法是创建计算字段； 12345678#不是解决这种数据检索的最有效方法SELECT cust_name,cust_state,(SELECT COUNT(*)FROM OrdersWHERE Orders.cust_id = Customers.cust_id) AS ordersFROM CustomersORDER BY cust_name; 联结表1、联结：SQL最强大的功能之一就是能在数据查询的执行中联结（join）表。联结是利用SQL的SELECT能执行的最重要的操作； 关系表：相同的数据出现多次决不是一件好事，这是关系数据库设计的基础。关系表的设计就是要把信息分解成多个表，一类数据一个表。各表通过某些共同的值互相关联（所以才叫关系数据库）； 关系数据可以有效地存储，方便地处理。因此，关系数据库的可伸缩性远比非关系数据库要好。可伸缩（scale）： 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称为可伸缩性好（scale well）； 如果数据存储在多个表中，怎样用一条SELECT语句就检索出数据呢？（使用联结）； 联结是一种机制，用来在一条SELECT语句中关联表，因此称为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行 ； 2、创建联结：指定要联结的所有表以及关联它们的方式即可 ； 123SELECT vend_name, prod_name, prod_priceFROM Vendors, ProductsWHERE Vendors.vend_id = Products.vend_id; 3、WHERE子句的重要性：在联结两个表时，实际要做的是将第一个表中的每一行与第二个表中的每一行配对。WHERE子句作为过滤条件，只包含那些匹配给定条件（这里是联结条件）的行。没有WHERE子句， 第一个表中的每一行将与第二个表中的每一行配对，而不管它们逻辑上是否能配在一起； 笛卡儿积（cartesian product）：由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数； 123SELECT vend_name, prod_name, prod_priceFROM Vendors, Products;#要保证所有联结都有WHERE子句，否则DBMS将返回比想要的数据多得多的数据 内联结（inner join）：目前为止使用的联结称为等值联结（equijoin），它基于两个表之间的相等测试，这种联结也称为内联结； 123SELECT vend_name, prod_name, prod_priceFROM Vendors INNER JOIN ProductsON Vendors.vend_id = Products.vend_id; 4、联结多个表 ：SQL不限制一条SELECT语句中可以联结的表的数目。创建联结的基本规则也相同，首先列出所有表，然后定义表之间的关系； 12345SELECT prod_name, vend_name, prod_price, quantityFROM OrderItems, Products, VendorsWHERE Products.vend_id = Vendors.vend_idAND OrderItems.prod_id = Products.prod_idAND order_num = 20007; 性能考虑：DBMS在运行时关联指定的每个表，以处理联结。这种处理可能非常耗费资源，因此应该注意，不要联结不必要的表。联结的表越多，性能下降越厉害； 执行任一给定的SQL操作一般不止一种方法。很少有绝对正确或绝对错误的方法。性能可能会受操作类型、所使用的DBMS、表中数据量、是否存在索引或键等条件的影响。 创建高级联结1、使用表别名：SQL除了可以对列名和计算字段使用别名，还允许给表名起别名； 缩短SQL语句； 允许在一条SELECT语句中多次使用相同的表； 1234567#表别名不仅能用于WHERE子句，还可以用于SELECT的列表、ORDER BY子句以及其他语句部分#表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户端。SELECT cust_name, cust_contactFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id = O.cust_idAND OI.order_num = O.order_numAND prod_id = &apos;RGAN01&apos;; 2、使用不同类型的联结： 自联结： 12345#许多DBMS处理联结远比处理子查询快得多SELECT c1.cust_id, c1.cust_name, c1.cust_contactFROM Customers AS c1, Customers AS c2WHERE c1.cust_name = c2.cust_nameAND c2.cust_contact = &apos;Jim Jones&apos;; 自然联结：排除多次出现，使每一列只返回一次 ； 123456SELECT C.*, O.order_num, O.order_date,OI.prod_id, OI.quantity, OI.item_priceFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id = O.cust_idAND OI.order_num = O.order_numAND prod_id = &apos;RGAN01&apos;; 外联结：联结包含了那些在相关表中没有关联行的行； 1234#在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）SELECT Customers.cust_id, Orders.order_numFROM Customers LEFT OUTER JOIN OrdersON Customers.cust_id = Orders.cust_id; 3、 使用带聚集函数的联结 ： 1234567891011SELECT Customers.cust_id,COUNT(Orders.order_num) AS num_ordFROM Customers INNER JOIN OrdersON Customers.cust_id = Orders.cust_idGROUP BY Customers.cust_id;#使用左外部联结来包含所有顾客，甚至包含那些没有任何订单的顾客SELECT Customers.cust_id,COUNT(Orders.order_num) AS num_ordFROM Customers LEFT OUTER JOIN OrdersON Customers.cust_id = Orders.cust_idGROUP BY Customers.cust_id; 4、使用联结和联结条件：联结及其使用的要点； 注意所使用的联结类型。一般我们使用内联结，但使用外联结也有效； 保证使用正确的联结条件（不管采用哪种语法），否则会返回不正确的数据；。 应该总是提供联结条件，否则会得出笛卡儿积； 在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前分别测试每个联结。这会使故障排除更为简单； 组合查询1、组合查询：多数SQL查询只包含从一个或多个表中返回数据的单条SELECT语句。但是，SQL也允许执行多个查询（多条SELECT语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）； 主要有两种情况需要使用组合查询： 在一个查询中从不同的表返回结构数据； 对一个表执行多个查询，按一个查询返回数据； 2、创建组合查询：可用UNION操作符来组合数条SQL查询。利用UNION，可给出多条SELECT语句，将它们的结果组合成一个结果集； 使用UNION ：给出每条SELECT语句，在各条语句之间放上关键字UNION ； 1234567SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN (&apos;IL&apos;,&apos;IN&apos;,&apos;MI&apos;)UNIONSELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_name = &apos;Fun4All&apos;; UNION规则： UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合四条SELECT语句，将要使用三个UNION关键字）； UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）； 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）； 包含或取消重复的行：使用UNION时，重复的行会被自动取消；如果想返回所有的匹配行，可使用UNION ALL而不是UNION； 对组合查询结果排序：在用UNION组合查询时，只能使用一条ORDER BY子句，它必须位于最后一条SELECT语句之后； 12345678SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN (&apos;IL&apos;,&apos;IN&apos;,&apos;MI&apos;)UNIONSELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_name = &apos;Fun4All&apos;ORDER BY cust_name, cust_contact; 插入数据1、数据插入：INSERT用来将行插入（或添加）到数据库表，插入有几种方式 ； 插入完整的行； 1234567#各列必须以它们在表定义中出现的次序填充，不安全，应该尽量避免使用INSERT INTO CustomersVALUES(&apos;1000000006&apos;,&apos;Toy Land&apos;,&apos;123 Any Street&apos;,&apos;New York&apos;,&apos;NY&apos;,&apos;11111&apos;,&apos;USA&apos;,NULL,NULL); #安全INSERT INTO Customers(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country, cust_contact,cust_email)VALUES(&apos;1000000006&apos;,&apos;Toy Land&apos;,&apos;123 Any Street&apos;,&apos;New York&apos;,&apos;NY&apos;,&apos;11111&apos;,&apos;USA&apos;,NULL,NULL); 插入行的一部分：使用这种语法，还可以省略列，这表示可以只给某些列提供值，给其他列不提供值； 12INSERT INTO Customers(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)VALUES(&apos;1000000006&apos;,&apos;Toy Land&apos;,&apos;123 Any Street&apos;,&apos;New York&apos;,&apos;NY&apos;,&apos;11111&apos;,&apos;USA&apos;); 如果表的定义允许，则可以在INSERT操作中省略某些列。省略的列必须满足以下某个条件： 该列定义为允许NULL值（无值或空值）； 在表定义中给出默认值。这表示如果不给出值，将使用默认值 ； 插入检索出的数据：将SELECT语句的结果插入表中，这就是所谓的INSERT SELECT。顾名思义，它是由一条INSERT语句和一条SELECT语句组成的； 1234567#这条语句将插入多少行呢？这依赖于CustNew表有多少行INSERT INTO Customers( cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state, cust_zip,cust_country)SELECT cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state, cust_zip,cust_countryFROM CustNew; INSERT通常只插入一行。要插入多行，必须执行多个INSERT语句。INSERT SELECT是个例外，它可以用一条INSERT插入多行，不管SELECT语句返回多少行，都将被INSERT插入； 2、从一个表复制到另一个表 ：使用SELECT INTO语句。与INSERT SELECT将数据添加到一个已经存在的表不同，SELECT INTO将数据复制到一个新表（有的DBMS可以覆盖已经存在的表，这依赖于所使用的具体DBMS）； INSERT SELECT与SELECT INTO：它们之间的一个重要差别是前者导出数据，而后者导入数据 ； 123#这条语句创建一个名为CustCopy的新表，并把Customers表的整个内容复制到新表中。CREATE TABLE CustCopy ASSELECT * FROM Customers; 更新和删除数据1、更新数据：更新（修改）表中的数据，可以使用UPDATE语句。有两种使用UPDATE的方式； 基本的UPDATE语句由三部分组成：要更新的表 、列名和它们的新值、确定要更新哪些行的过滤条件； 更新表中的特定行； 123456UPDATE CustomersSET cust_contact = &apos;Sam Roberts&apos;,cust_email = &apos;sam@toyland.com&apos;WHERE cust_id = &apos;1000000006&apos;#要删除某个列的值，可设置它为NULL（假如表定义允许NULL值）#其中NULL用来去除cust_email列中的值。这与保存空字符串很不同（空字符串用&apos;&apos;表示，是一个值），而NULL表示没有值 更新表中的所有行；（不加where子句） 2、删除数据 ： 从一个表中删除（去掉）数据，使用DELETE语句。有两种使用DELETE的方式； 从表中删除特定的行； 123#DELETE不需要列名或通配符。DELETE删除整行而不是删除列DELETE FROM CustomersWHERE cust_id = &apos;1000000006&apos;; 删除表的内容而不是表：DELETE语句从表中删除行，甚至是删除表中所有行。但是，DELETE不删除表本身； 更快的删除：如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，而速度更快（因为不记录数据的变动）； 从表中删除所有行； 3、更新和删除的指导原则 ： 除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句 ； 保证每个表都有主键（如果忘记这个内容，请参阅第12课），尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）； 在UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确； 创建和操纵表1、创建表：使用SQL的CREATE TABLE语句 ； 表创建基础： 12345678CREATE TABLE Products(prod_id CHAR(10) NOT NULL,vend_id CHAR(10) NOT NULL,prod_name CHAR(254) NOT NULL,prod_price DECIMAL(8,2) NOT NULL,prod_desc VARCHAR(1000) NULL); 使用NULL值：主键和NULL值— 主键是其值唯一标识表中每一行的列。只有不允许NULL值的列可作为主键，允许NULL值的列不能作为唯一标识 ； 指定默认值：用关键字DEFAULT指定； 12345678CREATE TABLE OrderItems(order_num INTEGER NOT NULL,order_item INTEGER NOT NULL,prod_id CHAR(10) NOT NULL,quantity INTEGER NOT NULL DEFAULT 1,item_price DECIMAL(8,2) NOT NULL); 2、更新表：使用ALTER TABLE语句； 1234ALTER TABLE VendorsADD vend_phone CHAR(20);ALTER TABLE VendorsDROP COLUMN vend_phone; 3、删除表：使用DROP TABLE语句； 1DROP TABLE CustCopy; 4、重命名表 ：使用RENAME语句，要求指定旧表名和新表名； 使用视图1、视图：视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询； 视图的一些常见应用 ： 重用SQL语句； 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道其基本查询细节； 使用表的一部分而不是整个表； 保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限 ； 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据； 视图仅仅是用来查看存储在别处数据的一种设施。视图本身不包含数据，因此返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据； 视图的规则和限制： 与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）； 对于可以创建的视图数目没有限制； 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。所允许的嵌套层数在不同的DBMS中有所不同（嵌套视图可能会严重降低查询的性能，因此在产品环境中使用之前，应该对其进行全面测试）； 视图不能索引，也不能有关联的触发器或默认值； 2、 创建视图：用CREATE VIEW语句来创建 ，只能用于创建不存在的视图； ​ 删除视图，可以使用DROP语句，其语法为DROP VIEW viewname；覆盖（或更新）视图，必须先删除它，然后再重新创建； 利用视图简化复杂的联结 ： 123456#创建一个名为ProductCustomers的视图，它联结三个表CREATE VIEW ProductCustomers ASSELECT cust_name, cust_contact, prod_idFROM Customers, Orders, OrderItemsWHERE Customers.cust_id = Orders.cust_idAND OrderItems.order_num = Orders.order_num; 用视图重新格式化检索出的数据： 1234CREATE VIEW VendorLocations AS SELECT CONCAT(vend_name,&apos;(&apos;,RTRIM(vend_country),&apos;)&apos;) AS vend_titleFROM Vendors 用视图过滤不想要的数据 ： 1234CREATE VIEW CustomerEMailList ASSELECT cust_id, cust_name, cust_emailFROM CustomersWHERE cust_email IS NOT NULL; 使用视图与计算字段： 1234567CREATE VIEW OrderItemsExpanded ASSELECT order_num,prod_id,quantity,item_price,quantity*item_price AS expanded_priceFROM OrderItems; ​ 视图可极大地简化复杂数据的处理； 总结：视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种封装SELECT语句的层次，可用来简化数据处理，重新格式化或保护基础数据； 使用存储过程1、存储过程 ：存储过程就是为以后使用而保存的一条或多条SQL语句。可将其视为批文件，虽然它们的作用不仅限于批处理； 2、为什么要使用存储过程： 通过把处理封装在一个易用的单元中，可以简化复杂的操作； 由于不要求反复建立一系列处理步骤，因而保证了数据的一致性。如果所有开发人员和应用程序都使用同一存储过程，则所使用的代码都是相同的；（防止错误） 简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，那么只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化 ；（安全性） 3、执行存储过程 ：EXECUTE，EXECUTE接受存储过程名和需要传递给它的任何参数； 12345#执行一个名为AddNewProduct的存储过程，将一个新产品添加到Products表中EXECUTE AddNewProduct( &apos;JTS01&apos;,&apos;Stuffed Eiffel Tower&apos;,6.49,&apos;Plush stuffed toy with the text LaTour Eiffel in red white and blue&apos; ); 存储过程所完成的工作： 验证传递的数据，保证所有4个参数都有值 ； 生成用作主键的唯一ID； 将新产品插入Products表，在合适的列中存储生成的主键和传递的数据； 4、创建存储过程：CREATE PROCEDURE； 管理事务处理1、事务处理（transaction processing）：通过确保成批的SQL操作要么完全执行，要么完全不执行，来维护数据库的完整性； 事务处理是一种机制，用来管理必须成批执行的SQL操作，保证数据库不包含不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止，它们要么完全执行，要么完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表；如果发生错误，则进行回退（撤销），将数据库恢复到某个已知且安全的状态； 2、使用事务处理时，有几个反复出现的关键词： 事务（transaction）指一组SQL语句； 回退（rollback）指撤销指定SQL语句的过程； 提交（commit）指将未存储的SQL语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），可以对它发布回退（与回退整个事务处理不同）； 事务处理用来管理INSERT、UPDATE和DELETE语句。不能回退SELECT语句（回退SELECT语句也没有必要），也不能回退CREATE或DROP操作。事务处理中可以使用这些语句，但进行回退时，这些操作也不撤销； 3、控制事务处理：管理事务的关键在于将SQL语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退； 1START TRANSACTION COMMITT用于保存更改，ROLLBACK用于撤销； 使用ROLLBACK； 使用COMMIT； 使用保留点：要支持回退部分事务，必须在事务处理块中的合适位置放置占位符。这样，如果需要回退，可以回退到某个占位符。 在SQL中，这些占位符称为保留点； 创建占位符，可使用SAVEPOINT语句，SAVEPOINT delete1； 总结：保留点越多越好—可以在SQL代码中设置任意多的保留点，越多越好。为什么呢？因为保留点越多，你就越能灵活地进行回退； 使用游标1、游标（cursor）：有时，需要在检索出来的行中前进或后退一行或多行，这就是游标的用途所在； 游标（cursor）是一个存储在DBMS服务器上的数据库查询， 它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据； 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改； 2、使用游标： 在使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句和游标选项 ； 一旦声明，就必须打开游标以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来； 对于填有数据的游标，根据需要取出（检索）各行； 在结束游标使用时，必须关闭游标，可能的话，释放游标（依赖于具体的DBMS）； 3、创建游标 ：使用DECLARE语句创建游标； 1234DECLARE CustCursor CURSORFORSELECT * FROM CustomersWHERE cust_email IS NULL 4、使用游标：使用OPEN CURSOR语句打开游标 ； 1OPEN CURSOR CustCursor 在处理OPEN CURSOR语句时，执行查询，存储检索出的数据以供浏览和滚动； 现在可以用FETCH语句访问游标数据了。FETCH指出要检索哪些行，从何处检索它们以及将它们放于何处（如变量名）； 5、关闭游标：CLOSE CustCursor； 高级SQL特性1、高级数据处理特性：约束、索引和触发器； 2、约束（constraint）：管理如何插入或处理数据库数据的规则； 主键： 1234567CREATE TABLE Vendors(vend_id CHAR(10) NOT NULL PRIMARY KEY,vend_name CHAR(50) NOT NULL);ALTER TABLE VendorsADD CONSTRAINT PRIMARY KEY (vend_id); 外键 ： 12345678910#外键有助防止意外删除CREATE TABLE Orders(order_num INTEGER NOT NULL PRIMARY KEY,order_date DATETIME NOT NULL,cust_id CHAR(10) NOT NULL REFERENCES Customers(cust_id));ALTER TABLE OrdersADD CONSTRAINTFOREIGN KEY (cust_id) REFERENCES Customers (cust_id); 唯一约束（UNIQUE）：唯一约束用来保证一列（或一组列）中的数据是唯一的。它们类似于主键，但存在以下重要区别： 表可包含多个唯一约束，但每个表只允许一个主键； 唯一约束列可包含NULL值； 唯一约束列可修改或更新； 唯一约束列的值可重复使用； 与主键不一样，唯一约束不能用来定义外键； 检查约束：用来保证一列（或一组列）中的数据满足一组指定的条件； 1234567#对OrderItems表施加了检查约束，它保证所有物品的数量大于0CREATE TABLE OrderItems(prod_id CHAR(10) NOT NULL,quantity INTEGER NOT NULL CHECK (quantity &gt; 0)); ADD CONSTRAINT CHECK (gender LIKE &apos;[MF]&apos;) 3、索引： 用来排序数据以加快搜索和排序操作的速度，在一个或多个列上定义索引，使DBMS保存其内容的一个排过序的列表，在定义了索引后，DBMS以使用书的索引类似的方法使用它。DBMS搜索排过序的索引，找出匹配的位置，然后检索这些行 ； 索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。在执行这些操作时，DBMS必须动态地更新索引； 索引数据可能要占用大量的存储空间； 并非所有数据都适合做索引。取值不多的数据（如州）不如具有更多可能值的数据（如姓或名），能通过索引得到那么多的好处； 索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能适合做索引； 可以在索引中定义多个列（例如，州加上城市）。这样的索引仅在以州加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处； 索引用CREATE INDEX语句创建，索引必须唯一命名 ： 123#在Products表的产品名列上创建一个简单的索引CREATE INDEX prod_name_indON PRODUCTS (prod_name); 检查索引：索引的效率随表数据的增加或改变而变化。许多数据库管理员发现，过去创建的某个理想的索引经过几个月的数据处理后可能变得不再理想 了。最好定期检查索引，并根据需要对索引进行调整； 4、触发器：是特殊的存储过程，它在特定的数据库活动发生时自动执行。触发器可以与特定表上的INSERT、UPDATE和DELETE操作（或组合）相关联； 与存储过程不一样（存储过程只是简单的存储SQL语句），触发器与单个的表相关联。与Orders表上的INSERT操作相关联的触发器只在Orders表中插入行时执行。类似地，Customers表上的INSERT和UPDATE操作的触发器只在表上出现这些操作时执行； 触发器的一些常见用途： 保证数据一致。例如，在INSERT或UPDATE操作中将所有州名转换为大写； 基于某个表的变动在其他表上执行活动。例如，每当更新或删除一行时将审计跟踪记录写入某个日志表； 进行额外的验证并根据需要回退数据。例如，保证某个顾客的可用资金不超限定，如果已经超出，则阻塞插入； 计算列的值或更新时间戳； 123456789#创建一个触发器，它对所有INSERT和UPDATE操作，将Customers表中的cust_state列转换为大写CREATE TRIGGER customer_stateAFTER INSERT OR UPDATEFOR EACH ROWBEGINUPDATE CustomersSET cust_state = Upper(cust_state)WHERE Customers.cust_id = :OLD.cust_idEND; 约束比触发器更快：一般来说，约束的处理比触发器快，因此在可能的时候，应该尽量使用约束； 5、数据库安全：任何安全系统的基础都是用户授权和身份确认。这是一种处理，通过这种处理对用户进行确认，保证他是有权用户，允许执行他要执行的操作。有的DBMS为此结合使用了操作系统的安全措施，而有的维护自己的用户及密码列表，还有一些结合使用外部目录服务服务器； 一般说来，需要保护的操作有： 对数据库管理功能（创建表、更改或删除已存在的表等）的访问； 对特定数据库或表的访问； 访问的类型（只读、对特定列的访问等）； 仅通过视图或存储过程对表进行访问； 创建多层次的安全措施，从而允许多种基于登录的访问和控制 ； 限制管理用户账号的能力； 安全性使用SQL的GRANT和REVOKE语句来管理，不过，大多数DBMS提供了交互式的管理实用程序，这些实用程序在内部使用GRANT和REVOKE语句 ； 总结：约束是实施引用完整性的重要部分，索引可改善数据检索的性能，触发器可以用来执行运行前后的处理，安全选项可用来管理数据访问。 脚本链接：https://pan.baidu.com/s/1BM1Z68UuLp73cLIrqjvfjw 提取码：5cer ​ ​ ​ ​ ​ ​","comments":true,"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"设计模式-观察者模式","date":"2019-03-18T02:08:53.000Z","path":"2019/03/18/设计模式-观察者模式/","text":"简单的说模式就是一种惯性的思维方式，用于解决同一类问题。 About模式：我们处理大量问题时，在很多不同的问题中重复出现的一种性质，它使得我们可以使用一种方法来描述问题实质并用本质上相同，但细节永不会重复的方法去解决，这种性质就叫模式。简单的说模式就是一种惯性的思维方式，用于解决同一类问题； 观察者模式（Observer）：何谓观察者模式？观察者模式定义了对象之间的一对多依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。 在这里，发生改变的对象称之为观察目标，而被通知的对象称之为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，所以么可以根据需要增加和删除观察者，使得系统更易于扩展。 所以观察者提供了一种对象设计，让主题和观察者之间以松耦合的方式结合。 简单例子观察者模式具备：事件的源、事件对象、事件处理对象； 以西游记为例，唐僧就是事件源，孙悟空、猪八戒、沙僧都是事件处理对象，事件对象包含有关事件和事件的源信息（就是记录唐僧发生事件的信息）； 先写事件对象类： TangEvent（记录唐僧发生事件的信息）： 1234567891011public class TangEvent &#123; private String eventStr; public TangEvent() &#123; &#125; public TangEvent(String eventStr) &#123; this.eventStr = eventStr; &#125; public String getEventStr() &#123; return eventStr; &#125;&#125; 接着写可以处理唐僧发生事件的接口类（Apprentice），只要是唐僧的徒弟就可以处理唐僧发生的事件，徒弟的功能就是观察唐僧看是否有事件需要处理： 123public interface Apprentice &#123; public void lookTS(TangEvent e);&#125; 再写可以处理事件的具体徒弟类，实现徒弟接口： 孙悟空实现类： 12345678910public class SunApprentice implements Apprentice &#123; @Override public void lookTS(TangEvent e) &#123; if(\"白骨精\".equals(e.getEventStr())) &#123; System.out.println(\"三打白骨精!\"); &#125; else if(\"女儿国王\".equals(e.getEventStr())) &#123; System.out.println(\"全凭师父定力！\"); &#125; &#125;&#125; 猪八戒实现类： 12345678910public class ZhuApprentice implements Apprentice &#123; @Override public void lookTS(TangEvent e) &#123; if(\"白骨精\".equals(e.getEventStr())) &#123; System.out.println(\"白骨精不是妖怪!\"); &#125; else if(\"女儿国王\".equals(e.getEventStr())) &#123; System.out.println(\"将师父留在女儿国吧！\"); &#125; &#125;&#125; 沙僧实现类： 12345678910public class ShaApprentice implements Apprentice &#123; @Override public void lookTS(TangEvent e) &#123; if(\"白骨精\".equals(e.getEventStr())) &#123; System.out.println(\"千万别误伤好人!\"); &#125; else if(\"女儿国王\".equals(e.getEventStr())) &#123; System.out.println(\"担心师父在女儿国王那有事！\"); &#125; &#125;&#125; 写事件源类（三要素：私有的监听者列表，公有的向监听者列表添加监听者的方法，公有的发生事情的方法）： 12345678910111213public class Tang &#123; private List&lt;Apprentice&gt; list = new ArrayList&lt;Apprentice&gt;();//私有的监听者列表 public void addTangListener(Apprentice apprentice) &#123;//公有的向监听者列表添加监听者的方法 this.list.add(apprentice); &#125; public void tangAction(String s) &#123;//公有的发生事情的方法 TangEvent tangEvent = new TangEvent(s); for(int i = 0; i &lt; this.list.size(); i++) &#123; Apprentice apprentice = this.list.get(i); apprentice.lookTS(tangEvent); &#125; &#125;&#125; 最后写一个Run类，事件源添加监听者实现类的实例： 1234567891011121314public class Run &#123; public static void main(String[] args) &#123; Tang tang = new Tang(); SunApprentice sun = new SunApprentice(); ZhuApprentice zhu = new ZhuApprentice(); ShaApprentice sha = new ShaApprentice(); //事件源加监听者实现类的实例 tang.addTangListener(sun); tang.addTangListener(zhu); tang.addTangListener(sha); tang.tangAction(\"白骨精\"); tang.tangAction(\"女儿国王\"); &#125;&#125; 至此，一个简单的观察者模式小例子完成。其实，在java中，我们不必像上面那样全都需要自己手动写，最后那个Run才需要我们自己完成。 事件源添加监听者接口实例四种方法： 1、自己加自己 2、自己加别人（实现接口） 3、自己加别人（适配器） 4、参数匿名类（适配器） 以Java Swing为例，先看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class MyFrame extends JFrame implements MouseListener &#123; private JPanel bodyPanel = null; private JButton b1 = null; private JButton b2 = null; private JButton b3 = null; private JButton b4 = null; private void init() &#123; this.bodyPanel = (JPanel)this.getContentPane(); this.bodyPanel.setLayout(new GridLayout(2, 2)); this.b1 = new JButton(\"b1\"); this.b1.addMouseListener(this);//自己加自己 this.bodyPanel.add(this.b1); this.b2 = new JButton(\"b2\"); MyListener1 myListener1 = new MyListener1(); this.b2.addMouseListener(myListener1);//自己加别人（实现接口） this.bodyPanel.add(this.b2); this.b3 = new JButton(\"b3\"); this.b3.addMouseListener(new MyListener2());//自己加别人（适配器） this.bodyPanel.add(this.b3); this.b4 = new JButton(\"b4\"); this.b4.addMouseListener(new MouseAdapter() &#123;//参数匿名类（适配器） public void mouseEntered(MouseEvent e) &#123; b4.setBackground(Color.BLACK); &#125; @Override public void mouseExited(MouseEvent e) &#123; b4.setBackground(Color.ORANGE); &#125; &#125;); this.bodyPanel.add(this.b4); this.setBounds(10, 10, 400, 400); this.setTitle(\"监听者模式\"); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public MyFrame() &#123; this.init(); &#125; public static void main(String[] args) &#123; MyFrame frame = new MyFrame(); frame.setVisible(true); &#125; @Override public void mouseClicked(MouseEvent e) &#123; &#125; @Override public void mousePressed(MouseEvent e) &#123; &#125; @Override public void mouseReleased(MouseEvent e) &#123; &#125; @Override public void mouseEntered(MouseEvent e) &#123; if(e.getSource() == this.b1) &#123; this.b1.setBackground(Color.RED); this.b4.setBackground(Color.BLUE); &#125; &#125; @Override public void mouseExited(MouseEvent e) &#123; if(e.getSource() == this.b1) &#123; this.b1.setBackground(Color.BLUE); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728public class MyListener1 implements MouseListener &#123; @Override public void mouseClicked(MouseEvent e) &#123; &#125; @Override public void mousePressed(MouseEvent e) &#123; &#125; @Override public void mouseReleased(MouseEvent e) &#123; &#125; @Override public void mouseEntered(MouseEvent e) &#123; JButton b2 = (JButton)e.getSource(); b2.setBackground(Color.BLUE); &#125; @Override public void mouseExited(MouseEvent e) &#123; JButton b2 = (JButton)e.getSource(); b2.setBackground(Color.GREEN); &#125;&#125; 12345678910111213public class MyListener2 extends MouseAdapter &#123; @Override public void mouseEntered(MouseEvent e) &#123; JButton b3 = (JButton)e.getSource(); b3.setBackground(Color.YELLOW); &#125; @Override public void mouseExited(MouseEvent e) &#123; JButton b3 = (JButton)e.getSource(); b3.setBackground(Color.PINK); &#125;&#125; 从代码也可以看出，适配器里面其实是一些空实现的方法，可以避免代码出现过多的空方法。 参考文章：http://cmsblogs.com/?p=3396#7Observer","comments":true,"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"零基础入门C语言","date":"2019-03-09T02:31:51.000Z","path":"2019/03/09/C语言入门/","text":"轻松入门C语言，通俗易懂的小例子理解C语言的三大结构 About面向对象和面向过程 面向过程就是人看待事物的眼光和思想，关注于步骤； 面向对象是一种对现实世界理解和抽象的方法； 面向过程—&gt;怎么做、面向对象—&gt;谁在做； 学习C语言的方法（其他语言类似） 入门：先了解背景、市场占有率、这门语言主要用途、前景如何、哪个公司发明； 最小单元：常量、变量、数据类型； 次小单元：运算符、表达式； 结构：业务逻辑（顺序结构、分支结构、循环结构）； 高级部分：数组、函数； 特征（语言所特有部分）：指针； 基础部分程序的入门 程序：做一件事情的过程，作用：计算机模拟现实生活，从而达到降低成本，提高效率的效果； 计算机中的程序：为了让计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合； 算法就是对解决问题的方法的描述，算法是描述、程序是执行； 算法固性：有穷性（步骤有限）、确定性（步骤清晰不模糊） 、交互性（具有输入输出）、有效性（步骤有效）； 如何表示算法：自然语言（需求分析）、流程图（概要设计-避免歧义）、伪代码（详细设计）、程序语言（出差：需求、部署）； C语言：面向过程的结构化语言，三种基本结构：顺序结构、分支选择结构、循环结构； 基础知识 低级语言：（汇编）机器语言，可以直接操作计算机硬件；中级语言（C），指针可操作计算机硬件，人类语言；高级语言：（Java）人类语言，经过编译变成机器语言，机器才能执行； 编译：语法查错、转成机器语言（转译）； C语言优点：既能开发系统程序，又能开发应用程序； C语言：面向过程，结构化的（顺序，分支，循环），函数语言； 学习方法：wwwh（why, what, when, how），程序 = 数据结构 + 算法； 最小单元变量和常量 最小的盛放数据单元； 常量：值不能改变的量，一般常量和符号常量（用#define定义，一改全改）； 变量：值可以改变的量，变量的本质是一片连续的内存空间，变量是一个容器，用来存放数据； C语言规定：变量必须先声明，再赋值，后使用；所有变量定义在函数首部，有了执行语句，就不能再有定义语句； 变量命名规则（三条）: ​ —必须以数字，字母，下划线组成，以字母或下划线开头； ​ —见名知义，首字母小写； ​ —变量不能和关键字重名，区分大小写； 基本数据类型 基本数据类型：运算法则、约束内存空间大小的单位； 数值：整型（int，short int，long int）和非整型（float，double），非数值：char； 1个字节 = 8位 、一个中文字符 = 2个字节 、一个英文字符 = 1个字节； C语言中没有字符串变量，用字符数组模拟字符串变量（难用）； ASCII码：0~9（48~57），A~Z（65~90），a~z（97~122）， C语言中char和int完全兼容； 类型转换: ​ —&gt;自动类型转换：把范围小的类型的值转换为范围大的类型的值：（ short, int, long, float, double）； ​ —&gt;强制类型转换：(类型名)变量或数值； 转义字符：转为其他的意思（\\t， \\n等）； C语言的输入输出：getchar() ，putchar()，输入输出字符； scanf() ，printf()输入输出任何东西，（sacnf和printf中的f是format的意思，即格式化输入和输出）； 次小单元运算符&amp;表达式 表达式：操作数 + 运算符； 数学表达式、赋值表达式、关系表达式、逻辑表达式； 算数运算符：+、-、* 、/、%（二目）， /：两边都是整数取整，/：两边至少一边为实型求精确值，%：要求两边都是整型，求余； 12345678910111213141516171819202122232425262728//算数运算符练习：回文数：void main() &#123; int ge, shi, qian, wan, x; printf(\"请输入一个五位数：\"); scanf(\"%d\", &amp;x); wan = x / 10000; qian = x % 10000 / 1000; shi = x % 100 / 10; ge = x % 10; if(wan == ge &amp;&amp; qian == shi) &#123; printf(\"%d是回文数\\n\", x); &#125; else &#123; printf(\"%d不是回文数\\n\", x); &#125;&#125;//水仙花数：void main() &#123; int n, ge, shi, bai; for(n = 100; n &lt;= 999; n++) &#123; ge = n % 10; shi = n % 100 / 10; bai = n / 100; if(ge * ge * ge + shi * shi * shi + bai * bai * bai == n) &#123; printf(\"%d\\n\", n); &#125; &#125;&#125; ++、–（一目），单个语句时a++和++a效果一样，参与运算时a++和++a效果不一样； 123456789//自增自减练习：void main() &#123; int a = 1, b = 2, c = 3, d, e, f; d = ++a; e = a + b; f = (b--) + c; printf(\"%d %d %d %d %d %d\\n\", a, b, c, d, e, f);&#125; 运行结果：2 1 3 2 4 5 赋值：变量 = 表达式； 关系运算符：&gt;、&gt;=、！=、==、&lt;、&lt;=； 逻辑运算符（与、或、非）：&amp;&amp;、||、！； C语言中：用0代表假，非零代表真；sizeof：可以获得数据类型占用内存空间的大小 ；sizeof(type_name) 结果以字节为单位显示； 三种结构顺序结构分支选择结构 if：（布尔常量， 布尔变量， 比较表达式， 逻辑表达式）； 多分支（否定式： 多重if-else、 switch-case）； 123456789101112131415161718192021222324252627282930313233343536//多重if-elsevoid main() &#123; int f; printf(\"请问你送几朵花：\"); scanf(\"%d\", &amp;f); if(f &gt;= 9 &amp;&amp; f &lt; 99) &#123; printf(\"笑一笑\"); &#125; else if(f &gt;= 99 &amp;&amp; f &lt; 999) &#123; printf(\"拉拉手\"); &#125; else if(f &gt;= 999) &#123; printf(\"抱一抱\"); &#125; else &#123; printf(\"不高兴\"); &#125; &#125;解释：程序能进入到下一个elseif语句块，说明前面if里的条件不成立//switch-casevoid main() &#123; int f; printf(\"请问你送几朵花：\"); scanf(\"%d\", &amp;f); switch(f) &#123; case 9: printf(\"笑一下\"); break; case 99: printf(\"拉拉手\"); break; case 999: printf(\"抱一下\"); break; default: printf(\"不高兴\"); &#125; &#125;解释：程序能进入到下一个case语句块，说明前面case里的条件不成立，每个case后应该有break语句，否则程序会执行当前case条件满足后的所有语句，不符逻辑。 （肯定式：If嵌套）； 1234567891011121314151617181920void main() &#123; int work, house, car; printf(\"请输入你的资源：\"); scanf(\"%d %d %d\", &amp;work, &amp;house, &amp;car); if(work) &#123; if(house) &#123; if(car) &#123; printf(\"赶紧结婚\"); &#125; else &#123; printf(\"买了车就结婚\"); &#125; &#125; else &#123; printf(\"无房不嫁女\"); &#125; &#125; else &#123; printf(\"先好好提升自己\"); &#125;&#125;解释：当进入下一个if条件判断时，说明满足之前if的判断条件。 switch-case：switch()里可以是整型常量，整型变量，整型表达式；case后面必须是整型常量，case最后一句跟break；case后面不能跟相同的值，case可以随意倒顺序； 条件运算符：a &gt; b ? c : d —-如果a &gt; b成立，则结果为C，否则为d； 循环结构 循环的本质：有规律的重复的做一件事； 循环分类：（小括号—规律，花括号—重复），规律：已知循环次数（循环变量i）和未知循环次数（循环的开关）；循环体：当型、直到型； 当型（while-未知循环次数、for-已知循环次数），直到型：do-while（已知循环次数和未知循环次数）； 12345678910111213141516171819202122232425262728293031323334353637383940414243//whilevoid main() &#123; int i = 0, j = 0; while(i &lt; 10) &#123; printf(\"第%d个同学演节目开始！\", (i + 1)); while(j &lt; 3) &#123; printf(\"第%d个节目!\", (j + 1)); j++; &#125; j = 0; printf(\"第%d个同学演节目结束！\\n\", (i + 1)); i++; &#125;&#125;//forvoid main() &#123; int i, j; for(i = 0; i &lt; 10; i++) &#123; printf(\"第%d个同学演节目开始！\", (i + 1)); for(j = 0; j &lt; 3; j++) &#123; printf(\"第%d个节目！\", (j + 1)); &#125; printf(\"第%d个同学演节目结束！\\n\", (i + 1)); &#125;&#125;//do-while（猜数字）void main() &#123; int flag = 1; int num = 8, guess; printf(\"请输入一个1~10之间的数！\"); do &#123; printf(\"请输入：\"); scanf(\"%d\", &amp;guess); if(guess &lt; num) &#123; printf(\"小了！\"); &#125; else if(guess &gt; num) &#123; printf(\"大了！\"); &#125; else &#123; flag = 0; &#125; &#125; while(flag); printf(\"恭喜你答对了！\");&#125; 已知循环次数：循环变量在外面定义并初始化，循环变量在循环体里进行自增或自减； 循环的嵌套：外层一趟，内层一遍； for循环：for（表达式1；表达式2；表达式3）， ​ 表达式1：循环变量赋初值； ​ 表达式2：循环条件； ​ 表达式3：更新循环变量值； break与continue：break，终止，在多层循环中，一个break语句只向外跳一层循环；continue：中止，只能用在循环里，跳过循环体中剩余的语句而执行下一次；对于while和do-while循环（continue语句执行之后的动作是条件判断），对于for循环，随后的动作是变量更新； 一般情况下，这几种循环体用的概率：for（60%）、while（25%）、do-while（15%）； 高级部分数组 why？数据带上结构：贴近现实生活，操作、维护方便； 主要内容：数组名、数组大小、数组下标、数组容器的样子、数组类型； 变量&amp;数组比较： ​ 变量：值可变的量、一片连续的内存空间、小容器； ​ 数组：一组数放在一起、一片连续的有序的类型相同的空间、大容器； 种类：一维、二维、多维； 一维数组声明： 1datatype arrayName[size]; //（size：整型常量） 静态定义（三种）： 123int num[5] = &#123;1, 2, 3, 4, 5&#125;;int n1[] = &#123;1, 2, 3&#125;;int n2[5] = &#123;1, 2, 3&#125; 动态定义（循环初始化）； 字符数组模拟字符串变量： 1char c[2] = \"ok\"； 输入输出字符串：gets(),puts()—可输入空格； 二维数组声明： 静态定义（两种）： 12int num[2][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;;int num[][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; 动态定义（使用for循环初始化）； 1234567891011121314151617//找数字：void main() &#123; int n = 8, i; int num[10]; for(i = 0; i &lt; 10; i++) &#123; scanf(\"%d\", &amp;num[i]); &#125; for(i = 0; i &lt; 10; i++) &#123; if(n == num[i]) &#123; printf(\"找到了：%d, 位置：%d\", num[i], i + 1); break; &#125; &#125; if(i == 10) &#123; printf(\"对不起，没找到！\"); &#125;&#125; 函数 使用函数四个优点： ​ 让主调函数更简短清晰； ​ 提高代码维护效率； ​ 提高代码开发效率； ​ 提高代码复用率； 函数类型： ​ 内置函数—函数原型，功能，在哪个工具箱（头文件）放着； ​ 自定义函数； rand（）：伪随机函数； 12srand((unsigned)time(NULL))---作种函数（每次出来的随机数不一样）；//没有这句，程序运行每次随机数一样 自定义函数：返回值类型 函数名（[参数的数据类型 参数名],…），函数一次性只能返回一个值； 一个函数只做一件事；（高内聚） 函数原型说明：int add(int a, int b)或int add(int, int)； 函数的参数：函数定义中声明的参数是形参，函数调用时传入的参数就是实参； 函数参数的传递：值传递（将实参拷贝一份赋值给形参），址传递（让形参和实参共享一片内存空间，即内存地址相同）； 12345678910111213141516171819202122//值拷贝传递void add(int x, int y) &#123; x++; y++;&#125;void main() &#123; int a = 1, b = 2; add(a, b); printf(\"%d %d\", a, b);&#125;运行结果：1 2//址传递void add(int n[2]) &#123; n[0]++; n[1]++;&#125;void main() &#123; int a[2] = &#123;1, 2&#125;; add(a); printf(\"%d %d\", a[0], a[1]);&#125;运行结果：2 3 变量作用域： 变量的有效范围 —&gt; 全局、局部； 123456789101112131415161718192021222324252627//简单彩票机void main() &#123; int i = 0, j, m; int lottery[7]; srand((unsigned)time(NULL)); printf(\"请问您是否要购买彩票？\"); printf(\"请选择：1-是，0-否\\n\"); scanf(\"%d\", &amp;m); if(m) &#123; do&#123; lottery[i] = (rand() % 33) + 1; for(j = 0; j &lt; i; j++) &#123; if(lottery[j] == lottery[i]) &#123; break; &#125; &#125; if(!(j &lt; i)) &#123; i++; &#125; &#125; while(i &lt; 7); for(i = 0; i &lt; 7; i++) &#123; printf(\"%d \", lottery[i]); &#125; &#125; else &#123; return 0; &#125;&#125; 特征指针 指针：就是内存地址，一个变量只有一个指针； 指针变量：用来存放地址的变量，变量的指针：变量的地址； 关键的运算符：&amp; 取地址符、* 指针运算符； int p== (int )p； n[i - 1] = (n + (i - 1)) = (p + (i - 1))；","comments":true,"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C语言/"}]},{"title":"JavaSE基础","date":"2019-03-07T06:22:36.000Z","path":"2019/03/07/Java基础/","text":"Java一些基础语法概念总结 About1、SUN（Stanford University Network），2008年10亿美金收购mysql，2010年74亿美金被甲骨文收购； 2、语言的进化：机器、汇编、高级语言、面向对象（计算机容易识别转换为人容易识别）； 3、java之父：James Gosling； 4、java诞生记：1991年SUN公司的Green计划（让电器带上智能—编程语言跨平台）、java开发了三年；Internet带来时机，本起名Oak（橡树），1995年正式发布java1.0版本； 5、java是sun公司倡导的JamesGosling发明的面向对象的可跨平台的编程语言； 6、平台 = cpu + 操作系统； 7、跨平台：编译以后能不能跨平台，并非源代码可跨平台运行； 8、Java可以反编译（缺点）； 9、java：一次编译，到处执行（编译器、解释器）； 10、语言执行方式的三种分类： 编译执行：缺点，无法跨平台；优点，速度快； 解释执行（html、javascript）：类似同声传译； 中间码+虚拟机（解释型语言）； 11、JDK：开发java需要从源文件到中间字节码的编译器；运行java需要java解释器；JDK=Java编译器+Java解释器+其他组件； 12、优点：面向对象、平台无关、自动收集内存、多线程开发；缺点：运行速度慢，占用资源多，复杂； 13、IDE工具：Jbuild可以拉拖界面； 基础1、数据类型：基本数据类型和引用数据类型； 基本数据类型：数值型（整数（byte—1个字节、short、int、long）、浮点（float、double））、字符型（char）、布尔型（boolean）； 引用数据类型：类（class）、接口（interface）、数组； 2、字符串String； 3、数组定义（三种方式）： 123int[] num = new int[2];int[] num = &#123;1, 2&#125;;int[] num = new int[]&#123;1, 2&#125;; 4、反序数： 12345int n = 12345;while (n != 0) &#123; System.out.print(n % 10); n = n / 10;&#125; 5、冒泡排序：（第一轮可以让未排序的最大元素上浮到右侧，以此类推，5个数循环4次）： 12345678910111213int[] num = new int[]&#123;2, 6, 4, 8, 3&#125;;for(int i = 0; i &lt; num.length - 1; i++) &#123; for(int j = 0; j &lt; num.length - i - 1; j++) &#123; if(num[j] &gt; num[j+1]) &#123; int temp = num[j]; num[j] = num[j+1]; num[j+1] = temp; &#125; &#125;&#125;for(int i = 0; i &lt; num.length; i++) &#123; System.out.println(num[i]); &#125; 6、二分查找（要求数字按序排列）： 123456789101112131415161718int[] num = &#123;1, 4, 6, 8, 10, 13&#125;;int n = 4;int start = 0, end = num.length - 1, m;while(true) &#123; m = (start + end) / 2; if(num[m] &gt; n) &#123; end = m - 1; &#125; else if(num[m] &lt; n) &#123; start = m + 1; &#125; else &#123; System.out.println(\"找到了\" + num[m] + \"，位置为：\"+ (m + 1)); break; &#125; if(start &gt; end) &#123; System.out.println(\"找不到！\"); break; &#125;&#125; 类和对象1、面向对象编程（oop，Object Oriented Programming），是一种设计软件的先进的主流的思想，旨在计算机中模拟现实世界中的事物和概念，Everything is object； 2、现实生活中的任何事物，都可以用状态（属性）和行为（方法）来描述； 属性是事物（类）本身的特性，用来表示它的状态；行为（方法）用来说明这个事物（类）所具有的功能； 3、类（主观）是具有相同属性和方法的一组对象（实例）的集合； 4、对象是具体的，是类定义内容的实现，把一个类的对象称为一个类的实例（客观存在的）； 5、类是对象的抽象定义，对象是类的具体实例； 6、java声明完类并不开辟空间，new关键字为实例开辟空间； 7、构造方法（什么？作用？调用时机？分类？） 方法名与类名完全相同，但没有返回类型（跟没有返回值不一样）； 123//Person类Person() &#123; //构造方法 &#125; 作用：让类开辟空间；在类诞生的时候做一些事情（一般是初始化）； 调用时机：new的时候自动调用（开辟空间的时候），传什么参调用什么方法； 分类： 默认有隐式构造方法（空参数），显式构造方法（带参）； 如果类中不带任何构造方法，系统提供隐式构造方法； 如果自己定义了显式构造方法，系统不再提供隐式构造方法； 8、static关键字： 成员变量（实例名、引用名）：new完后才可使用的变量； 12static int num = 0; //静态变量，不需成员名直接类名可调用；成员名也可调用//Person.num static定义完就开辟空间，开辟在静态池中； 静态变量只保持一份，节省空间； 作用：保存类的信息（比如new一次加一次）； 9、包：本质是个文件夹（方便管理、避免名字冲突）；包名是类名的一部分；包是java封装机制的一部分； 10、一般先写被调，再写主调； 封装和继承1、面向对象特征：封装、继承、多态；对象的特征：属性、方法； 2、封装：隐藏事物内部的实现细节、有选择的提供数据； 封装优点： 内部的修改不影响外部的使用； 防止外界误修改程序单元； 对象使用变得更简单； 3、访问修饰符：public、protected、默认、private（都可以修饰属性和方法，只有默认和public可以修饰类）； public：所有类都可以访问（本类、同包、异包下的子类、异包下的其他类）； protected：该类及其子类成员可以访问，同一个包中的可以访问（本类、同包、异包下的子类）； 默认：相同数据包里的可以访问（本类及其同包下的类可以访问）； private：只有该类可以访问； 4、实体类：get与set方法称为访问器； 5、继承（extends）： 在一个类的基础上定义一个新类是继承； 父子关系是相对的； 继承关系由“子类是父类”确定； java中只有单继承； 继承效果： 子类可以拥有父类的属性和方法； 子类可以拥有新的属性和方法（扩展）； 子类可以重写覆盖父类方法和属性（修改）； 1@Override //注解，写给编译器 可以声明父类，创建子类（父类装载子类—向上转型），父类能出现的地方，子类一定能出现；声明的什么类型，就只能调用什么类型的属性方法；创建的什么类型，就真正运行什么类型的方法；创建的什么类型，就可以强转为什么类型（向下转型）； 1Person p = new Teacher();//父类装载子类，父类的引用指向子类的空间 继承的优点： 提高代码复用性； 父类的属性方法可以用于子类； 可以轻松的定义子类； 使设计应用程序变得简单； 6、关键字this与super： this：表示调用本类声明的属性和方法，this使用在构造方法中表示调用本类其它构造方法； super：表示调用父类声明的属性和方法； 7、继承中的构造方法： 创建子类一定会调用父类的构造方法； 子类默认调用父类无参（显式或隐式）构造方法； 子类只能调用父类存在的构造方法； 子类构造方法中使用super调用父类构造方法，并且super必须放在第一行； 8、子类要覆盖父类的属性或方法，子类的访问修饰符必须大于或等于父类的访问修饰符； 方法重载和多态1、方法重载（Overload）： 具有相同的方法名称、不同的参数（类型或者个数）； 要点： 与参数名无关； 与返回类型无关； 父子类方法重载； 构造方法重载； 2、多态： 多态可以理解为“多种形式”的意思； 多态在程序中表现为同一个引用在不同的条件下指向不同实例，从而表现出不同状态； 多态一般用方法重载和方法重写来实现； 3、雪雪是个多态：在学校是学生，在家里是儿女，在社会是工作者（同一个人在不同环境下表现出不同状态）； 4、static（强调只有一份）修饰符： static只能修饰属性和方法，不能修饰类； static修饰符修饰的变量叫静态变量； static修饰符修饰的方法叫静态方法；静态方法独立于类的实例，使用类去访问，而不是类实例，所以也叫类方法；静态方法只能调用静态成员，不能调用成员化东西；成员方法可以调用静态方法；静态方法和属性不能写this和super； 5、final修饰符： final可以修饰属性、方法和类； 不能修改该变量；不能继承该类；子类不能重写该方法； 6、static和final：final强调是不变的；static强调只有一份； 7、内存机制： 方法区：类结构的样子、静态属性、静态方法； 堆：对象的实例； 栈：对象的引用、基本数据类型； 栈（最快）&gt;堆（容量大、速度慢）； 8、Java内存图示： 9、值传递与址传递：基本数据类型采用值传递、引用类型址传递； 接口1、抽象方法： abstract修饰的方法就是抽象方法； 抽象方法不能有方法实现，只能有方法定义； 抽象方法必须出现在抽象类中； 构造方法和static方法不能是抽象的； 2、抽象类： abstract修饰的类就是抽象类； 抽象类中可以拥有若干个（0~多个）抽象方法，也可以拥有若干个（0~多个）普通方法； 抽象类不能被实例化，可被继承； 如果一个抽象类被另一个类继承，这个类必须重写抽象类中所有抽象方法； 3、接口（interface），达到多继承的效果，接口就是功能： 是一种“纯虚抽象类”，可以理解为半个类； 接口用来完成多继承的效果； 接口中只能有方法的定义，不能有方法的具体实现； 接口中可以定义常量（static final）； 接口可以被继承（接口继承接口），接口可以多继承； 接口可以多实现（类实现接口）； 弥补单继承的不足，实现多继承的效果； 实现者-使用者纽带作用； 用法：extends， implements 4、编程技术的趋势：面向过程、面向对象、面向接口、面向方面； 5、什么是什么，可以理解为类的继承；什么能干什么，可以理解为接口的实现； JavaAPI（Java.lang—基础包）1、包装类、String和StringBuffer类、Math、Class、Object； 2、java的main方法和8个基本数据类型不是面向对象的； 3、装箱：int-&gt;Interger（valueOf）；拆箱：Interger-&gt;int（intValue）； 4、包装类型 实例名 = 包装类型.valueOf(String);包装类型.parse基类型(String)；实例名.toString()； 5、字符串： 12String s0 = \"aa\";//字符串字面量String s1 = new String(\"aa\");//字符串对象 6、==：判断字符串指的是否为同一片空间；equals比较字符串值是否相等； 7、字符串字面量：值相等用==比较true；字符串对象：值相等用==比较false； 8、字符串lengh是方法，数组lengh是属性； 9、字符串比较内容：equals、compareTo、startswith、endswith； 10、搜索字符串：indexOf（String）； 11、操作字符串：split（）、charAt（）、subString（）、replace（）、concat（）、trim（）—去掉字符串前后包含的空格； 12、Object：toString、equals（在object里比较的是两个引用是否相等，无法比内容，需重写equals方法）、hashcode（重写hashcode，使重写equals方法后，业务逻辑和虚拟机保持一致）、finalize（析构方法，收空间，System.gc()—建议立即回收垃圾方法）； 13、Class：类的类，包装正在运行类的运行状态及信息，可用来动态加载类，得到类的实例； 14、字符串（空间）的不变性：String—&gt;有序的、不变的字符序列； StringBuffer：可变字符串，解决字符串的不变性，节省空间； 12StringBuffer sb = new StringBuffer(\"ok\");sb.append(\"halou\"); 异常处理1、try、catch、finally、throw、throws； 2、异常：就是不同寻常的事情，异常并不总是错误，一切不寻常的事情都是异常（其中包含错误）； 3、所有异常类型都是内置类Throwable的子类： Error类对象由java虚拟机生成并抛出（用于java运行时系统来显示与运行时系统本身有关的错误）—灾难，无法处理； Exception类对象由应用程序处理或抛出（用于用户程序可能捕获的异常，也是用来创建用户异常类型子类的类）—可以处理。RuntimeException可以忽略，除了RuntimeException其他子类不能忽略； 4、处理方式：直接处理、向上抛出； 5、是一个业务逻辑才能try在一起； 6、try-catch如果代码段有异常没被处理，在发生异常处及后面代码不被执行，如果处理，进入catch处理后后面代码依然执行； 7、throws处理后，后面代码不再执行，看到throw方法直接返回，位于throw下面的代码不再执行；如果希望throw后面的代码执行，最后加finally，不管有木有错finally里语句要执行； 8、里面throw-throws，外面try-catch；如果里面是Runtime可以throw不throws，外面可抓可不抓；里面不throw，外面直接catch； JDBC数据库连接（java.sql）1、JDBC（sun公司制定）是一种标准，不是技术，是一些类和接口的集合（jar包）； 2、sun公司制定标准（接口），数据库生产商按照标准生产数据库连接对象（类-实现），开发人员学习接口，使用类； 3、Driver（驱动程序）、Connection（表示与数据库的连接）、PreparedStatement（执行预编译的SQL语句）、ResultSet（查询出来的数据库数据结果集）、Statement（执行SQL语句并将数据检索到ResultSet中）； java.util1、Date、Calendar、GregorianCalendar（时间）；Arraylist、Vector、HashSet、HashMap、Hashtable（集合框架、容器）； 2、Date：表示特定的瞬间，精确到毫秒，获得当前时间； 3、toString原生出来是类名+地址； 4、Calender：日历类，抽象类，不能被实例化； 5、GregorianCalendar：标准日历类，是Calendar一个子类，日期类月份值跟业务逻辑相差1； 6、SimpleDateFormat：日期的格式化； 7、日历变日期：getTime()； 8、集合框架：用于表示和操纵集合的统一体系结构，集合用于存储、检索和操纵数据，Collection对象是将多个元素组成一个单元的对象； 9、集合框架包含三个组件：接口、实现、算法； 10、Iterator（迭代器）、Collection（多个变一个，用对象本身存集合里面，无序）、Map（多个变一个，键值对存储，无序）； 11、集合框架类层次结构： 12、List：有序的、带下标的、对象本身存；Set：无序、不带下标、对象本身存； Vector：线程安全的动态数组，ArrayList：线程不安全的动态数组； 13、Collection：可存储重复值； 迭代器-Iterator： 12345Iterator iterator = c1.iterator();while (iterator.hasNext()) &#123; Student temp = (Student) iterator.next(); System.out.println(temp.toString()); &#125; foreach迭代： 123for(Student s : c1) &#123; System.out.println(s.toString()); &#125; foreach里面内部就是iterator； 14、泛型：规定容器里只放一种东西； 15、Vector： 具有类似数组的数据结构，是动态的，容量可以递增； 可存储重复元素和NULL； 元素有序排列； 线程安全； 16、Set：无序、不能存储重复元素、可存null、线程不安全的； 17、Map： 键值对存储； 三种遍历方式—迭代（键、值）、entry（key-value）； 键不能重复，值可以重复； 键和值可以存null值，hashmap线程不安全； 12345678910111213141516171819System.out.println(\"通过keys进行遍历===========\");Set&lt;String&gt; keys = map.keySet();for(String keyStr: keys) &#123; System.out.println(keyStr); System.out.println(map.get(keyStr));&#125;System.out.println(\"通过values遍历=================\");Collection&lt;Student&gt; values = map.values();for(Student stu: values) &#123; System.out.println(stu);&#125;System.out.println(\"通过key-values（Entrys）遍历================\");Set&lt;Map.Entry&lt;String, Student&gt;&gt; entrys = map.entrySet();for(Map.Entry&lt;String, Student&gt; entry: entrys) &#123; System.out.println(entry.getKey()); System.out.println(entry.getValue());&#125; 18、hashtable线程安全，键和值都不可以存储null值，遍历的时候可以使用枚举类型； 1234567Hashtable&lt;String, Student&gt; ht = new Hashtable&lt;String, Student&gt;();ht.put(\"dd\", s1);System.out.println(\"枚举类型==============\");Enumeration&lt;Student&gt; enumeration = ht.elements();while (enumeration.hasMoreElements()) &#123; System.out.println(enumeration.nextElement());&#125; 19、实现comparable达到list集合排序功能； 20、集合框架的优点：提供有用的数据结构和算法，减少编程工作；提高程序速度和质量，因为它提供了高性能的数据结构和算法；可以方便地扩展或改写集合； JavaSwing1、GUI：图形用户界面； 2、Awt（抽象窗口工具-重量级页面技术）、Swing（波浪、翅膀-轻量级页面技术），swing是awt的子类； 3、Awt（重量级）：容器（包含Awt容器组件）、组件（以图形表示的对象允许用户交互）、布局管理器（定义GUI组件的位置）、图形和绘制方法（使用Awt图形方法相对于窗口绘制图形）、字体、事件（用于用户和系统交互）； 4、Swing（轻量级）：容器、组件、可改变的外观、Java2D图形绘制； 5、MVC（编程思想）：界面、操作、存储（视图、控制—业务的分发和流程的转发、持久—存储数据）； 6、页面主动拿数据（拉）、页面被动拿数据（推），swing是mvc的推； 7、重量级（直接借助于awt、被单独的显示）、中间层容器、功能性容器； 8、Dimention：描述矩形的单位； 9、JLabel：单向交互、显示图片或文字；JButton：交互；JTextField：文本域；JPasswordField、JTextArea、JScollPane； 10、布局管理器：屏幕组件可以按照一定的格式布局； 流式（FlowLayout）：默认，一直往下排列； BorderLayout：边框布局管理器，上下左右中； GridLayout：几行几列； GridBagLayout：高级布局管理器，实现精确的布局管理； 11、ActionListener：实现接口、完成事件方法、相应事件源上加事件； 12、JDialog（繁琐）和JOptionPane（简单）：弹出式对话框，完成于用户的交互； 13、对话框显示：模式（需处理）、非模式（不需处理）； 14、模式：观察者模式（事件的源、事件对象、事件处理对象）； 15、事件源（三个要素）：私有的监听者列表，公有的向监听者列表添加监听者的方法，公有的发生事情的方法； 16、事件源四种添加监听者接口实例：自己加自己、自己加别人实现接口、自己加别人（适配器）、参数匿名类（适配器）； 17、表格JTable：显示数据，表格模板（TableModel）：对数据操作，JMenu：菜单；热键：Alt+？ 18、JMenue不能做快捷键，可以做热键，不能带图片；JMenueIterm两个都可以做，可以带图片； 19、工具栏（JToolBar）挂在panel上； 20、标签面板（JTabbedPane）：是一种容器，提供一组标签显示不同页面； 设计模式1、模式：我们处理大量问题时，在很多不同的问题中重复出现的一种性质，它使得我们可以使用一种方法来描述问题实质并用本质上相同，但细节永不会重复的方法去解决，这种性质就叫模式。简单的说模式就是一种惯性的思维方式，用于解决同一类问题； 2、23种设计模式： 创建型：解决对象与对象之间创建性的问题； 结构型：解决对象与对象间搭配结构的问题； 行为型：解决对象与对象之间做事情； Java Io1、I/O流用来完成java的输入输出工作，包括磁盘文件、设备、其他程序以及内存数据等等的输入输出； 2、数据流（不间断—I/O流）、数据包（间断）； 3、分类：字节流（Stream）、字符流； 4、基于流技术可以用来传递数据，还可以用来操作或格式化数据； 5、外部进入代码里面：输入流；代码输出数据：输出流； 6、声明、创建、读写、关闭； 7、字符流的根：Reader和Writer； 8、 123reader = new BufferedReader(new FileReader(\"./test1.txt\"));writer = new BufferedWriter(new FileWriter(\"./test2.txt\"));里面节点流，外面处理流； 9、字节流、缓冲字节流、字符流、缓冲字符流； Java多线程1、进程（是执行中的程序，是活动的实体—正在通电的内存；是自包容的运行程序，有自己的地址空间）—是操作系统的最小单元；线程（是轻量级进程，是CPU使用的基本单元；线程属于某一个进程，一个进程中拥有一个或多个线程；多个线程共享同一个进程资源）；进程是重量级的、线程是轻量级的； 2、read方法是一种阻塞方法； 3、多任务处理： 基于进程：计算机同时运行多个进程；基于线程：一个进程包含多个线程； 4、使用多线程的理由：与用户交互更佳、模拟同步动作、利用多处理器、等待缓慢I/0操作时完成其他任务、简化对象模型；线程也需要开销资源，谨慎使用； 5、JVM中的线程：当操作系统启动（javac、java、javaw等命令）JVM时就创建了一个进程；JVM进程内至少包含了 两个线程：mian方法和垃圾回收线程，它们称为主线程，有时它们还会启动其他线程，它们必须最后完成执行，执行各种关闭、释放动作； 6、创建线程两种方法：声明一个Thread类的子类，并覆盖run（）方法；声明一个实现Runnable接口的类，并实现run（）方法； 7、线程的状态：新建态（New—尚未启动的线程）、可运行态（Runnable—可运行线程的线程状态）、锁定态（Blocked—受阻塞线程的线程状态）、等待态（Waiting）、定时等待态（Timed_Waiting）、中止态（Terminated—已终止线程的线程状态）； 8、yield：使正在执行的线程临时暂停，并允许其他线程执行； 9、优先级：线程抢占cpu的能力； Java网络编程1、网络（套接字、socket）编程； 2、网络：实现资源共享和通信，连接终端系统（主机）的通信系统； 3、OSI模型：物理层、数据链路层（怎么连）、网络层（怎么找）、传输层（怎么传）、会话层、表示层、应用层（传什么）； 4、TCP：双向的、稳定的、可靠的、有序的、不间断的数据流（打电话）；UDP：单向的、间断的、不可靠的数据包（写信）； 5、IP：连接至网络的每台计算机都是唯一的，32位数字，包括网络ID和主机ID；域名系统：将特定IP地址映射至字符串，映射由域名服务器系统维护； 6、客户端：向另一台计算机请求服务的计算机；服务器：处理客户端请求的计算机； 7、InetAddress：封装IP地址和DNS；ServerSocket：用来创建套接字（TCP）服务器；Socket：创建客户端套接字； 8、UDP（数据报）：DatagramPacket—邮包、DatagramSocket—邮递员；","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Python Selenium基础","date":"2019-02-27T08:38:02.000Z","path":"2019/02/27/Python-Selenium/","text":"Python + Selenium 测试基础 About自动化测试是用机器代替手工做一些事情。作为一个测试人员，做自动化一般是指接口自动化与UI自动化。（接口也是指对外的部分，通过各种协议，各系统或模块之间交流的接口）接口性价比更高，但不代表UI自动化没有价值。 自动化测试基础1、什么是自动化测试？ 首先理清自动化测试的概念，广义上来讲，自动化包括一切通过工具（程序）的方式来代替或辅助手工测试的行为都可以看做自动化，包括性能测试工具（loadrunner、jmeter），或自己所写的一段程序，用于生成1到100个测试数据。狭义上来讲，通过工具记录或编写脚本的方式模拟手工测试的过程，通过回放或运行脚本来执行测试用例，从而代替人工对系统的功能进行验证。当然，我们更普遍的认识把“自动化测试”看做“ 基于产品或项目UI层的自动化测试”。 2、分层的自动化测试 传统的自动化测试更关注的产品UI层的自动化测试，而分层的自动化测试倡导产品的不同阶段（层次）都需要自动化测试。 上面的金字塔就是对产品开发不同阶段所对应的测试！我们需要规范的来做单元测试同样需要相应的单元测试框架，如java的Junit、testNG，python 的unittest、pytest 等，几乎所有的主流语言，都会有其对应的单元测试框架。 集成、接口测试对于不少测试新手来说不太容易理解，单元测试关注代码的实现逻辑，例如一个if 分支或一个for循环的实现；那么集成、接口测试关注的一是个函数、类（方法）所提供的接口是否可靠。例如，我定义一个add()函数用于计算两个参数的结果并返回，那么我需要调用add()并传参，并比较返回值是否是两个参数相加。当然，接口测试也可以是url的形式进行传递。例如，我们通过get方式向服务器发送请求，那么我们发送的内容做为URL的一部分传递到服务器端。但比如 Web service 技术对外提供的一个公共接口，需要通过soapUI 等工具对其进行测试。 UI层的自动化测试，大部分测试人员的大部分工作都是对UI层的功能进行测试。例如，我们不断重复的对一个表单提交，结果查询等功能进行测试，我们可以通过相应的自动化测试工具来模拟这些操作，从而解放重复的劳动。UI层的自动化测试工具非常多，比较主流的是QTP，Robot Framework、watir、selenium 等。 在自动化测试中最怕的是变化，因为变化的直接结果就是导致测试用例的运行失败，那么就需要对自动化脚本进行维护；如何控制失败，降低维护成本对自化的成败至关重要。反过来讲，一份永远都运行成功的自动化测试用例是没有价值的。 对于google产品，70% 投入为单元测试，20% 为集成、接口测试，10% 为UI层的自动化测试。 3、为什么要做自动化测试？ 相对开发来说，测试的门槛底，薪资普遍较底，所要求的知识面虽然有一定广度，但缺乏深度。这是测试的普遍现状。 4、什么项目适合做自动化测试？ 软件需求变动不频繁 （相对稳定的模块进行自动化测试，而变动较大的仍是用手工测试）、项目周期较长 （自动化测试需求的确定、自动化测试框架的设计、测试脚本的编写与调试均需要相当长的时间来完成）、自动化测试脚本可重复使用 （自动化测试脚本的重复使用要从三个方面来考量，一方面所测试的项目之间是否很大的差异性（如C/S系统和B/S系统的差异）；所选择的测试工具是否适应这种差异；最后，测试人员是否有能力开发出适应这种差异的自动化测试框架）。 5、选择什么工具进行自动化测试 ？ 首先要先确认你所测试的产品是桌面程序（C/S）还是web应用（B/S）。 桌面程序的工具有：QTP、 AutoRunner ； web应用的工具有：QTP、AutoRunner、Robot Framework、watir、selenium ； 如果，被测产品是B/S 结构，那么推荐selenium ，为什么不是QTP 或其它工具？因为selenium 对B/S应用支持很好，更重要的一点，它支持多语言的开发，真正的使用selenium ，你所要掌握的不仅仅是一个工具而已，你还需要学习一门语言。我为什么要选择selenium？还要学一门语言，这无疑增加了我的学习成本。增加成本的同时，也增加的你的竞争力，而且，在这个过程中你不单单只是学会了一个自动化工具而已，你完全可以使用所学的语言去做更多的事情。 selenium 是支持java、python、ruby、php、C#、JavaScript 。 从语言易学性来讲，首选ruby ，python；从语言应用广度来讲，首选java、C#、php；从语言相关测试技术成度（及资料）来讲：ruby ，python ，java； selenium 概念1、selenium 并不是单纯的一个工具，它是一组工具的集合，而且，他还有1.0与2.0之分，当然3.0也已经到来。selenium 也不是简单一个工具，而是由几个工具组成，每个工具都有其特点和应用场景。 selenium IDE selenium IDE 是嵌入到Firefox浏览器中的一个插件，实现简单的浏览器操作的录制与回放功能。那么什么情况下用到它呢？ 快速的创建bug重现脚本，在测试人员的测试过程中，发现了bug之后可以通过IDE将重现的步骤录制下来，以帮助开发人员更容易的重现bug。 IDE录制的脚本可以可以转换成多种语言，从而帮助我们快速的开发脚本，关于这个功能后而用到时再详细介绍。 selenium Grid Selenium Grid是一种自动化的测试辅助工具，Grid通过利用现有的计算机基础设施，能加快Web-app的功能测试。利用Grid，可以很方便地同时在多台机器上和异构环境中并行运行多个测试事例。其特点为： 并行执行 通过一个主机统一控制用例在不同环境、不同浏览器下运行 灵活添加变动测试机 selenium RC selenium RC 是selenium 家族的核心工具，selenium RC 支持多种不同的语言编写自动化测试脚本，通过selenium RC 的服务器作为代理服务器去访问应用从而达到测试的目的。 selenium RC 使用分Client Libraries和selenium Server，Client Libraries库主要主要用于编写测试脚本，用来控制selenium Server的库。 Selenium Server负责控制浏览器行为，总的来说，Selenium Server主要包括3个部分：Launcher、Http Proxy、Core。其中Selenium Core是被Selenium Server嵌入到浏览器页面中的。其实Selenium Core就是一堆JS函数的集合，就是通过这些JS函数，我们才可以实现用程序对浏览器进行操作。Launcher用于启动浏览器，把selnium Core加载到浏览器页面当中，并把浏览器的代理设置为Selenium Server 的Http Proxy。 2、selenium 2.0 搞清了selenium 1.0 的家族关系，selenium 2.0 是把 WebDriver 加入到了这个家族中；简单用公式表示为： ​ selenium 2.0 = selenium 1.0 + WebDriver 需要强调的是，在selenium 2.0 中主推的是WebDriver ，WebDriver 是selenium RC 的替代品，因为 selenium 为了向下兼容性，所以selenium RC 并没有彻底抛弃，如果你使用selenium开发一个新自动化测试项目，强列推荐使用WebDriver 。那么selenium RC 与webdriver 主要有什么区别呢？ selenium RC 在浏览器中运行JavaScript应用，使用浏览器内置的JavaScript 翻译器来翻译和执行selenese命令（selenese 是selenium命令集合）。 WebDriver通过原生浏览器支持或者浏览器扩展直接控制浏览器。WebDriver针对各个浏览器而开发，取代了嵌入到被测Web应用中的JavaScript。与浏览器的紧密集成支持创建更高级的测试，避免了JavaScript安全模型导致的限制。除了来自浏览器厂商的支持，WebDriver还利用操作系统级的调用模拟用户输入。 如果是新项目直接学习webdriver 就OK了，RC是过时技术。 selenium学习路线配置测试环境，针对所学习语言，来配置相应的selenium 测试环境。selenium 好比定义的语义—“问好”，假如你使用的是中文，为了表术问好，你的写法是“你好”，假如你使用的是英语，你的写法是“hello”。 所以，同样有语义在不同的语言下会有不同的写法（语法）。 接着你需要熟悉webdriver API ，API就是selenium 所定义一方法，用于定位，操作页面上的各种元素。 先学习元素的定位，selenium 提供了id、name、class name、 tag name、link text、partial link text、 xpath、css等定位方法。xpath和css 功能强大语法稍微复杂，在这其间你可能还需要了解更多的前端知识。xml ，javascript 等。 定位元素的目的是为了操作元素，接就要学习各种元素的操作，输入框，下拉框，按钮点击，文件上传、下载，分页，对话框，警告框…等等。 经过一段时间的学习，你可以游刃有余的模拟手工测试来操作页面上的各种元素了。接着你需要做的就是把这些“用例”组织起来，统一来跑。 那么你需要做的就是学习并使用单元测试框架，单元测试框架本身就解决了用例的组织与运行。 当你写了一些“测试用例” 之后，你会发现用例中有大量重复的操作，能不能写到一个单独的文件中，需要的时候调用这些操作？当然可以，运用你的编程能力来实现这一点将非常简单。然后，你又发现每个用例中都有一些数据，这些数据也是一样的，但如果变化了修改起来非常麻烦，你也可以把他写到一个单独的文件中进行读取。 接着你又遇到了新的疑问，我写的脚本（用例）都是流水式的，我怎么知道用例运行失败还是成功。那么就需要在脚本中加一些验证与断言。 接着你又有了更多的想法，单元测试框架的log太简陋了，能不能生成一张漂亮的测试报告出来。我能不能定时的来跑这个脚本。能不能把每一次跑脚本的测试结果直接发到我的邮箱。能不能…… 为解决这些问题，你不得不学习更多的编程技术，然后你的“测试结构”会功能越来越强大，越来越灵活。产生了一定的通用性和移植性。一个有模有样的自动化测试框架诞生了。 总结： 配置测试环境 -&gt; 熟悉 webdriver API -&gt; 学习元素定位 -&gt; 操作元素 -&gt; 单元测试框架组织用例 -&gt; 抽取重复部分 -&gt; 加验证与断言 -&gt; 生成漂亮测试报告、定时跑脚本、测试结果发邮箱 -&gt;… PythonwebdriverAPI1、熟练掌握xpath/css定位使用；python版本的webdriver API；学习掌握js语言；与前端打交道，多熟悉前端技术，如http请求，HTML语言，cookie/session机制等 2、主要内容： 浏览器的操作（浏览器最大化；设置浏览器宽、高；控制浏览器前进、后退）； 简单对象的定位（id 和name的定位；tagname和classname定位；linktext和partiallinktext定位；xpath和css定位）； 操作测试对象（登录实例；webelement接口常用方法）； 鼠标事件；键盘事件；打印信息；设置等待时间； 定位一组对象；层级定位；定位frame中的对象；对话框处理；浏览器多窗口处理； alert/confirm/prompt处理； 下拉框处理；分页处理；上传文件；下载文件； 调用js；控制浏览器滚动条； cookie处理；获取对象的属性；验证码问题； 自动化测试模型1、一个自动化测试框架就是一个集成体系，在这一体系中包含测试功能的函数库、测试数据源、测试对象识别标准，以及可重用的模块。自动化测试框架在发展的过程中经历了几个阶段，模块驱动测试、数据驱动测试、对象驱动测试； 2、自动化测试模型：是自动化测试架构的基础； 线性测试：通过录制或编写脚本，一个脚本完成一个场景（一组完整功能操作），通过对脚本的回放来进行自动化测试；优势：每一个脚本都是独立的，任何一个脚本文件拿出来就能单独运行；缺点：用例的开发与维护成本很高；这种模式下数据和脚本是混在一起的，如果数据发生变也需要对脚本进行修改。这种模式下脚本没有可重复使用的概念。 模块化与类库：能把重复的部分写成一个公共的模块，需要的时候进行调用，这样就大大提高了编写脚本的效率；优点：提高了开发效率，不用重复的编写相同的脚本用，不同重复造轮子；方便了代码的维护； 数据驱动：数据的改变（更新）驱动自动化的执行，从而引起测试结果的改变。（可直白的理解成参数化，输入数据的不同从而引起输出结果的变化）—实现了数据与脚本的分离； 关键字驱动（我要做什么-命令？对谁做-对象？怎么做-值？）：是把“数据”换成“关键字”，通过关键字的改变引起测试结果的改变；Selenium IDE 脚本分：命令（command）、对象（target）、值（value）； 总结： 在实施自动化更多的是以需求为出发点，混合的来使用以上模型去解决问题；使脚本更易于开发与维护； 脚本的模块化与参数化是我们在自动化脚本开发中用到最多的两个技巧； 自动化测试用例设计1、测试用例是测试人员综合自己的经验从需求中挖掘和提炼而来。所以不管什么类型的测试工作，我们都不能盲目开展。任何测试工作都应该以需求为基础，以测试用例为导向进行实施； 2、手工测试用例与自动化测试用例：手工测试用例是针对手工测试人员，自动化测试用例是针对自动化测试框架，前者是手工测试用例人员应用手工方式进行用例解析，后者是应用脚本技术进行用例解析，两者最大的各自特点在于，前者具有较好的异常处理能力，而且能够基于测试用例，制造各种不同的逻辑判断，而且人工测试步步跟踪，能够细致的定位问题。而后者是完全按照测试用例的方式测试，而且异常处理能力不强，往往一个自动化测试用例运行完毕后，报一堆错误，对于测试人员来定位错误是一个难点，这样往往发现的问题很少。 手工测试用例与自动化测试用例对比： 手工测试用例： 较好的异常处理能力，能通过人为的逻辑判断校验当前步骤的功能实现正确与否； 人工执行用例具有一定的步骤跳跃性； 人工测试步步跟踪，能够细致的定位问题 ； 主要用来发现功能缺陷； 自动化测试用例： 执行对象是脚本，任何一个判断都需要编码定义； 用例步骤之间关联性强； 主要用来保证产品主体功能正确完整和让测试人员从繁琐重复的工作中解脱出来； 目前自动化测试阶段定位在冒烟测试和回归测试 ； 总结： 自动化测试替代不了手工测试，目的仅仅在于让测试人员从繁琐重复的机械式测试过程解脱出来，把时间和精力突入到更有价值的地方，从而挖掘更多的产品缺陷。目前自动化测试更多的时候是定位在冒烟测试和回归测试；冒烟测试执行的是主体功能点的用例，回归测试执行全部或部分的测试用例。 3、测试类型： 测试静态内容：静态内容测试是最简单的测试，用于验证静态的、不变化的 UI 元素的存在性； 每个页面都有其预期的页面标题，这可以用来验证链接指向一个预期的页面； 应用程序的主页包含一个应该在页面顶部的图片吗； 网站的每一个页面是否都包含一个页脚区域来显示公司的联系方式,隐私政策,以及商标信息； 每一页的标题文本都使用标签吗?每个页面有正确的头部文本内吗； 测试链接 ：Web 站点的一个常见错误为的失效的链接或链接指向无效页。链接测试涉及的各个链接和验证预期的页面是否存在。如果静态链接不经常更改，手动测试就足够。但是，如果你的网页设计师经常改变链接,或者文件不时被重定向，链接测试应该实现自动化。 功能测试：在您的应用程序中，需要测试应用的特定功能，需要一些类型的用户输入，并返回某种类型的结果。通常一个功能测试将涉及多个页面，一个基于表单的输入页面,其中包含若干输入字段、提交“和”取消“操作，以及一个或多个响应页面。用户输入可以通过文本输入域，复选框，下拉列表，或任何其他的浏览器所支持的输入。 功能测试通常是需要自动化测试的最复杂的测试类型，但也通常是最重要的。典型的测试是登录，注册网站账户，用户帐户操作，帐户设置变化，复杂的数据检索操作等等。功能测试通常对应着您的应用程序的描述应用特性或设计的使用场景。 测试动态元素：通常一个网页元素都有一个唯一的标识符，用于唯一地定位该网页中的元素。通常情况下，唯一标识符用 HTML 标记的’id’属性或’name’属性来实现。这些标识符可以是一个静态的，即不变的、字符串常量。它们也可以是动态生产值,在每个页面实例上都是变化的。例如,有些 Web 服务器可能在一个页面实例 上命名所显示的文件为 doc3861，并在其他页面实例上显示为 doc6148，这取决于用户在检索的‘文档’。验证文件是否存在的测试脚本，可能无法找到不变的识别码来定位该文件。通常情况下，具有变化的标识符的动态元素存在于基于用户操作的结果页面上，然而,显然这取决于 Web 应用程序。 Ajax 的测试：Ajax 是一种支持动态改变用户界面元素的技术。页面元素可以动态更改，但不需要浏览器重新载入页面,如动画，RSS 源，其他实时数据更新等等。Ajax 有不计其数的更新网页上的元素的方法。但是了解 AJAX 的最简单的方式，可以这样想，在 Ajax 驱动的应用程序中,数据可以从应用服务器检索，然后显示在页面上，而不需重新加载整个页面。只有一小部分的页面或者只有元素本身被重新加载。 断言 assert 与验证 verify：断言：测试将在检查失败时停止，并不运行任何后续的检查；验证：将不会终止测试； 4、python 异常断言：Try…except… ，try…finally… ，Raise 抛出异常 异常的抛出机制： 如果在运行时发生异常，解释器会查找相应的处理语句（称为 handler）； 要是在当前函数里没有找到的话，它会将异常传递给上层的调用函数，看看那里能不能处理； 如果在最外层（全局“main”）还是没有找到的话，解释器就会退出，同时打印出 traceback 以便让用户找到错误产生的原因； 注意：虽然大多数错误会导致异常，但一个异常不一定代表错误，有时候它们只是一个警告，有时候它们可能是一个终止信号，比如退出循环等。 5、weddriver 错误截图 ：Webdriver 提供错误截图函数 get_screenshot_as_file()，可以帮助我们跟踪 bug，在脚本无法继续执行时候， get_screenshot_as_file()函数将截取当前页面的截图保存到指定位置； 6、自动化测试用例设计实例：（编写自动化测试用例的原则） 一个脚本是一个完整的场景，从用户登陆操作到用户退出系统关闭浏览器； 一个脚本脚本只验证一个功能点，不要试图用户登陆系统后把所有的功能都进行验证再退出系统； 尽量只做功能中正向逻辑的验证，不要考虑太多逆向逻辑的验证，逆向逻辑的情况很多（例如手机号输错有很多种情况），验证一方面比较复杂，需要编写大量的脚本，另一方面自动化脚本本身比较脆弱， 很多非正常的逻辑的验证能力不强。（我们尽量遵循用户正常使用原则编写脚本即可）； 脚本之间不要产生关联性，也就是说编写的每一个脚本都是独立的，不能依赖或影响其他脚本； 如果对数据进行了修改，需要对数据进行还原； 在整个脚本中只对验证点进行验证，不要对整个脚本每一步都做验证； 登陆用例实例： 备注：通过匹配用户登录之后的昵称来判断用户是否登录成功。 添加文件用例实例： 备注：通过计算用户列表中的文件的数量来判断文件是否添加成功； 删除文件用例实例： 备注：因为删除了一个文件对文件的数据发生的改变，如果多次执行脚本，列表中的文件被删除完了就会引发异常，所以在删除一个文件后，需要再添加一文件，但添加文件操作不做验证。 重命名文件用例实例 ： 备注：文件的重命名其实我们很难找到证据（验证点）证明重命名成功，那么脚本整个运行没有报错， 我们也可模糊的判断功能测试是 OK 的。 引入 unittest 单元测试框架1、selenium IDE 介绍：可以将 selenium IDE 录制的脚本转换成不同语言脚本，有助于帮助我们尽快熟悉脚本语言以及测试框架； 2、引入 unittest 框架： 12345678910#Baidu 类继承 unittest.TestCase 类，从 TestCase 类继承是告诉 unittest 模块的方式，这是一个测试案例class Baidu(unittest.TestCase):#setUp 用于设置初始化的部分，在测试用例执行前，这个方法中的函数将先被调用def setUp(self): self.driver = webdriver.Firefox() self.base_url = \"http://www.baidu.com/\"#tearDown 方法在每个测试方法执行后调用，这个地方做所有测试用例执行完成的清理工作，如退出浏览器等def tearDown(self): self.driver.quit() self.assertEqual([], self.verificationErrors) 利用 Command 和 Composite 设计模式，多个 TestCase 还可以组合成测试用例集合。 组织用例集：完整的单元测试很少只执行一个测试用例，开发人员通常都需要编写多个测试用例才能对某一软件功能进行比较完整的测试，这些相关的测试用例称为一个测试用例集，在 PyUnit 中是用 TestSuite 类来表示的。 12345def suite(): suite = unittest.TestSuite() suite.addTest(WidgetTestCase(\"testSize\")) suite.addTest(WidgetTestCase(\"testResize\")) return suite 如果用于测试的类中所有的测试方法都以 test 开头，Python 程序员甚至可以用 PyUnit 模块提供的 makeSuite()方法来构造一个。 123#TestSuite 类可以看成是 TestCase 类的一个容器，用来对多个测试用例进行组织，这样多个测试用例可以自动在一次测试中全部完成。def suite(): return unittest.makeSuite(WidgetTestCase, \"test\") 运行测试集 ：PyUnit 使用 TestRunner 类作为测试用例的基本执行环境，来驱动整个单元测试过程。Python开发人员在进行单元测试时一般不直接使用 TestRunner 类，而是使用其子类 TextTestRunner 来完成测试，并将测试结果以文本方式显示出来； 12runner = unittest.TextTestRunner()runner.run(suite) 由于引入 unittest 框架的作用，一条用例失败后不会影响下一条用例的执行。 引入测试报告与结构优化1、引入漂亮的 HTMLTestRunner 测试报告，HTMLTestRunner 是 Python 标准库的 unittest 模块的一个扩展。它生成易于使用的 HTML 测试报告。 HTMLTestRunner 是在 BSD 许可证下发布； 2、测试套件 ：通过测试套件组织的用例结构； makeSuite 用于生产 testsuite 对象的实例，把所有的测试用例组装成 TestSuite，最后把 TestSuite 传给 TestRunner 进行执行。 123#将测试用例加入到测试容器(套件)中testunit.addTest(unittest.makeSuite(baidu.Baidu))testunit.addTest(unittest.makeSuite(youdao.Youdao)) 3、discover 解决用例的读取： TestLoader：测试用例加载器，其包括多个加载测试用例的方法。返回一个测试套件。 discover(start_dir，pattern=’test*.py’，top_level_dir=None) start_dir ：要测试的模块名或测试用例目录； pattern=’test.py’ ：表示用例文件名的匹配原则。星号“”表示任意多个字符； top_level_dir=None：测试模块的顶层目录。如果没顶层目录（也就是说测试用例不是放在多级目录 中），默认为 None。 自动化测试高级应用1、自动发邮件功能、多线程和定时任务，让我们的自动化工作真正变得高效而又强大起来。 2、自动发邮件功能：python 的 smtplib 模块提供了一种很方便的途径发送电子邮件。它对 smtp 协议进行了简单的封装。 一般 smtp 会话有两种方式： 邮件直接投递； 验证过后的发信 ； 3、python 多进程/线程基础： 什么是进程？ 计算机程序只不过是磁盘中可执行的，二进制（或其它类型）的数据。它们只有在被读取到内存中， 被操作系统调用的时候才开始它们的生命期。进程（有时被称为重量级进程）是程序的一次执行。每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据。操作系统管理在其上运行的所有进程，并为这些进程公平地分配时间。 什么是线程？ 线程（有时被称为轻量级进程）跟进程有些相似，不同的是，所有的线程运行在同一个进程中，共享相同的运行环境。我们可以想像成是在主进程或“主线程”中并行运行的“迷你进程”。 4、定时任务：可以设置定时任务，使我们自动化脚本在某个时间点自动运行脚本。实现这个需求的方式很多； 程序控制时间执行； windows 添加任务计划 ； linux 实现定时任务：可以通过 at 命令实现一次性计划任务，也可以通过 batch 实现周期性计划任务； 通过 at 命令创建任务：at 命令主要用于创建临时的任务，创建的任务只能被执行一次；—at -l / atq 两个命令查看 at 创建的任务—删除已经设置的任务：atrm 用于删除已经创建的任务at 命令指定时间的方式：—绝对计时方法： midnight noon teatimehh:mm [today]hh:mm tomorrowhh:mm 星期hh:mm MM/DD/YY —相对计时方法： now+n minutesmow+n hours now+n days 通过 crontab 命令创建任务：crontab 可以方便的用来创建周期性任务，也许你想每天某个时间执行 python 程序，或每周五的某个时间执行。crontab 像 windows 的计划任务一样方便，或者更加灵活 ；—crontab - e 命令进入 crontab 文件；—按键盘 i、o、a 任意一个键进入编辑状态，可以对文件进行修改；—分钟 小时 天 月 星期 命令/脚本 15 * * * * python /home/fnngj/test/file_time.py —ctrl+x 离开，提示是否保存任务？按 y 保存任务退出。（不同版本 linux 对 crontab 文件的编辑/退出会有差异。）—完成 crontab 任务创建后，会有如下提示： crontab: installing new crontab ；—启动 crontab 服务：注意（在完成编辑以后，要重新启动 cron 进程，crontab 服务操作说明） cron restart //重启服务，cron start //启动服务，cron stop //关闭服务，cron reload //重新载入配置 ； selenium grid2 分布式执行测试用例1、Selenium Grid 允许用户将测试案例分布在几台机器上并行执行。用户可以在一个集中控制点控制不同的环境。在不同的浏览器 / 系统组合上面更为容易的运行测试案例。允许用户更多的利用虚拟资源减少了维护测试环境的成本； 2、selenium-server 支持接收远程脚本的调用命令； 行为驱动开发 BDD 框架 lettuce 入门1、lettuce 是一个非常有用的和迷人的 BDD（行为驱动开发）工具。Python项目的自动化测试，它可以执行纯文本的功能描述； lettuce，使开发和测试过程变得很容易，可扩展性，可读性和-什么是最好的-它允许我们用自然语言去描述个一个系统的行为，你不能想象这些描述可以自动测试你的系统。 Feature（功能）， Scenario（情景），Given（给定）， And（和）， When（当），Then（则）； 说明：前半部分转载虫师和这篇博文，后半部分内容和插图来源于 《selenium2 python自动化测试实战》。","comments":true,"tags":[{"name":"Python Selenium","slug":"Python-Selenium","permalink":"http://yoursite.com/tags/Python-Selenium/"}]}]