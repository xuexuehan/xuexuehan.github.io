[{"title":"设计模式-观察者模式","date":"2019-03-18T02:08:53.000Z","path":"2019/03/18/设计模式-观察者模式/","text":"简单的说模式就是一种惯性的思维方式，用于解决同一类问题。 About模式：我们处理大量问题时，在很多不同的问题中重复出现的一种性质，它使得我们可以使用一种方法来描述问题实质并用本质上相同，但细节永不会重复的方法去解决，这种性质就叫模式。简单的说模式就是一种惯性的思维方式，用于解决同一类问题； 观察者模式（Observer）：何谓观察者模式？观察者模式定义了对象之间的一对多依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。 在这里，发生改变的对象称之为观察目标，而被通知的对象称之为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，所以么可以根据需要增加和删除观察者，使得系统更易于扩展。 所以观察者提供了一种对象设计，让主题和观察者之间以松耦合的方式结合。 简单例子观察者模式具备：事件的源、事件对象、事件处理对象； 以西游记为例，唐僧就是事件源，孙悟空、猪八戒、沙僧都是事件处理对象，事件对象包含有关事件和事件的源信息（就是记录唐僧发生事件的信息）； 先写事件对象类： TangEvent（记录唐僧发生事件的信息）： 1234567891011public class TangEvent &#123; private String eventStr; public TangEvent() &#123; &#125; public TangEvent(String eventStr) &#123; this.eventStr = eventStr; &#125; public String getEventStr() &#123; return eventStr; &#125;&#125; 接着写可以处理唐僧发生事件的接口类（Apprentice），只要是唐僧的徒弟就可以处理唐僧发生的事件，徒弟的功能就是观察唐僧看是否有事件需要处理： 123public interface Apprentice &#123; public void lookTS(TangEvent e);&#125; 再写可以处理事件的具体徒弟类，实现徒弟接口： 孙悟空实现类： 12345678910public class SunApprentice implements Apprentice &#123; @Override public void lookTS(TangEvent e) &#123; if(\"白骨精\".equals(e.getEventStr())) &#123; System.out.println(\"三打白骨精!\"); &#125; else if(\"女儿国王\".equals(e.getEventStr())) &#123; System.out.println(\"全凭师父定力！\"); &#125; &#125;&#125; 猪八戒实现类： 12345678910public class ZhuApprentice implements Apprentice &#123; @Override public void lookTS(TangEvent e) &#123; if(\"白骨精\".equals(e.getEventStr())) &#123; System.out.println(\"白骨精不是妖怪!\"); &#125; else if(\"女儿国王\".equals(e.getEventStr())) &#123; System.out.println(\"将师父留在女儿国吧！\"); &#125; &#125;&#125; 沙僧实现类： 12345678910public class ShaApprentice implements Apprentice &#123; @Override public void lookTS(TangEvent e) &#123; if(\"白骨精\".equals(e.getEventStr())) &#123; System.out.println(\"千万别误伤好人!\"); &#125; else if(\"女儿国王\".equals(e.getEventStr())) &#123; System.out.println(\"担心师父在女儿国王那有事！\"); &#125; &#125;&#125; 写事件源类（三要素：私有的监听者列表，公有的向监听者列表添加监听者的方法，公有的发生事情的方法）： 12345678910111213public class Tang &#123; private List&lt;Apprentice&gt; list = new ArrayList&lt;Apprentice&gt;();//私有的监听者列表 public void addTangListener(Apprentice apprentice) &#123;//公有的向监听者列表添加监听者的方法 this.list.add(apprentice); &#125; public void tangAction(String s) &#123;//公有的发生事情的方法 TangEvent tangEvent = new TangEvent(s); for(int i = 0; i &lt; this.list.size(); i++) &#123; Apprentice apprentice = this.list.get(i); apprentice.lookTS(tangEvent); &#125; &#125;&#125; 最后写一个Run类，事件源添加监听者实现类的实例： 1234567891011121314public class Run &#123; public static void main(String[] args) &#123; Tang tang = new Tang(); SunApprentice sun = new SunApprentice(); ZhuApprentice zhu = new ZhuApprentice(); ShaApprentice sha = new ShaApprentice(); //事件源加监听者实现类的实例 tang.addTangListener(sun); tang.addTangListener(zhu); tang.addTangListener(sha); tang.tangAction(\"白骨精\"); tang.tangAction(\"女儿国王\"); &#125;&#125; 至此，一个简单的观察者模式小例子完成。其实，在java中，我们不必像上面那样全都需要自己手动写，最后那个Run才需要我们自己完成。 事件源添加监听者接口实例四种方法： 1、自己加自己 2、自己加别人（实现接口） 3、自己加别人（适配器） 4、参数匿名类（适配器） 以Java Swing为例，先看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class MyFrame extends JFrame implements MouseListener &#123; private JPanel bodyPanel = null; private JButton b1 = null; private JButton b2 = null; private JButton b3 = null; private JButton b4 = null; private void init() &#123; this.bodyPanel = (JPanel)this.getContentPane(); this.bodyPanel.setLayout(new GridLayout(2, 2)); this.b1 = new JButton(\"b1\"); this.b1.addMouseListener(this);//自己加自己 this.bodyPanel.add(this.b1); this.b2 = new JButton(\"b2\"); MyListener1 myListener1 = new MyListener1(); this.b2.addMouseListener(myListener1);//自己加别人（实现接口） this.bodyPanel.add(this.b2); this.b3 = new JButton(\"b3\"); this.b3.addMouseListener(new MyListener2());//自己加别人（适配器） this.bodyPanel.add(this.b3); this.b4 = new JButton(\"b4\"); this.b4.addMouseListener(new MouseAdapter() &#123;//参数匿名类（适配器） public void mouseEntered(MouseEvent e) &#123; b4.setBackground(Color.BLACK); &#125; @Override public void mouseExited(MouseEvent e) &#123; b4.setBackground(Color.ORANGE); &#125; &#125;); this.bodyPanel.add(this.b4); this.setBounds(10, 10, 400, 400); this.setTitle(\"监听者模式\"); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public MyFrame() &#123; this.init(); &#125; public static void main(String[] args) &#123; MyFrame frame = new MyFrame(); frame.setVisible(true); &#125; @Override public void mouseClicked(MouseEvent e) &#123; &#125; @Override public void mousePressed(MouseEvent e) &#123; &#125; @Override public void mouseReleased(MouseEvent e) &#123; &#125; @Override public void mouseEntered(MouseEvent e) &#123; if(e.getSource() == this.b1) &#123; this.b1.setBackground(Color.RED); this.b4.setBackground(Color.BLUE); &#125; &#125; @Override public void mouseExited(MouseEvent e) &#123; if(e.getSource() == this.b1) &#123; this.b1.setBackground(Color.BLUE); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728public class MyListener1 implements MouseListener &#123; @Override public void mouseClicked(MouseEvent e) &#123; &#125; @Override public void mousePressed(MouseEvent e) &#123; &#125; @Override public void mouseReleased(MouseEvent e) &#123; &#125; @Override public void mouseEntered(MouseEvent e) &#123; JButton b2 = (JButton)e.getSource(); b2.setBackground(Color.BLUE); &#125; @Override public void mouseExited(MouseEvent e) &#123; JButton b2 = (JButton)e.getSource(); b2.setBackground(Color.GREEN); &#125;&#125; 12345678910111213public class MyListener2 extends MouseAdapter &#123; @Override public void mouseEntered(MouseEvent e) &#123; JButton b3 = (JButton)e.getSource(); b3.setBackground(Color.YELLOW); &#125; @Override public void mouseExited(MouseEvent e) &#123; JButton b3 = (JButton)e.getSource(); b3.setBackground(Color.PINK); &#125;&#125; 从代码也可以看出，适配器里面其实是一些空实现的方法，可以避免代码出现过多的空方法。 参考文章：http://cmsblogs.com/?p=3396#7Observer","comments":true,"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"零基础入门C语言","date":"2019-03-09T02:31:51.000Z","path":"2019/03/09/C语言入门/","text":"轻松入门C语言，通俗易懂的小例子理解C语言的三大结构 About面向对象和面向过程 面向过程就是人看待事物的眼光和思想，关注于步骤； 面向对象是一种对现实世界理解和抽象的方法； 面向过程—&gt;怎么做、面向对象—&gt;谁在做； 学习C语言的方法（其他语言类似） 入门：先了解背景、市场占有率、这门语言主要用途、前景如何、哪个公司发明； 最小单元：常量、变量、数据类型； 次小单元：运算符、表达式； 结构：业务逻辑（顺序结构、分支结构、循环结构）； 高级部分：数组、函数； 特征（语言所特有部分）：指针； 基础部分程序的入门 程序：做一件事情的过程，作用：计算机模拟现实生活，从而达到降低成本，提高效率的效果； 计算机中的程序：为了让计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合； 算法就是对解决问题的方法的描述，算法是描述、程序是执行； 算法固性：有穷性（步骤有限）、确定性（步骤清晰不模糊） 、交互性（具有输入输出）、有效性（步骤有效）； 如何表示算法：自然语言（需求分析）、流程图（概要设计-避免歧义）、伪代码（详细设计）、程序语言（出差：需求、部署）； C语言：面向过程的结构化语言，三种基本结构：顺序结构、分支选择结构、循环结构； 基础知识 低级语言：（汇编）机器语言，可以直接操作计算机硬件；中级语言（C），指针可操作计算机硬件，人类语言；高级语言：（Java）人类语言，经过编译变成机器语言，机器才能执行； 编译：语法查错、转成机器语言（转译）； C语言优点：既能开发系统程序，又能开发应用程序； C语言：面向过程，结构化的（顺序，分支，循环），函数语言； 学习方法：wwwh（why, what, when, how），程序 = 数据结构 + 算法； 最小单元变量和常量 最小的盛放数据单元； 常量：值不能改变的量，一般常量和符号常量（用#define定义，一改全改）； 变量：值可以改变的量，变量的本质是一片连续的内存空间，变量是一个容器，用来存放数据； C语言规定：变量必须先声明，再赋值，后使用；所有变量定义在函数首部，有了执行语句，就不能再有定义语句； 变量命名规则（三条）: ​ —必须以数字，字母，下划线组成，以字母或下划线开头； ​ —见名知义，首字母小写； ​ —变量不能和关键字重名，区分大小写； 基本数据类型 基本数据类型：运算法则、约束内存空间大小的单位； 数值：整型（int，short int，long int）和非整型（float，double），非数值：char； 1个字节 = 8位 、一个中文字符 = 2个字节 、一个英文字符 = 1个字节； C语言中没有字符串变量，用字符数组模拟字符串变量（难用）； ASCII码：0~9（48~57），A~Z（65~90），a~z（97~122）， C语言中char和int完全兼容； 类型转换: ​ —&gt;自动类型转换：把范围小的类型的值转换为范围大的类型的值：（ short, int, long, float, double）； ​ —&gt;强制类型转换：(类型名)变量或数值； 转义字符：转为其他的意思（\\t， \\n等）； C语言的输入输出：getchar() ，putchar()，输入输出字符； scanf() ，printf()输入输出任何东西，（sacnf和printf中的f是format的意思，即格式化输入和输出）； 次小单元运算符&amp;表达式 表达式：操作数 + 运算符； 数学表达式、赋值表达式、关系表达式、逻辑表达式； 算数运算符：+、-、* 、/、%（二目）， /：两边都是整数取整，/：两边至少一边为实型求精确值，%：要求两边都是整型，求余； 12345678910111213141516171819202122232425262728//算数运算符练习：回文数：void main() &#123; int ge, shi, qian, wan, x; printf(\"请输入一个五位数：\"); scanf(\"%d\", &amp;x); wan = x / 10000; qian = x % 10000 / 1000; shi = x % 100 / 10; ge = x % 10; if(wan == ge &amp;&amp; qian == shi) &#123; printf(\"%d是回文数\\n\", x); &#125; else &#123; printf(\"%d不是回文数\\n\", x); &#125;&#125;//水仙花数：void main() &#123; int n, ge, shi, bai; for(n = 100; n &lt;= 999; n++) &#123; ge = n % 10; shi = n % 100 / 10; bai = n / 100; if(ge * ge * ge + shi * shi * shi + bai * bai * bai == n) &#123; printf(\"%d\\n\", n); &#125; &#125;&#125; ++、–（一目），单个语句时a++和++a效果一样，参与运算时a++和++a效果不一样； 123456789//自增自减练习：void main() &#123; int a = 1, b = 2, c = 3, d, e, f; d = ++a; e = a + b; f = (b--) + c; printf(\"%d %d %d %d %d %d\\n\", a, b, c, d, e, f);&#125; 运行结果：2 1 3 2 4 5 赋值：变量 = 表达式； 关系运算符：&gt;、&gt;=、！=、==、&lt;、&lt;=； 逻辑运算符（与、或、非）：&amp;&amp;、||、！； C语言中：用0代表假，非零代表真；sizeof：可以获得数据类型占用内存空间的大小 ；sizeof(type_name) 结果以字节为单位显示； 三种结构顺序结构分支选择结构 if：（布尔常量， 布尔变量， 比较表达式， 逻辑表达式）； 多分支（否定式： 多重if-else、 switch-case）； 123456789101112131415161718192021222324252627282930313233343536//多重if-elsevoid main() &#123; int f; printf(\"请问你送几朵花：\"); scanf(\"%d\", &amp;f); if(f &gt;= 9 &amp;&amp; f &lt; 99) &#123; printf(\"笑一笑\"); &#125; else if(f &gt;= 99 &amp;&amp; f &lt; 999) &#123; printf(\"拉拉手\"); &#125; else if(f &gt;= 999) &#123; printf(\"抱一抱\"); &#125; else &#123; printf(\"不高兴\"); &#125; &#125;解释：程序能进入到下一个elseif语句块，说明前面if里的条件不成立//switch-casevoid main() &#123; int f; printf(\"请问你送几朵花：\"); scanf(\"%d\", &amp;f); switch(f) &#123; case 9: printf(\"笑一下\"); break; case 99: printf(\"拉拉手\"); break; case 999: printf(\"抱一下\"); break; default: printf(\"不高兴\"); &#125; &#125;解释：程序能进入到下一个case语句块，说明前面case里的条件不成立，每个case后应该有break语句，否则程序会执行当前case条件满足后的所有语句，不符逻辑。 （肯定式：If嵌套）； 1234567891011121314151617181920void main() &#123; int work, house, car; printf(\"请输入你的资源：\"); scanf(\"%d %d %d\", &amp;work, &amp;house, &amp;car); if(work) &#123; if(house) &#123; if(car) &#123; printf(\"赶紧结婚\"); &#125; else &#123; printf(\"买了车就结婚\"); &#125; &#125; else &#123; printf(\"无房不嫁女\"); &#125; &#125; else &#123; printf(\"先好好提升自己\"); &#125;&#125;解释：当进入下一个if条件判断时，说明满足之前if的判断条件。 switch-case：switch()里可以是整型常量，整型变量，整型表达式；case后面必须是整型常量，case最后一句跟break；case后面不能跟相同的值，case可以随意倒顺序； 条件运算符：a &gt; b ? c : d —-如果a &gt; b成立，则结果为C，否则为d； 循环结构 循环的本质：有规律的重复的做一件事； 循环分类：（小括号—规律，花括号—重复），规律：已知循环次数（循环变量i）和未知循环次数（循环的开关）；循环体：当型、直到型； 当型（while-未知循环次数、for-已知循环次数），直到型：do-while（已知循环次数和未知循环次数）； 12345678910111213141516171819202122232425262728293031323334353637383940414243//whilevoid main() &#123; int i = 0, j = 0; while(i &lt; 10) &#123; printf(\"第%d个同学演节目开始！\", (i + 1)); while(j &lt; 3) &#123; printf(\"第%d个节目!\", (j + 1)); j++; &#125; j = 0; printf(\"第%d个同学演节目结束！\\n\", (i + 1)); i++; &#125;&#125;//forvoid main() &#123; int i, j; for(i = 0; i &lt; 10; i++) &#123; printf(\"第%d个同学演节目开始！\", (i + 1)); for(j = 0; j &lt; 3; j++) &#123; printf(\"第%d个节目！\", (j + 1)); &#125; printf(\"第%d个同学演节目结束！\\n\", (i + 1)); &#125;&#125;//do-while（猜数字）void main() &#123; int flag = 1; int num = 8, guess; printf(\"请输入一个1~10之间的数！\"); do &#123; printf(\"请输入：\"); scanf(\"%d\", &amp;guess); if(guess &lt; num) &#123; printf(\"小了！\"); &#125; else if(guess &gt; num) &#123; printf(\"大了！\"); &#125; else &#123; flag = 0; &#125; &#125; while(flag); printf(\"恭喜你答对了！\");&#125; 已知循环次数：循环变量在外面定义并初始化，循环变量在循环体里进行自增或自减； 循环的嵌套：外层一趟，内层一遍； for循环：for（表达式1；表达式2；表达式3）， ​ 表达式1：循环变量赋初值； ​ 表达式2：循环条件； ​ 表达式3：更新循环变量值； break与continue：break，终止，在多层循环中，一个break语句只向外跳一层循环；continue：中止，只能用在循环里，跳过循环体中剩余的语句而执行下一次；对于while和do-while循环（continue语句执行之后的动作是条件判断），对于for循环，随后的动作是变量更新； 一般情况下，这几种循环体用的概率：for（60%）、while（25%）、do-while（15%）； 高级部分数组 why？数据带上结构：贴近现实生活，操作、维护方便； 主要内容：数组名、数组大小、数组下标、数组容器的样子、数组类型； 变量&amp;数组比较： ​ 变量：值可变的量、一片连续的内存空间、小容器； ​ 数组：一组数放在一起、一片连续的有序的类型相同的空间、大容器； 种类：一维、二维、多维； 一维数组声明： 1datatype arrayName[size]; //（size：整型常量） 静态定义（三种）： 123int num[5] = &#123;1, 2, 3, 4, 5&#125;;int n1[] = &#123;1, 2, 3&#125;;int n2[5] = &#123;1, 2, 3&#125; 动态定义（循环初始化）； 字符数组模拟字符串变量： 1char c[2] = \"ok\"； 输入输出字符串：gets(),puts()—可输入空格； 二维数组声明： 静态定义（两种）： 12int num[2][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;;int num[][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; 动态定义（使用for循环初始化）； 1234567891011121314151617//找数字：void main() &#123; int n = 8, i; int num[10]; for(i = 0; i &lt; 10; i++) &#123; scanf(\"%d\", &amp;num[i]); &#125; for(i = 0; i &lt; 10; i++) &#123; if(n == num[i]) &#123; printf(\"找到了：%d, 位置：%d\", num[i], i + 1); break; &#125; &#125; if(i == 10) &#123; printf(\"对不起，没找到！\"); &#125;&#125; 函数 使用函数四个优点： ​ 让主调函数更简短清晰； ​ 提高代码维护效率； ​ 提高代码开发效率； ​ 提高代码复用率； 函数类型： ​ 内置函数—函数原型，功能，在哪个工具箱（头文件）放着； ​ 自定义函数； rand（）：伪随机函数； 12srand((unsigned)time(NULL))---作种函数（每次出来的随机数不一样）；//没有这句，程序运行每次随机数一样 自定义函数：返回值类型 函数名（[参数的数据类型 参数名],…），函数一次性只能返回一个值； 一个函数只做一件事；（高内聚） 函数原型说明：int add(int a, int b)或int add(int, int)； 函数的参数：函数定义中声明的参数是形参，函数调用时传入的参数就是实参； 函数参数的传递：值传递（将实参拷贝一份赋值给形参），址传递（让形参和实参共享一片内存空间，即内存地址相同）； 12345678910111213141516171819202122//值拷贝传递void add(int x, int y) &#123; x++; y++;&#125;void main() &#123; int a = 1, b = 2; add(a, b); printf(\"%d %d\", a, b);&#125;运行结果：1 2//址传递void add(int n[2]) &#123; n[0]++; n[1]++;&#125;void main() &#123; int a[2] = &#123;1, 2&#125;; add(a); printf(\"%d %d\", a[0], a[1]);&#125;运行结果：2 3 变量作用域： 变量的有效范围 —&gt; 全局、局部； 123456789101112131415161718192021222324252627//简单彩票机void main() &#123; int i = 0, j, m; int lottery[7]; srand((unsigned)time(NULL)); printf(\"请问您是否要购买彩票？\"); printf(\"请选择：1-是，0-否\\n\"); scanf(\"%d\", &amp;m); if(m) &#123; do&#123; lottery[i] = (rand() % 33) + 1; for(j = 0; j &lt; i; j++) &#123; if(lottery[j] == lottery[i]) &#123; break; &#125; &#125; if(!(j &lt; i)) &#123; i++; &#125; &#125; while(i &lt; 7); for(i = 0; i &lt; 7; i++) &#123; printf(\"%d \", lottery[i]); &#125; &#125; else &#123; return 0; &#125;&#125; 特征指针 指针：就是内存地址，一个变量只有一个指针； 指针变量：用来存放地址的变量，变量的指针：变量的地址； 关键的运算符：&amp; 取地址符、* 指针运算符； int p== (int )p； n[i - 1] = (n + (i - 1)) = (p + (i - 1))；","comments":true,"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C语言/"}]}]