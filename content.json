[{"title":"Java基础（二）","date":"2019-06-24T11:15:21.000Z","path":"2019/06/24/Java-Common-Two/","text":"Java：跨平台、 String Pool、JVM内存机制、GC、内存泄露与溢出。 Java跨平台1、平台无关性：一种语言在计算机上的运行不受平台的约束，一次编译，到处执行（Write Once ，Run Anywhere）。 也就是说，用Java创建的可执行二进制程序，能够不加改变的运行于多个平台。 2、平台无关性的实现：对于Java的平台无关性的支持，就像对安全性和网络移动性的支持一样，是分布在整个Java体系结构中的。其中扮演者重要的角色的有Java语言规范、Class文件、Java虚拟机（JVM）等。 3、Java虚拟机： 对于不同的硬件和操作系统，最主要的区别就是指令不同。比如同样执行a+b，A操作系统对应的二进制指令可能是10001000，而B操作系统对应的指令可能是11101110。那么，想要做到跨平台，最重要的就是可以根据对应的硬件和操作系统生成对应的二进制指令。 而这一工作，主要由Java虚拟机完成。虽然Java语言是平台无关的，但是JVM却是平台有关的，不同的操作系统上面要安装对应的JVM。 所以，Java之所以可以做到跨平台，是因为Java虚拟机充当了桥梁。他扮演了运行时Java程序与其下的硬件和操作系统之间的缓冲角色。 4、字节码： 各种不同的平台的虚拟机都使用统一的程序存储格式——字节码（ByteCode）是构成平台无关性的另一个基石。Java虚拟机只与由自己码组成的Class文件进行交互。 我们说Java语言可以Write Once ,Run Anywhere。这里的Write其实指的就是生成Class文件的过程。 因为Java Class文件可以在任何平台创建，也可以被任何平台的Java虚拟机装载并执行，所以才有了Java的平台无关性。 5、Java语言规范： 已经有了统一的Class文件，以及可以在不同平台上将Class文件翻译成对应的二进制文件的Java虚拟机，Java就可以彻底实现跨平台了吗？ 其实并不是的，Java语言在跨平台方面也是做了一些努力的，这些努力被定义在Java语言规范中。 比如，Java中基本数据类型的值域和行为都是由其自己定义的。而C/C++中，基本数据类型是由它的占位宽度决定的，占位宽度则是由所在平台决定的。所以，在不同的平台中，对于同一个C++程序的编译结果会出现不同的行为。 通过保证基本数据类型在所有平台的一致性，Java语言为平台无关性提供强了有力的支持。 总结： 对于Java的平台无关性的支持是分布在整个Java体系结构中的。其中扮演着重要的角色的有Java语言规范、Class文件、Java虚拟机等。 Java语言规范：通过规定Java语言中基本数据类型的取值范围和行为； Class文件：所有Java文件要编译成统一的Class文件； Java虚拟机：通过Java虚拟机将Class文件转成对应平台的二进制文件等。 Java的平台无关性是建立在Java虚拟机的平台有关性基础之上的，是因为Java虚拟机屏蔽了底层操作系统和硬件的差异。 字符串常量池（String Pool）字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 123456789101112//s1 和 s2 采用 new String() 的方式新建了两个不同字符串String s1 = new String(\"aaa\");String s2 = new String(\"aaa\");System.out.println(s1 == s2); // false//s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。String s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true//如果采用 \"bbb\" 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。String s5 = \"bbb\";String s6 = \"bbb\";System.out.println(s5 == s6); // true new String(“abc”)：使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。 “abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量； 使用 new 的方式会在堆中创建一个字符串对象。 JVM内存机制 方法区：类结构的样子、静态属性、静态方法； 堆：对象的实例、数组； 栈：对象的引用、基本数据类型； 栈（最快）&gt; 堆（容量大、速度慢）。 123456789101112131415161718public class People &#123; private String name; private String sex; public static int myNum = 0; public void eat() &#123;&#125; public void sleep() &#123;&#125; public static void think() &#123;&#125; public People(String name, String sex) &#123; this.name = name; this.sex = sex; &#125; public static void main(String[] args) &#123; int[] num = &#123;1, 2, 3&#125;; int a = 1; People p1 = new People(\"叮当\", \"男\"); People p2 = new People(\"超人\", \"男\"); &#125;&#125; 上述代码对应的内存图示如下： JVM内存结构：Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。 JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。 程序计数器（PC Register）：是当前线程所执行的字节码的行号指示器。在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 每条线程都有一个独立的程序计数器，所以程序计数器是线程私有的内存区域。 Java虚拟机栈：描述Java方法执行的内存模型，每个方法执行的同时会创建一个栈帧，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 Java虚拟机栈是线程私有的，它的生命周期与线程相同。 本地方法栈：本地方法栈与虚拟机栈的区别：虚拟机栈为虚拟机执行Java方法服务（也就是字节码），而本地方法栈为虚拟机使用到的Native方法服务。 Java堆：Java堆是被所有的线程共享的一块内存区域，在虚拟机启动时创建。Java堆的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 Java堆是垃圾回收器管理的主要区域，从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆可以细分为：新生代、老生代；从内存分配的角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区（TLAB）。 方法区：被所有的线程共享的一块内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 Java内存模型：Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。 Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。 在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。 Java对象模型：Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。 每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。 总结： JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。 垃圾回收机制垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。 引用：如果Reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。 强引用（Strong Reference）：如“Object obj = new Object（）”，这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。 软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2之后提供了SoftReference类来实现软引用。 弱引用（Weak Reference）：它也是用来描述非须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。 虚引用（Phantom Reference）：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供了PhantomReference类来实现虚引用。 对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆（heap）中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”.当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。但是，为了保证GC能够在不同平台实现的问题，Java规范对GC的很多行为都没有进行严格的规定。例如，对于采用什么类型的回收算法、什么时候进行回收等重要问题都没有明确的规定。因此，不同的JVM的实现者往往有不同的实现算法。这也给Java程序员的开发带来行多不确定性。 增量式GC（IncrementalGC）：设计GC的时候，就必须在停顿时间和回收率之间进行权衡。增量式GC就是通过一定的回收算法，把一个长时间的中断，划分为很多个小的中断，通过这种方式减少GC对用户程序的影响。 为什么要进行垃圾回收？ 随着程序的运行，内存中存在的实例对象、变量等信息占据的内存越来越多，如果不及时进行垃圾回收，必然会带来程序性能的下降，甚至会因为可用内存不足造成一些不必要的系统异常。 哪些“垃圾”需要回收？ 有三个是不需要进行垃圾回收的：程序计数器、JVM栈、本地方法栈。因为它们的生命周期是和线程同步的，随着线程的销毁，它们占用的内存会自动释放，所以只有方法区和堆需要进行GC。具体到哪些对象的话，简单概况一句话：如果某个对象已经不存在任何引用，那么它可以被回收。通俗解释一下就是说，如果一个对象，已经没有什么作用了，就可以被当废弃物被回收了。 什么时候进行垃圾回收？ 根据一个经典的引用计数算法，每个对象添加一个引用计数器，每被引用一次，计数器加1，失去引用，计数器减1，当计数器在一段时间内保持为0时，该对象就认为是可以被回收得了。但是，这个算法有明显的缺陷：当两个对象相互引用，但是二者已经没有作用时，按照常规，应该对其进行垃圾回收，但是其相互引用，又不符合垃圾回收的条件，因此无法完美处理这块内存清理，因此Sun的JVM并没有采用引用计数算法来进行垃圾回收。而是采用一个叫：根搜索算法，如下图： 基本思想就是：从一个叫GC Roots的对象开始，向下搜索，如果一个对象不能到达GC Roots对象的时候，说明它已经不再被引用，即可被进行垃圾回收（此处 暂且这样理解，其实事实还有一些不同，当一个对象不再被引用时，并没有完全“死亡”，如果类重写了finalize()方法，且没有被系统调用过，那么系统会调用一次finalize()方法，以完成最后的工作，在这期间，如果可以将对象重新与任何一个和GC Roots有引用的对象相关联，则该对象可以“重生”，如果不可以，那么就说明彻底可以被回收了），如上图中的Object5、Object6、Object7，虽然它们3个依然可能相互引用，但是总体来说，它们已经没有作用了，这样就解决了引用计数算法无法解决的问题。 为什么要分代? 分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。 在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。 虚拟机中的共划分为三个代：年轻代(Young Generation)、年老代(Old Generation)和持久代(Permanent Generation)。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。 年轻代：所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区(两个中的一个)，当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的(多于两个)，这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。 年老代：在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 持久代：用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显着影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。 什么情况下触发垃圾回收？ 由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。 Scavenge GC：一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。 Full GC：对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC： 年老代(Tenured)被写满； 持久代(Perm)被写满； System.gc()被显示调用； 上一次GC之后Heap的各域分配策略动态变化。 常见的GC算法： 标记-清除算法（Mark-Sweep）：最基础的GC算法，将需要进行回收的对象做标记，之后扫描，有标记的进行回收，这样就产生两个步骤：标记和清除。这个算法效率不高，而且在清理完成后会产生内存碎片，这样，如果有大对象需要连续的内存空间时，还需要进行碎片整理，所以，此算法需要改进。 复制算法（Copying）：新生代内存分为了三份，Eden区和2块Survivor区，一般Sun的JVM会将Eden区和Survivor区的比例调为8:1，保证有一块Survivor区是空闲的，这样，在垃圾回收的时候，将不需要进行回收的对象放在空闲的Survivor区，然后将Eden区和第一块Survivor区进行完全清理，这样有一个问题，就是如果第二块Survivor区的空间不够大怎么办？这个时候，就需要当Survivor区不够用的时候，暂时借持久代的内存用一下。此算法适用于新生代。 标记-整理（或叫压缩）算法（Mark-Compact）：和标记-清楚算法前半段一样，只是在标记了不需要进行回收的对象后，将标记过的对象移动到一起，使得内存连续，这样，只要将标记边界以外的内存清理就行了。此算法适用于持久代。 常见的一些垃圾收集器： 串行GC（SerialGC）：是最基本、最古老的收集器，但是现在依然被广泛使用，是一种单线程垃圾回收机制，而且不仅如此，它最大的特点就是在进行垃圾回收的时候，需要将所有正在执行的线程暂停（Stop The World），对于有些应用这是难以接受的，但是我们可以这样想，只要我们能够做到将它所停顿的时间控制在N个毫秒范围内，大多数应用我们还是可以接受的，而且事实是它并没有让我们失望，几十毫米的停顿我们作为客户机（Client）是完全可以接受的，该收集器适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式。 并行GC（ParNew）：基本和Serial GC一样，但本质区别是加入了多线程机制，提高了效率，这样它就可以被用在服务器端（Server）上，同时它可以与CMS GC配合，所以，更加有理由将它置于Server端。 并行回收GC（Parallel Scavenge）：在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式。 CMS (Concurrent Mark Sweep)收集器。该收集器目标就是解决Serial GC 的停顿问题，以达到最短回收时间。常见的B/S架构的应用就适合用这种收集器，因为其高并发、高响应的特点。CMS收集器是基于“标记-清除”算法实现的。 总结：Java垃圾回收器是一种“自适应的、分代的、停止—复制、标记-清扫”式的垃圾回收器。 内存泄漏和溢出区别 内存泄漏（memory leak）：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。 内存溢出（ out of memory） ：指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。 博客转自： https://www.hollischuang.com/archives/category/java https://blog.csdn.net/zhangerqing/article/details/8214365#commentBox","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础（一）","date":"2019-06-23T02:29:29.000Z","path":"2019/06/23/Java-Common-one/","text":"Java：三大特性、 重写与重载、接口与实现类。 封装、继承、多态1、封装：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。 使用封装的优点： 良好的封装能够减少耦合； 类内部的结构可以自由修改； 可以对成员进行更精确的控制； 隐藏信息，实现细节。 12345678910111213141516171819202122//封装可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码private String age ; //原来int类型，改成String类型的public void setAge(int age) &#123; //转换即可 this.age = String.valueOf(age);&#125;//可以对成员变量进行更精确的控制，对对象的入口、出口进行控制public void setAge(int age) &#123; if(age &gt; 120) &#123; System.out.println(\"Error: error age input.\"); &#125; else &#123; this.age = age; &#125;&#125;public String getSex() &#123; if(\"0\".equals(sex)) &#123; sex = \"男\"; &#125; else if(\"1\".equals(sex)) &#123; sex = \"女\"; &#125; return sex;&#125; 2、继承：复用代码的一种方式。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。 继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。 继承定义了类如何相互关联，共享特性。 在使用继承时需要注意： 子类拥有父类非private的属性和方法； 子类可以拥有自己属性和方法，即子类可以对父类进行扩展； 子类可以用自己的方式实现父类的方法（重写）。 构造器：只能够被调用，而不能被继承。调用父类的构造方法使用super()即可。 总结：对于继承来说，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。 protected关键字：将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。 向上转型： 将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型。由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是属性和方法的丢失。这就是为什么编译器在“未曾明确表示转型”或“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。 谨慎继承，继承存在如下缺陷： 父类变，子类就必须变； 继承破坏了封装，对于父类而言，它的实现细节对于子类来说都是透明的； 继承是一种强耦合关系。 3、多态：指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。 Java中多态的实现方式：接口实现、继承父类进行方法重写、同一个类中进行方法重载。 Java实现多态有三个必要条件：继承、重写、向上转型； 继承：在多态中必须存在有继承关系的子类和父类； 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法； 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。 多态机制遵循的原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class A &#123; public String show(D obj) &#123; return (\"A and D\"); &#125; public String show(A obj) &#123; return (\"A and A\"); &#125;&#125;public class B extends A &#123; public String show(B obj)&#123; return (\"B and B\"); &#125; public String show(A obj)&#123; return (\"B and A\"); &#125;&#125;public class C extends B &#123;&#125;public class D extends B &#123;&#125;public class Test &#123; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(\"1--\" + a1.show(b)); System.out.println(\"2--\" + a1.show(c)); System.out.println(\"3--\" + a1.show(d)); System.out.println(\"4--\" + a2.show(b)); System.out.println(\"5--\" + a2.show(c)); System.out.println(\"6--\" + a2.show(d)); System.out.println(\"7--\" + b.show(b)); System.out.println(\"8--\" + b.show(c)); System.out.println(\"9--\" + b.show(d)); &#125;&#125;结果：1--A and A2--A and A3--A and D4--B and A5--B and A6--A and D7--B and B8--B and B9--A and D 总结：面向对象编程有三大特性：封装、继承、多态。 封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而言它的内部细节是隐藏的，暴露给外界的只是它的访问方法。 继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。 多态指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定。 重写与重载1、定义： 重载（Overloading）：函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。 重写（Overriding）：在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。 2、重载 VS 重写： 重载是一个编译期概念、重写是一个运行期间概念； 重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法； 重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法； 因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）。 3、重写有以下三个限制： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型； 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。 1234567891011121314151617181920public class Dog &#123; public void bark() &#123; System.out.println(\"woof \"); &#125;&#125;public class Hound extends Dog &#123; public void sniff() &#123; System.out.println(\"sniff \"); &#125; public void bark() &#123; System.out.println(\"bowl \"); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Dog dog = new Hound(); dog.bark(); &#125;&#125;结果：bowl 4、重载： 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 应该注意的是，返回值不同，其它都相同不算是重载。 123456789//定义了两个bark方法，一个是没有参数的bark方法，另外一个是包含一个int类型参数的bark方法。在编译期，编译期可以根据方法签名（方法名和参数情况）情况确定哪个方法被调用。public class Dog &#123; public void bark() &#123; System.out.println(\"woof \"); &#125; public void bark(int num) &#123; System.out.println(\"woof \" + num); &#125;&#125; 接口与抽象类抽象类与接口是java语言中对抽象概念进行定义的两种机制，正是由于他们的存在才赋予java强大的面向对象的能力。他们两者之间对抽象概念的支持有很大的相似，甚至可以互换，但是也有区别。 1、抽象类： 抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可； 抽象方法必须由子类来进行重写； 只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法； 抽象类中可以包含具体的方法，当然也可以不包含抽象方法； 子类中的抽象方法不能与父类的抽象方法同名； abstract不能与final并列修饰同一个类； abstract 不能与private、static、final或native并列修饰同一个方法。 创建抽象类和抽象方法非常有用，因为他们可以使类的抽象性明确起来,并告诉用户和编译器打算怎样使用他们。抽象类还是有用的重构器，因为它们使我们可以很容易地将公共方法沿着继承层次结构向上移动。 2、接口：接口本身就不是类，不能实例化。接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口，同时也表示着“interface只是它的外貌，但是现在需要声明它是如何工作的”。 接口是抽象类的延伸，java为了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷，但是推荐继承和接口共同使用，因为这样既可以保证数据安全性又可以实现多重继承。 在使用接口过程中需要注意如下几个问题： Interface所有的方法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！ 接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name； 接口中不存在实现的方法； 实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现； 不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable){}； 在实现多接口的时候一定要避免方法名的重复。 3、抽象类与接口的区别： 语法层次： 抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。 对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。 设计层次： 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。 设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们再抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。 总结： 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口； 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的； 抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系； 抽象类和接口是java语言中两种不同的抽象概念，他们的存在对多态提供了非常好的支持，虽然他们之间存在很大的相似性。但是对于他们的选择往往反应了对问题域的理解。只有对问题域的本质有良好的理解，才能做出正确、合理的设计。 博客转自： https://chenssy.blog.csdn.net/column/info/chenssy-javaimpr/2 https://www.hollischuang.com/archives/1308 -","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"数据结构（一）","date":"2019-06-08T06:22:00.000Z","path":"2019/06/08/数据结构总结/","text":"数据结构一些总结。 数组、栈、队列、链表、二分搜索树、集合、映射； 优先队列、堆、线段树、TRie前缀树、并查集； 平衡二叉树与AVL树、红黑树、哈希表。 About分类： 线性结构：数组、栈、队列、链表、哈希表… 树结构：二叉树、二分搜索树、AVL、红黑树、Treap、Splay、堆、Trie、线段树、K-D树、并查集、哈夫曼树… 图结构：邻接矩阵、邻接表… 应用： 数据库：树结构（AVL、红黑树、Treap、伸展树、B树）、哈希表； 操作系统：多任务间切换（系统栈，优先队列：堆）； 文件压缩：哈夫曼树； 通讯录：Trie-前缀树； 大量的算法，以数据结构为基石：寻路算法（图论算法—&gt;DFS：使用栈，BFS：使用队列）。 数组1、把数据码成一排进行存放，索引可以有语意，也可以没有语意； 2、最大优点：快速查询，最好应用于“索引有语意”的情况，并非所有有语意的索引都适用于数组； 3、size：数组中第一个没有元素的位置； 4、向数组末尾添加元素相当于在size位置处添加元素（将size索引位置值变为添加的值，size++）； 5、向数组指定位置添加元素（先将size-1处的元素值依次往后移，再将元素插入指定位置，size++）； 6、删除指定位置元素（将要删除索引处后面元素相继向左移动，size–）； 7、泛型：让数据结构可以放置“任何”数据类型（不可以是基本数据类型-8种，只能是类对象）； 8、动态数组（扩容、缩容）：新数组开辟新空间（可以装更多元素），将原来数组元素赋值到新数组； 9、动态数组的时间复杂度： 添加操作：addLast（e）-&gt; O（1）、addFIrst（e）-&gt; O（n）、add（index, e）-&gt; O（n / 2） = O（n）、resize（）-&gt; O（n）； 删除操作：removeLast（e）-&gt; O（1）、removeFIrst（e）-&gt; O（n）、remove（index, e）-&gt; O（n / 2） = O（n）、resize（）-&gt; O（n）； 修改操作：set（index, e）-&gt; O（1）； 查找操作：get（index）-&gt; O（1）、contains（e）-&gt; O（n）、find（e）-&gt; O（n）； 10、均摊复杂度：耗时的操作不会每次都触发，耗时的操作可分摊到其他操作中； 11、防止复杂度震荡：Lazy，当size == capacity / 4时，才将capacity减半。 123456789101112131415161718192021222324252627282930313233343536//关键代码Array类public void add(int index, E e) &#123;//在第index位置处插入一个新元素e if(index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"AddLast failed. Require index &gt;= 0 and index &lt;= size\"); &#125; if(size == data.length) &#123; resize(2 * data.length); &#125; for(int i = size -1; i &gt;= index; i--) &#123; data[i + 1] = data[i]; &#125; data[index] = e; size++;&#125;public E remove(int index) &#123;//从数组中删除index位置的元素，返回删除的元素 if(index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"Remove failed. Index is illegal.\"); &#125; E ret = data[index]; for(int i = index + 1; i &lt; size; i++) &#123; data[i - 1] = data[i]; &#125; size--; data[size] = null;//loitering objects != memory leak if(size == data.length / 4 &amp;&amp; data.length / 2 != 0) &#123; resize(data.length / 2); &#125; return ret;&#125;private void resize(int newCapacity) &#123;//动态数组 E[] newData = (E[])new Object[newCapacity]; for(int i = 0; i &lt; size; i++) &#123; newData[i] = data[i]; &#125; data = newData;&#125; 栈和队列1、栈（Stack）： 是一种线性结构； 相比数组，栈对应的操作是数组的子集； 只能从一端添加元素，也只能从同一端取出元素（栈顶）； 是一种后进先出的数据结构（LIFO，Last In First Out）； 栈拥有不可思议的作用。 2、栈的应用： 无处不在的undo操作（撤销）-编辑器； 程序调用的系统栈-操作系统； 括号匹配-编译器。 3、栈的实现-Stack： void push 入栈 O(1) 均摊； E pop() 出栈 O(1) 均摊； E peek() 查看栈顶元素（top） O(1)； int getSize() 栈大小 O(1)； boolean isEmpty() 栈是否为空 O(1)。 12345678910//关键代码，基于动态数组实现public void push(E e) &#123; array.addLast(e);&#125;public E pop() &#123; return array.removeLast();&#125;public E peek() &#123; return array.getLast();&#125; 4、队列（Queue）： 是一种线性结构； 相比数组，队列对应的操作是数组的子集； 只能从一端（队尾）添加元素，从另一端（队首）取出元素； 队列是一种先进先出的数据结构（先到先得）-FIFO，First In First Out； 5、队列的实现-Queue： void enqueue(E) O(1) 均摊； E dequeue() O(n)； E getFront() O(1)； int getSize() O(1)； boolean isEmpty() O(1)。 12345678910//关键代码，基于动态数组实现public void enqueue(E e) &#123; array.addLast(e);&#125;public E dequeue() &#123; return array.removeFirst();&#125;public E getFront() &#123; return array.getFirst();&#125; 6、循环队列： front == tail 队列为空，（tail + 1） % c == front 队列为满； 入队：只需维护tail（tail++ % 数组长度）； 出队：只需维护front（–）。 7、循环队列的实现-LoopQueue： void enqueue(E) O(1) 均摊； E dequeue() O(1) 均摊； E getFront() O(1)； int getSize() O(1)； boolean isEmpty() O(1)。 12345678910111213141516171819202122232425262728293031323334353637383940//关键代码private E[] data;private int front, tail;private int size;public void enqueue(E e) &#123; if((tail + 1) % data.length == front) &#123; resize(getCapacity() * 2); &#125; data[tail] = e; tail = (tail + 1) % data.length; size++;&#125;private void resize(int newCapacity) &#123; E[] newData = (E[]) new Object[newCapacity + 1]; for(int i = 0; i &lt; size; i++) &#123; newData[i] = data[(i + front) % data.length]; &#125; data = newData; front = 0; tail = size;&#125;public E dequeue() &#123; if(isEmpty()) &#123; throw new IllegalArgumentException(\"cannot dequeue from an empty queue.\"); &#125; E res = data[front]; data[front] = null; front = (front + 1) % data.length; size--; if(size == getCapacity() / 4 &amp;&amp; getCapacity() / 2 != 0) &#123; resize(getCapacity() / 2); &#125; return res;&#125;public E getFront() &#123; if(isEmpty()) &#123; throw new IllegalArgumentException(\"Queue is empty.\"); &#125; return data[front];&#125; 8、链表实现队列： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//Node类private class Node &#123; public E e; public Node next; public Node(E e, Node next) &#123; this.e = e; this.next = next; &#125; public Node(E e) &#123; this(e, null); &#125; public Node() &#123; this(null, null); &#125;&#125;//关键代码private Node head, tail;private int size;public void enqueue(E e) &#123;//链表尾插入 if(tail == null) &#123; tail = new Node(e); head = tail; &#125; else &#123; tail.next = new Node(e); tail = tail.next; &#125; size++;&#125;public E dequeue() &#123;//链表头删除 if(isEmpty()) &#123; throw new IllegalArgumentException(\"Cannot dequeue from an empty queue.\"); &#125; Node retNode = head; head = head.next; retNode.next = null; if(head == null) &#123; tail = null; &#125; size--; return retNode.e;&#125;public E getFront() &#123; if(isEmpty()) &#123; throw new IllegalArgumentException(\"Queue is empty.\"); &#125; return head.e;&#125; 链表1、线性数据结构：底层依托静态数组，靠resize解决固定容量问题； 2、链表：真正的动态数据结构； 最简单的动态数据结构； 更深入的理解引用（或者指针）； 更深入的理解递归； 辅助组成其他数据结构。 3、链表Linked List： 数据存储在“节点”（Node）中； 1234class Node &#123; E e； Node next;&#125; 优点：真正的动态，不需要处理固定容量的问题； 缺点：丧失了随机访问的能力。 4、数组和链表的对比： 数组最好用于索引有语意的情况； 最大的优点：支持快速查询； 链表不适合用于索引有语意的情况； 最大的优点：动态。 5、在链表头添加元素： 6、在链表中间添加元素（关键是找到要添加的节点的前一个节点；）： 7、链表元素的删除： 8、复杂度分析： 添加操作：addLast(e) O(n)、addFirst(e) O(1)、add(index, e) O(n / 2) = O(n)； 删除操作：removeLast(e) O(n)、removeFirst(e) O(1)、remove(index, e) O(n / 2) = O(n)； 修改操作：set(index, e) O(n)； 查找操作：get(index) O(n)、contains(e) O(n)。 9、对链表头进行操作（增、删）：O（1）、只查链表头的元素：O（1）； 10、链表实现栈、链表实现队列： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144public class LinkedList&lt;E&gt; &#123; private class Node &#123; public E e; public Node next; public Node(E e, Node next) &#123; this.e = e; this.next = next; &#125; public Node(E e) &#123; this(e, null); &#125; public Node() &#123; this(null, null); &#125; @Override public String toString() &#123; return e.toString(); &#125; &#125; private Node dummyHead;//虚拟头节点 private int size; public LinkedList() &#123; dummyHead = new Node(null, null); size = 0; &#125; public int getSize() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; //在链表头添加新的元素e public void addFirst(E e) &#123; // Node node = new Node(e); // node.next = head; // head = node; // // head = new Node(e, head); // size++; add(0, e); &#125; //在链表的index位置添加新的元素e public void add(int index, E e) &#123; if(index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"Add failed. Illegal index.\"); &#125; Node prev = dummyHead; for(int i = 0; i &lt; index; i++) &#123; prev = prev.next; &#125; // Node node = new Node(e); // node.next = prev.next; // prev.next = node; prev.next = new Node(e, prev.next); size++; &#125; //在链表末尾添加新的元素e public void addLast(E e) &#123; add(size, e); &#125; public E get(int index) &#123; if(index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"Get failed. Illegal index.\"); &#125; Node cur = dummyHead.next; for(int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; return cur.e; &#125; public E getFirst() &#123; return get(0); &#125; public E getLast() &#123; return get(size - 1); &#125; public void set(int index, E e) &#123; if(index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"Set failed. Illegal index.\"); &#125; Node cur = dummyHead.next; for(int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; cur.e = e; &#125; public boolean contains(E e) &#123; Node cur = dummyHead.next; while(cur != null) &#123; if(cur.e.equals(e)) &#123; return true; &#125; cur = cur.next; &#125; return false; &#125; public E remove(int index) &#123; if(index &lt; 0 || index &gt;= size) &#123; throw new IllegalArgumentException(\"Remove failed. Illegal index.\"); &#125; Node prev = dummyHead; for(int i = 0; i &lt; index; i++) &#123; prev = prev.next; &#125; Node ret = prev.next; prev.next = ret.next; ret.next = null; size--; return ret.e; &#125; public E removeFirst() &#123; return remove(0); &#125; public E removeLast() &#123; return remove(size - 1); &#125; //从链表删除元素e public void removeElement(E e) &#123; Node prev = dummyHead; while (prev.next != null) &#123; if(prev.next.e.equals(e)) &#123; break; &#125; prev = prev.next; &#125; if(prev.next != null) &#123; Node delNode = prev.next; prev.next = delNode.next; delNode.next = null; &#125; &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); Node cur = dummyHead.next; while (cur != null) &#123; res.append(cur + \"-&gt;\"); cur = cur.next; &#125; res.append(\"Null\"); return res.toString(); &#125;&#125; 链表和递归1、递归：本质上，将原来的问题，转化为更小的同一问题； 2、求解最基本问题，把原问题转化为更小的问题； 3、递归函数： 递归函数的调用，本质就是函数调用； 只不过调用的函数是自己而已。 递归调用是有代价的：函数调用+系统栈空间。 4、双链表： 1234class Node &#123; E e; Node next, prev;&#125; 加入虚拟头节点：对于很多操作，在链表头不需特殊讨论。 5、循环链表： 6、数组链表： 二分搜索树1、树结构本身是一种天然的组织结构； 2、树结构：高效； 3、二叉树： 123456//和链表一样，动态数据结构class Node &#123; E e; Node left; //左孩子 Node right; //右孩子&#125; 二叉树具有唯一根节点； 二叉树每个节点最多有两个孩子； 二叉树每个节点最多有一个父亲节点； 二叉树具有天然递归结构： 每个节点的左子树也是二叉树； 每个节点的右子树也是二叉树，一个节点也是二叉树，空也是二叉树。 4、二分搜索树（Binary Search Tree）： 二分搜索树是二叉树； 二分搜索树的每个节点的值： 大于其左子树的所有节点的值； 小于其右子树的所有节点的值。 每一棵子树也是二分搜索树； 存储的元素必须有可比较性（存储数据的局限性）； 二分搜索树不包含重复元素： 如果想包含重复元素的话，改变定义：左子树小于等于节点，或者右子树大于等于节点。 注意：数组和链表，可以有重复元素。 二分搜索树添加元素的非递归写法，和链表很像； 在二分搜索树方面，递归比非递归实现简单。 5、遍历： 把所有节点都访问一遍； 访问的原因和业务相关； 在线性结构下，遍历是及其容易的； 在树结构下，也没那么难； 对遍历操作，两颗子树都要顾及。 6、后序遍历应用：为二分搜索树释放内存。 7、栈消除递归。 8、深度优先遍历：前序、中序、后序；广度优先遍历（搜索策略）：层序遍历（非递归实现-借助队列） 广度优先遍历：更快的找到问题的解，常用于算法设计中-最短路径。 9、二分搜索树删除节点（找后继和前驱都可以删除）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267import java.util.LinkedList;import java.util.Queue;import java.util.Stack;public class BST&lt;E extends Comparable&lt;E&gt;&gt; &#123; private class Node &#123; public E e; public Node left, right; public Node(E e) &#123; this.e = e; left = null; right = null; &#125; &#125; private Node root; private int size; public BST() &#123; this.root = null; this.size = 0; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void add(E e) &#123; // if(root == null) &#123; // root = new Node(e); // &#125; else &#123; // add(root, e); // &#125; root = add(root, e); &#125; private Node add(Node node, E e) &#123; // if(e.equals(node.e)) &#123; // return; // &#125; else if(e.compareTo(node.e) &lt; 0 &amp;&amp; node.left == null) &#123; // node.left = new Node(e); // size++; // return; // &#125; else if(e.compareTo(node.e) &gt; 0 &amp;&amp; node.right == null) &#123; // node.right = new Node(e); // size++; // return; // &#125; //向以node为根的二分搜索树中插入元素E，递归算法 //返回插入新节点后二分搜索树的根 if(node == null) &#123; size++; return new Node(e); &#125; if(e.compareTo(node.e) &lt; 0) &#123; node.left = add(node.left, e); &#125; if(e.compareTo(node.e) &gt; 0) &#123; node.right = add(node.right, e); &#125; return node; &#125; public boolean contains(E e) &#123;//二分搜索树中是否包含元素e return contains(root, e); &#125; private boolean contains(Node node, E e) &#123;//以node为根的二分搜索树中是否包含元素e，递归算法 if(node == null) &#123; return false; &#125; if(e.compareTo(node.e) &lt; 0) &#123; return contains(node.left, e); &#125; else if(e.compareTo(node.e) &gt; 0) &#123; return contains(node.right, e); &#125; else &#123; return true; &#125; &#125; //遍历 public void preOrder() &#123;//前序遍历 preOrder(root); &#125; private void preOrder(Node node) &#123; // if(node == null) &#123; // return; // &#125; if(node != null) &#123; System.out.println(node.e); preOrder(node.left); preOrder(node.right); &#125; &#125; public void preOrderNR() &#123;//前序非递归遍历，栈消除递归 Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; Node cur = stack.pop(); System.out.println(cur.e); if(cur.right != null) &#123; stack.push(cur.right); &#125; if(cur.left != null) &#123; stack.push(cur.left); &#125; &#125; &#125; public void inOrder() &#123;//中序排序 inOrder(root); &#125; private void inOrder(Node node) &#123; if(node == null) &#123; return; &#125; inOrder(node.left); System.out.println(node.e); inOrder(node.right); &#125; public void postOrder() &#123;//后序遍历 postOrder(root); &#125; private void postOrder(Node node) &#123; if(node == null) &#123; return; &#125; postOrder(node.left); postOrder(node.right); System.out.println(node.e); &#125; //层序遍历，队列实现 public void levelOrder() &#123; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); while (!q.isEmpty()) &#123; Node cur = q.remove(); System.out.println(cur.e); if(cur.left != null) &#123; q.add(cur.left); &#125; if(cur.right != null) &#123; q.add(cur.right); &#125; &#125; &#125; //寻找二分搜索树的最小元素 public E minimum() &#123; if(size == 0) &#123; throw new IllegalArgumentException(\"BST is empty\"); &#125; return minimum(root).e; &#125; //返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node) &#123; if(node.left == null) &#123; return node; &#125; return minimum(node.left); &#125; //寻找二分搜索树的最大元素 public E maximum() &#123; if(size == 0) &#123; throw new IllegalArgumentException(\"BST is empty\"); &#125; return maximum(root).e; &#125; //返回以node为根的二分搜索树的最大值所在的节点 private Node maximum(Node node) &#123; if(node.right == null) &#123; return node; &#125; return maximum(node.right); &#125; //从二分搜索树中删除最小值所在节点，返回最小值 public E removeMin() &#123; E ret = minimum(); root = removeMin(root); return ret; &#125; //删除以node为根的二分搜索树中的最小节点 //返回删除节点后新的二分搜索树的根 private Node removeMin(Node node) &#123; if(node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; node.left = removeMin(node.left); return node; &#125; //从二分搜索树中删除最大值所在节点，返回最大值 public E removeMax() &#123; E ret = maximum(); root = removeMax(root); return ret; &#125; //删除以node为根的二分搜索树中的最大节点 //返回删除节点后新的二分搜索树的根 private Node removeMax(Node node) &#123; if(node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; node.right = removeMax(node.right); return node; &#125; //从二分搜索树中删除元素为e的节点 public void remove(E e) &#123; root = remove(root, e); &#125; //删除以node为根的二分搜索树中值为e的节点，递归算法 //返回删除节点后新的二分搜索树的根 private Node remove(Node node, E e) &#123; if(node == null) &#123; return null; &#125; if(e.compareTo(node.e) &lt; 0) &#123; node.left = remove(node.left, e); return node; &#125; else if(e.compareTo(node.e) &gt; 0) &#123; node.right = remove(node.right, e); return node; &#125; else &#123;//e == node.e //待删节点左子树为空的情况 if(node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; //待删节点右子树为空的情况 if(node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; //待删节点左右子树为均不为空的情况 //找到比待删节点大的最小节点，即待删除节点右子树的最小节点 //用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; &#125; &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); generateBSTString(root, 0, res); return res.toString(); &#125; private void generateBSTString(Node node, int depth, StringBuilder res) &#123; if(node == null) &#123; res.append(generateBSTString(depth) + \" \\n\"); return; &#125; res.append(generateBSTString(depth) + node.e + \"\\n\"); generateBSTString(node.left, depth + 1, res); generateBSTString(node.right, depth + 1, res); &#125; private String generateBSTString(int depth) &#123; StringBuilder res = new StringBuilder(); for(int i = 0; i &lt; depth; i++) &#123; res.append(\"--\"); &#125; return res.toString(); &#125;&#125; 集合和映射1、集合：每个元素只能存在一次（去重）； Set: void add(E) 不能添加重复元素； void remove(E) ； boolean contains(E)； int getSize()； boolean isEmpty()。 应用：客户统计、词汇量统计。 2、BST和LinkedList都属于动态数据结构，可以用来实现set。 3、集合类的复杂度分析： LinkedListSet： 增add：O(n)； 查contains：O(n)； 删remove：O(n)。 BSTSet： 增add：O(h) h为二分搜索树的高度 h=logn； 查contains：O(h)； 删remove：O(h)。 4、java集合底层是：红黑树，本质是有序的集合； ​ 基于链表实现的集合：无序。 5、 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//链表实现集合public class LinkedListSet&lt;E&gt; implements Set&lt;E&gt; &#123; private LinkedList&lt;E&gt; list; public LinkedListSet() &#123; list = new LinkedList&lt;&gt;(); &#125; @Override public void add(E e) &#123; if(!list.contains(e)) &#123; list.addFirst(e); &#125; &#125; @Override public void remove(E e) &#123; list.removeElement(e); &#125; @Override public boolean contains(E e) &#123; return list.contains(e); &#125; @Override public int getSize() &#123; return list.getSize(); &#125; @Override public boolean isEmpty() &#123; return list.isEmpty(); &#125;&#125;//二分搜索树实现集合public class BSTSet&lt;E extends Comparable&lt;E&gt;&gt; implements Set&lt;E&gt; &#123; private BST&lt;E&gt; bst; public BSTSet() &#123; bst = new BST&lt;&gt;(); &#125; @Override public void add(E e) &#123; bst.add(e); &#125; @Override public void remove(E e) &#123; bst.remove(e); &#125; @Override public boolean contains(E e) &#123; return bst.contains(e); &#125; @Override public int getSize() &#123; return bst.size(); &#125; @Override public boolean isEmpty() &#123; return bst.isEmpty(); &#125;&#125; 6、映射Map： 存储（键，值）数据对的数据结构（Key，Value）； 根据键（Key），寻找值（Value）； 非常容易使用链表或者二分搜索树实现。 7、映射的时间复杂度分析： 8、有序映射和无序映射： 有序映射中的键具有顺序性（基于搜索树的实现）； 无序映射中的键没有顺序性（基于哈希表的实现）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240//链表实现映射import java.util.ArrayList;public class LinkedListMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123; private class Node &#123; public K key; public V value; public Node next; public Node(K key, V value, Node next) &#123; this.key = key; this.value = value; this.next = next; &#125; public Node(K key) &#123; this(key, null, null); &#125; public Node() &#123; this(null, null, null); &#125; @Override public String toString() &#123; return key.toString() + \":\" + value.toString(); &#125; &#125; private Node dummyHead; private int size; public LinkedListMap() &#123; dummyHead = new Node(); size = 0; &#125; @Override public void add(K key, V value) &#123; Node node = getNode(key); if(node == null) &#123; dummyHead.next = new Node(key, value, dummyHead.next); size++; &#125; else &#123; node.value = value; &#125; &#125; @Override public V remove(K key) &#123; Node prev = dummyHead; while (prev.next != null) &#123; if(prev.next.key.equals(key)) &#123; break; &#125; prev = prev.next; &#125; if(prev.next != null) &#123; Node delNode = prev.next; prev.next = delNode.next; delNode.next = null; size--; return delNode.value; &#125; return null; &#125; @Override public boolean contains(K key) &#123; return getNode(key) != null; &#125; @Override public V get(K key) &#123; Node node = getNode(key); return node == null ? null : node.value; &#125; @Override public void set(K key, V newValue) &#123;//更新键对应的值 Node node = getNode(key); if(node == null) &#123; throw new IllegalArgumentException(key + \"does't exist!\"); &#125; node.value = newValue; &#125; @Override public int getSize() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; private Node getNode(K key) &#123; Node cur = dummyHead.next; while (cur != null) &#123; if(cur.key.equals(key)) &#123; return cur; &#125; cur = cur.next; &#125; return null; &#125;&#125;//二分搜索树实现映射import java.util.ArrayList;public class BSTMap&lt;K extends Comparable&lt;K&gt;, V&gt; implements Map&lt;K, V&gt; &#123; private class Node &#123; public K key; public V value; public Node left, right; public Node(K key, V value) &#123; this.key = key; this.value = value; left = null; right = null; &#125; &#125; private Node root; private int size; public BSTMap() &#123; this.root = null; this.size = 0; &#125; @Override public void add(K key, V value) &#123; root = add(root, key, value); &#125; private Node add(Node node, K key, V value) &#123; //返回插入新节点后二分搜索树的根 //向以node为根的二分搜索树中插入元素E，递归算法 if(node == null) &#123; size++; return new Node(key, value); &#125; if(key.compareTo(node.key) &lt; 0) &#123; node.left = add(node.left, key, value); &#125; if(key.compareTo(node.key) &gt; 0) &#123; node.right = add(node.right, key, value); &#125; if(key.compareTo(node.key) == 0) &#123; node.value = value; &#125; return node; &#125; //返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node) &#123; if(node.left == null) &#123; return node; &#125; return minimum(node.left); &#125; //删除以node为根的二分搜索树中的最小节点 //返回删除节点后新的二分搜索树的根 private Node removeMin(Node node) &#123; if(node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; node.left = removeMin(node.left); return node; &#125; //从二分搜索树中删除元素为e的节点 @Override public V remove(K key) &#123; Node node = getNode(root, key); if(node != null) &#123; root = remove(root, key); return node.value; &#125; return null; &#125; //删除以node为根的二分搜索树中键为key的节点，递归算法 //返回删除节点后新的二分搜索树的根 private Node remove(Node node, K key) &#123; if(node == null) &#123; return null; &#125; if(key.compareTo(node.key) &lt; 0) &#123; node.left = remove(node.left, key); return node; &#125; else if(key.compareTo(node.key) &gt; 0) &#123; node.right = remove(node.right, key); return node; &#125; else &#123;//key == node.key //待删节点左子树为空的情况 if(node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; //待删节点右子树为空的情况 if(node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; return leftNode; &#125; //待删节点左右子树为均不为空的情况 //找到比待删节点大的最小节点，即待删除节点右子树的最小节点 //用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; &#125; &#125; @Override public boolean contains(K key) &#123; return getNode(root, key) != null; &#125; @Override public V get(K key) &#123; Node node = getNode(root, key); return node == null ? null : node.value; &#125; @Override public void set(K key, V newValue) &#123; Node node = getNode(root, key); if(node == null) &#123; throw new IllegalArgumentException(key + \" doesn't exist!\"); &#125; node.value = newValue; &#125; //返回以node为根节点的二分搜索树中，key所在的节点 private Node getNode(Node node, K key) &#123; if(node == null) &#123; return null; &#125; if(key.compareTo(node.key) == 0) &#123; return node; &#125; else if(key.compareTo(node.key) &lt; 0) &#123; return getNode(node.left, key); &#125; else &#123; return getNode(node.right, key); &#125; &#125; @Override public int getSize() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125;&#125; 优先队列和堆1、普通队列：先进先出，后进后出； ​ 优先队列：出队顺序和入队顺序无关，和优先级相关；（应用：任务调度）。 2、优先队列实现： 普通线性结构：入队-O（1）、出队-O（n）； 顺序线性结构：入队-O（n）、出队-O（1）； 堆：入队-O（logn）、出队-O（logn）。 3、堆的基本结构： 二叉堆是一颗完全二叉树（完全二叉树：把元素顺序排列成树的形状）； 堆中某个节点的值总是不大于其父节点的值–最大堆。 4、数组存储二叉堆： 索引从1开始： parent（i）= i / 2； left child (i) = 2 * i； right child(i) = 2 * i + 1。 索引从0开始： parent（i ）=（ i - 1） / 2； left child (i ) = 2 * i + 1； right child(i) = 2 * i + 2。 5、堆的时间复杂度分析： add O（logn）； extractMax （logn）。 6、replace操作： replace：取出最大元素后，放入一个新元素； 实现1：可以先extractMax，再add，两次O（logn）的操作； 实现2：可以直接将堆顶元素替换以后Sift Down，一次O（logn）的操作。 7、heapify操作：将任意数组整理成堆的形状； 将n个元素逐个插入到一个空堆中，算法复杂度是O（nlogn）； heapify的过程，算法复杂度为O（n）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class MaxHeap&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Array&lt;E&gt; data; public MaxHeap(int capacity) &#123; data = new Array&lt;&gt;(capacity); &#125; public MaxHeap() &#123; data = new Array&lt;&gt;(); &#125; public MaxHeap(E[] arr) &#123; data = new Array&lt;&gt;(arr); for(int i = parent(arr.length - 1); i &gt;= 0; i--) &#123; siftDown(i); &#125; &#125; //返回堆中元素个数 public int size() &#123; return data.getSize(); &#125; //返回一个布尔值，表示堆中是否为空 public boolean isEmpty() &#123; return data.isEmpty(); &#125; //返回完全二叉树的数组表示中，一个索引所表示的元素的父亲节点的索引 private int parent(int index) &#123; if(index == 0) &#123; throw new IllegalArgumentException(\"index-0 doesn't have parent\"); &#125; return (index - 1) / 2; &#125; //返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引 private int leftChild(int index) &#123; return index * 2 + 1; &#125; //返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引 private int rightChild(int index) &#123; return index * 2 + 2; &#125; //向堆中添加元素 public void add(E e) &#123; data.addLast(e); siftUp(data.getSize() - 1); &#125; private void siftUp(int k) &#123; while (k &gt; 0 &amp;&amp; data.get(parent(k)).compareTo(data.get(k)) &lt; 0) &#123; data.swap(k, parent(k)); k = parent(k); &#125; &#125; //查看堆中最大元素 public E findMax() &#123; if(data.getSize() == 0) &#123; throw new IllegalArgumentException(\"can not findMax when heap is empty\"); &#125; return data.get(0); &#125; //取出堆中最大元素 public E extractMax() &#123; E ret = findMax(); data.swap(0, data.getSize() - 1); data.removeLast(); siftDown(0); return ret; &#125; private void siftDown(int k) &#123; while (leftChild(k) &lt; data.getSize()) &#123; int j = leftChild(k); if(j + 1 &lt; data.getSize() &amp;&amp; data.get(j + 1).compareTo(data.get(j)) &gt; 0) &#123; j = rightChild(k); &#125; if(data.get(k).compareTo(data.get(j)) &gt;= 0) &#123; break; &#125; else &#123; data.swap(k, j); k = j; &#125; &#125; &#125; //取出堆中的最大元素，并且替换成元素e public E replace(E e) &#123; E ret = findMax(); data.set(0, e); siftDown(0); return ret; &#125;&#125; 8、优先队列的经典问题：在1000000个元素中选出前100名； 在N个元素中选出前M个元素； 排序？ NlogN； 使用优先队列？NlogM。 使用优先队列，维护当前看到的前M个元素；需要使用最小堆。 1234567891011121314151617181920212223242526public class PriorityQueue&lt;E extends Comparable&lt;E&gt;&gt; implements Queue&lt;E&gt; &#123; private MaxHeap&lt;E&gt; maxHeap; public PriorityQueue() &#123; maxHeap = new MaxHeap&lt;&gt;(); &#125; @Override public int getSize() &#123; return maxHeap.size(); &#125; @Override public boolean isEmpty() &#123; return maxHeap.isEmpty(); &#125; @Override public void enqueue(E e) &#123; maxHeap.add(e); &#125; @Override public E dequeue() &#123; return maxHeap.extractMax(); &#125; @Override public E getFront() &#123; return maxHeap.findMax(); &#125;&#125; 线段树（区间树）1、关心的是一个线段或区间； 2、最经典的线段树问题：区间染色、区间查询； 3、 4、线段树不一定是完全二叉树，线段树是平衡二叉树，堆也是平衡二叉树； ​ 平衡二叉树：树的最大深度与最小深度相差最多为1。 5、 6、区间操作的数据结构： 线段树； 树状数组（Binary Index Tree）。 区间相关的问题：RMQ（Range Minimum Query）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public interface Merger&lt;E&gt; &#123; E merge(E a, E b);&#125;public class SegmentTree&lt;E&gt; &#123; private E[] tree; private E[] data; private Merger&lt;E&gt; merger; public SegmentTree(E[] arr, Merger&lt;E&gt; merger) &#123; this.merger = merger; data = (E[]) new Object[arr.length]; for(int i = 0; i &lt; arr.length; i++) &#123; data[i] = arr[i]; &#125; tree = (E[]) new Object[4 * arr.length]; buildSegmentTree(0, 0, data.length - 1); &#125; //在treeIndex的位置创建表示区间[l...r]的线段树 private void buildSegmentTree(int treeIndex, int l, int r) &#123; if(l == r) &#123; tree[treeIndex] = data[l]; return; &#125; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); int mid = l + (r - l) / 2;//mid = l + r buildSegmentTree(leftTreeIndex, l, mid); buildSegmentTree(rightTreeIndex, mid + 1, r); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); &#125; //返回区间[queryL, queryR]的值 public E query(int queryL, int queryR) &#123; if(queryL &lt; 0 || queryL &gt;= data.length || queryR &lt; 0 || queryR &gt;= data.length || queryL &gt; queryR) &#123; throw new IllegalArgumentException(\"Index is illegal.\"); &#125; return query(0, 0, data.length - 1, queryL, queryR); &#125; //在以treeIndex为根的线段树中[l...r]的范围里，搜索区间[queryL...queryR]的值 private E query(int treeIndex, int l, int r, int queryL, int queryR) &#123; if(l == queryL &amp;&amp; r == queryR) &#123; return tree[treeIndex]; &#125; int mid = l + (r - l) / 2; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if(queryL &gt;= mid + 1) &#123; return query(rightTreeIndex, mid + 1, r, queryL, queryR); &#125; else if(queryR &lt;= mid) &#123; return query(leftTreeIndex, l, mid, queryL, queryR); &#125; E leftResult = query(leftTreeIndex, l, mid, queryL, mid); E rightResult = query(rightTreeIndex, mid + 1, r, mid + 1, queryR); return merger.merge(leftResult, rightResult); &#125; public int getSize() &#123; return data.length; &#125; public E get(int index) &#123; if(index &lt; 0 || index &gt;= data.length) &#123; throw new IllegalArgumentException(\"Index is illegal.\"); &#125; return data[index]; &#125; //返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引 private int leftChild(int index) &#123; return 2 * index + 1; &#125; //返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引 private int rightChild(int index) &#123; return 2 * index + 2; &#125; //将index位置的值，更新为e public void set(int index, E e) &#123; if(index &lt; 0 || index &gt;= data.length) &#123; throw new IllegalArgumentException(\"Index is illegal.\"); &#125; data[index] = e; set(0, 0, data.length - 1, index, e); &#125; //在以treeIndex为根的线段树中更新index的值为e private void set(int treeIndex, int l, int r, int index, E e) &#123; if(l == r) &#123; tree[treeIndex] = e; return; &#125; int mid = l + (r - l) / 2; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if(index &gt;= mid + 1) &#123; set(rightTreeIndex, mid + 1, r, index, e); &#125; else &#123; set(leftTreeIndex, l, mid, index, e); &#125; tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append('['); for (int i = 0; i &lt; tree.length; i++) &#123; if (tree[i] != null) &#123; res.append(tree[i]); &#125; else &#123; res.append(\"null\"); &#125; if (i != tree.length - 1) &#123; res.append('-'); &#125; else &#123; res.append(']'); &#125; &#125; return res.toString(); &#125;&#125; Trie字典树 前缀树1、Trie：专门为字符串设计； 2、字典：如果有n个条目，使用树结构，查询的时间复杂度是O（logn），如果有100万个条目（2^20），logn大约为20； ​ Trie：查询每个条目的时间复杂度，和字典中一共有多少条目无关，时间复杂度为O（w），w为查询单词的长度，大多数单词的长度小于10； 3、Trie：每个节点有若干指向下个节点的指针； 1234class Node &#123; boolean isWord;//是否访问到单词的结尾 Map&lt;char, Node&gt; next;&#125; 4、Trie的局限性：最大的问题（空间！） 解决办法： 压缩字典树（Compressed Trie）； 三分搜索树（Ternary Search Trie）。 5、字符串模式识别：后缀树； 6、更多字符串问题： 子串查询（KMP、Boyer-Moore、Rabin-Karp）； 文件压缩（哈夫曼）； 模式匹配； 编译原理； DNA。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.TreeMap;public class Trie &#123; private class Node &#123; public boolean isWord; public TreeMap&lt;Character, Node&gt; next; public Node(boolean isWord) &#123; this.isWord = isWord; next = new TreeMap&lt;&gt;(); &#125; public Node() &#123; this(false); &#125; &#125; private Node root; private int size; public Trie() &#123; root = new Node(); size = 0; &#125; //获得Trie中存储的单词数量 public int getSize() &#123; return size; &#125; //向Trie中添加一个新的单词word public void add(String word) &#123; Node cur = root; for(int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); if(cur.next.get(c) == null) &#123; cur.next.put(c, new Node()); &#125; cur = cur.next.get(c); &#125; if(!cur.isWord) &#123; cur.isWord = true; size++; &#125; &#125; //查询单词word是否在Trie中 public boolean contains(String word) &#123; Node cur = root; for(int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); if(cur.next.get(c) == null) &#123; return false; &#125; cur = cur.next.get(c); &#125; return cur.isWord; &#125; //查询是否在Trie中有单词以prefix为前缀 public boolean isPrefix(String prefix) &#123; Node cur = root; for(int i = 0; i &lt; prefix.length(); i++) &#123; char c = prefix.charAt(i); if(cur.next.get(c) == null) &#123; return false; &#125; cur = cur.next.get(c); &#125; return true; &#125;&#125; 并查集（Union Find）1、一种很不一样的树形结构，孩子指向父亲，可以回答连接问题； 2、并查集（连接问题和路径问题）： 网络中节点间的连接状态：网络是个抽象的概念-用户之间形成的网络； 数学中的集合类实现。 回答连接问题比路径问题要回答的问题少。 3、对于一组数据，主要支持两个动作： union（p，q）； isConnected（p， q）。 4、并查集实现： Quick Find：unionElements(p, q)-O(n)、isConnected(p, q)- O(1) 5、并查集时间复杂度：O（log*n） 近乎是O（1）级别的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class UnionFind implements UF &#123; private int[] parent; private int[] rank; public UnionFind(int size) &#123; parent = new int[size]; rank = new int[size]; for(int i =0; i &lt; size; i++) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; //查找过程，查找元素p所对应的集合编号 //O（h）复杂度，h为树的高度 private int find(int p) &#123; if(p &lt; 0 || p &gt;= parent.length) &#123; throw new IllegalArgumentException(\"p is out of bound.\"); &#125; if(p != parent[p]) &#123; parent[p] = find(parent[p]); &#125; return parent[p]; &#125; //查看元素p和元素q是否所属一个集合 @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; //合并元素p和元素q所属的集合 //O(h)复杂度，h为树的高度 @Override public void unionElements(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if(pRoot == qRoot) &#123; return; &#125; //根据两个元素所在树的rank不同判断合并方向 //将rank低的集合合并到rank高的集合上 if(rank[pRoot] &lt; rank[qRoot]) &#123; parent[pRoot] = qRoot; &#125; else if(rank[pRoot] &gt; rank[qRoot]) &#123; parent[qRoot] = pRoot; &#125; else &#123; parent[pRoot] = qRoot; rank[qRoot] += 1; &#125; &#125;&#125; 平衡二叉树与AVL树1、AVL树是最经典的平衡二叉树，AVL发明人：G. M. Adelson-Velsky 和 E. M. Landis； 2、AVL树是最早的自平衡的二分搜索树结构； 3、平衡二叉树： 满二叉树一定是平衡二叉树； 完全二叉树、线段树也是平衡二叉树； AVL树中，对于任意一个节点，左子树和右子树的高度差不能超过1，平衡二叉树的高度和节点数量之间的关系是O（logn）的； 标注节点的高度，计算平衡因子：左右子树高度差。 4、右旋转：插入的元素在不平衡的节点的左侧的左侧； ​ 左旋转：插入的元素在不平衡的节点的右侧的右侧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279import com.map.Map;import java.util.ArrayList;public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; implements Map&lt;K, V&gt; &#123; private class Node &#123; public K key; public V value; public Node left, right; public int height; public Node(K key, V value) &#123; this.key = key; this.value = value; left = null; right = null; height = 1; &#125; &#125; private Node root; private int size; public AVLTree() &#123; this.root = null; this.size = 0; &#125; @Override public int getSize() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; //获得节点node的高度 public int getHeight(Node node) &#123; if(node == null) &#123; return 0; &#125; return node.height; &#125; //获得节点node的平衡因子 private int getBalanceFactor(Node node) &#123; if(node == null) &#123; return 0; &#125; return getHeight(node.left) - getHeight(node.right); &#125; //判断该二叉树是否是一棵二分搜索树 public boolean isBST() &#123; ArrayList&lt;K&gt; keys = new ArrayList&lt;&gt;(); inOrder(root, keys); for(int i = 1; i &lt; keys.size(); i++) &#123; if(keys.get(i - 1).compareTo(keys.get(i)) &gt; 0) &#123; return false; &#125; &#125; return true; &#125; private void inOrder(Node node, ArrayList&lt;K&gt; keys) &#123; if(node == null) &#123; return; &#125; inOrder(node.left, keys); keys.add(node.key); inOrder(node.right, keys); &#125; //判断该二叉树是否是一棵平衡二叉树 public boolean isBanlanced() &#123; return isBanlanced(root); &#125; //判断以Node为根的二叉树是否是一棵平衡二叉树，递归算法 private boolean isBanlanced(Node node) &#123; if(node == null) &#123; return true; &#125; int balanceFactor = getBalanceFactor(node); if(Math.abs(balanceFactor) &gt; 1) &#123; return false; &#125; return isBanlanced(node.left) &amp;&amp; isBanlanced(node.right); &#125; // 对节点y进行向右旋转操作，返回旋转后新的根节点x // y x // / \\ / \\ // x T4 向右旋转 (y) z y // / \\ - - - - - - - -&gt; / \\ / \\ // z T3 T1 T2 T3 T4 // / \\ // T1 T2 private Node rightRotate(Node y) &#123; Node x = y.left; Node T3 = x.right; //向右旋转过程 x.right = y; y.left = T3; //更新height y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1; x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1; return x; &#125; // 对节点y进行向左旋转操作，返回旋转后新的根节点x // y x // / \\ / \\ // T1 x 向左旋转 (y) y z // / \\ - - - - - - - -&gt; / \\ / \\ // T2 z T1 T2 T3 T4 // / \\ // T3 T4 private Node leftRotate(Node y) &#123; Node x = y.right; Node T2 = x.left; //左旋转 x.left = y; y.right = T2; //更新height y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1; x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1; return x; &#125; @Override public void add(K key, V value) &#123; root = add(root, key, value); &#125; private Node add(Node node, K key, V value) &#123; //向以node为根的二分搜索树中插入元素E，递归算法 //返回插入新节点后二分搜索树的根 if(node == null) &#123; size++; return new Node(key, value); &#125; if(key.compareTo(node.key) &lt; 0) &#123; node.left = add(node.left, key, value); &#125; if(key.compareTo(node.key) &gt; 0) &#123; node.right = add(node.right, key, value); &#125; if(key.compareTo(node.key) == 0) &#123; node.value = value; &#125; //更新height node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right)); //计算平衡因子 int balanceFactor = getBalanceFactor(node);// if(Math.abs(balanceFactor) &gt; 1) &#123;// System.out.println(\"unbalanced:\" + balanceFactor);// &#125; //平衡维护 //LL if(balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(node.left) &gt;= 0) &#123;//右旋转 return rightRotate(node); &#125; //RR if(balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(node.right) &lt;= 0) &#123; return leftRotate(node); &#125; //LR，先转化为LL情况 if(balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(node.left) &lt; 0) &#123; node.left = leftRotate(node.left); return rightRotate(node); &#125; //RL，先转化为RR情况 if(balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(node.right) &gt; 0) &#123; node.right = rightRotate(node.right); return leftRotate(node); &#125; return node; &#125; //返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node) &#123; if(node.left == null) &#123; return node; &#125; return minimum(node.left); &#125; //从二分搜索树中删除元素为e的节点 @Override public V remove(K key) &#123; Node node = getNode(root, key); if(node != null) &#123; root = remove(root, key); return node.value; &#125; return null; &#125; //删除以node为根的二分搜索树中键为key的节点，递归算法 //返回删除节点后新的二分搜索树的根 private Node remove(Node node, K key) &#123; if(node == null) &#123; return null; &#125; Node retNode; if(key.compareTo(node.key) &lt; 0) &#123; node.left = remove(node.left, key); retNode = node; &#125; else if(key.compareTo(node.key) &gt; 0) &#123; node.right = remove(node.right, key); retNode = node; &#125; else &#123;//key == node.key //待删节点左子树为空的情况 if(node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; retNode = rightNode; &#125; //待删节点右子树为空的情况 else if(node.right == null) &#123; Node leftNode = node.left; node.left = null; size--; retNode = leftNode; &#125; //待删节点左右子树为均不为空的情况 //找到比待删节点大的最小节点，即待删除节点右子树的最小节点 //用这个节点顶替待删除节点的位置 else &#123; Node successor = minimum(node.right); successor.right = remove(node.right, successor.key); successor.left = node.left; node.left = node.right = null; retNode = successor; &#125; &#125; if(retNode == null) &#123; return null; &#125; //更新height retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right)); //计算平衡因子 int balanceFactor = getBalanceFactor(retNode); //平衡维护 //LL if(balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(retNode.left) &gt;= 0) &#123;//右旋转 return rightRotate(retNode); &#125; //RR if(balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(retNode.right) &lt;= 0) &#123; return leftRotate(retNode); &#125; //LR，先转化为LL情况 if(balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(retNode.left) &lt; 0) &#123; retNode.left = leftRotate(retNode.left); return rightRotate(retNode); &#125; //RL，先转化为RR情况 if(balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(retNode.right) &gt; 0) &#123; retNode.right = rightRotate(retNode.right); return leftRotate(retNode); &#125; return retNode; &#125; @Override public boolean contains(K key) &#123; return getNode(root, key) != null; &#125; @Override public V get(K key) &#123; Node node = getNode(root, key); return node == null ? null : node.value; &#125; @Override public void set(K key, V newValue) &#123; Node node = getNode(root, key); if(node == null) &#123; throw new IllegalArgumentException(key + \" doesn't exist!\"); &#125; node.value = newValue; &#125; //返回以node为根节点的二分搜索树中，key所在的节点 private Node getNode(Node node, K key) &#123; if(node == null) &#123; return null; &#125; if(key.compareTo(node.key) == 0) &#123; return node; &#125; else if(key.compareTo(node.key) &lt; 0) &#123; return getNode(node.left, key); &#125; else &#123; return getNode(node.right, key); &#125; &#125;&#125; 红黑树1、红黑树（是一棵二分搜索树）： 每个节点或者是红色的，或者是黑色的； 根节点是黑色的； 每一叶子节点（最后的空节点）是黑色的； 如果一个节点是红色的，那么它的孩子节点都是黑色的； 从任意一个节点到叶子节点，经过的黑色节点是一样的。 2、2-3树： 满足二分搜索树的基本性质； 节点可以存放一个元素或者两个元素； 每个节点有2个或者3个孩子（2-3树）； 2-3树是一棵绝对平衡的树(从根节点到任意一个叶子节点所经过的节点数量相同)。 3、红黑树： 红色：节点与父亲节点融合在一起； 红黑树是保持”黑平衡“的二叉树，严格意义上，不是平衡二叉树，最大高度2logn -&gt;O（logn）。 4、红黑树添加新元素： 维护的时机：和AVL树一样，添加节点后回溯向上维护。 5、红黑树的性能总结： 对于完全随机的数据，普通的二分搜索树很好用！ 缺点：极端情况退化成链表（或者高度不平衡）； 对于查询较多的使用情况，AVL树很好用！ 红黑树牺牲了平衡性（2logn的高度）； 统计性能更优（综合增删改查所有的操作）。 6、红黑树更多问题：红黑树中删除节点、左倾红黑树、右倾红黑树、另一种统计性能优秀的树结构：Splay Tree（伸展树）–&gt;局部性原理：刚被访问的内容下次高概率被再次访问、基于红黑树的Map和Set（java.util中的TreeMap和TreeSet基于红黑树）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193import java.util.ArrayList;public class RBTree&lt;K extends Comparable&lt;K&gt;, V&gt; &#123; private static final boolean RED = true; private static final boolean BLACK = false; private class Node&#123; public K key; public V value; public Node left, right; public boolean color; public Node(K key, V value)&#123; this.key = key; this.value = value; left = null; right = null; color = RED; &#125; &#125; private Node root; private int size; public RBTree()&#123; root = null; size = 0; &#125; public int getSize()&#123; return size; &#125; public boolean isEmpty()&#123; return size == 0; &#125; // 判断节点node的颜色 private boolean isRed(Node node)&#123; if(node == null) return BLACK; return node.color; &#125; // node x // / \\ 左旋转 / \\ // T1 x ---------&gt; node T3 // / \\ / \\ // T2 T3 T1 T2 private Node leftRotate(Node node)&#123; Node x = node.right; // 左旋转 node.right = x.left; x.left = node; x.color = node.color; node.color = RED; return x; &#125; // node x // / \\ 右旋转 / \\ // x T2 -------&gt; y node // / \\ / \\ // y T1 T1 T2 private Node rightRotate(Node node) &#123; Node x = node.left; //右旋转 node.left = x.right; x.right = node; x.color = node.color; node.color = RED; return x; &#125; //颜色翻转 private void flipColors(Node node) &#123; node.color = RED; node.left.color = BLACK; node.right.color = BLACK; &#125; // 向红黑树中添加新的元素(key, value) public void add(K key, V value)&#123; root = add(root, key, value); root.color = BLACK; // 最终根节点为黑色节点 &#125; // 向以node为根的红黑树中插入元素(key, value)，递归算法 // 返回插入新节点后红黑树的根 private Node add(Node node, K key, V value)&#123; if(node == null)&#123; size ++; return new Node(key, value); // 默认插入红色节点 &#125; if(key.compareTo(node.key) &lt; 0) node.left = add(node.left, key, value); else if(key.compareTo(node.key) &gt; 0) node.right = add(node.right, key, value); else // key.compareTo(node.key) == 0 node.value = value; // if(isRed(node.right) &amp;&amp; !isRed(node.left)) &#123; node = leftRotate(node); &#125; if(isRed(node.left) &amp;&amp; isRed(node.left.left)) &#123; node = rightRotate(node); &#125; if(isRed(node.left) &amp;&amp; isRed(node.right)) &#123; flipColors(node); &#125; return node; &#125; // 返回以node为根节点的二分搜索树中，key所在的节点 private Node getNode(Node node, K key)&#123; if(node == null) return null; if(key.equals(node.key)) return node; else if(key.compareTo(node.key) &lt; 0) return getNode(node.left, key); else // if(key.compareTo(node.key) &gt; 0) return getNode(node.right, key); &#125; public boolean contains(K key)&#123; return getNode(root, key) != null; &#125; public V get(K key)&#123; Node node = getNode(root, key); return node == null ? null : node.value; &#125; public void set(K key, V newValue)&#123; Node node = getNode(root, key); if(node == null) throw new IllegalArgumentException(key + \" doesn't exist!\"); node.value = newValue; &#125; // 返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node)&#123; if(node.left == null) return node; return minimum(node.left); &#125; // 删除掉以node为根的二分搜索树中的最小节点 // 返回删除节点后新的二分搜索树的根 private Node removeMin(Node node)&#123; if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; node.left = removeMin(node.left); return node; &#125; // 从二分搜索树中删除键为key的节点 public V remove(K key)&#123; Node node = getNode(root, key); if(node != null)&#123; root = remove(root, key); return node.value; &#125; return null; &#125; private Node remove(Node node, K key)&#123; if( node == null ) return null; if( key.compareTo(node.key) &lt; 0 )&#123; node.left = remove(node.left , key); return node; &#125; else if(key.compareTo(node.key) &gt; 0 )&#123; node.right = remove(node.right, key); return node; &#125; else&#123; // key.compareTo(node.key) == 0 // 待删除节点左子树为空的情况 if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; // 待删除节点右子树为空的情况 if(node.right == null)&#123; Node leftNode = node.left; node.left = null; size --; return leftNode; &#125; // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; &#125; &#125;&#125; 哈希表1、哈希表：每一个字符都和一个索引相对应 O(1)的查找操作！ 2、哈希函数：对于给定字符，将其转为索引的方法； 3、哈希冲突：每一个”键“通过哈希函数的转换对应相同的”索引“； 4、哈希表充分体现了算法设计领域的经典思想：空间换时间，哈希表是时间和空间之间的平衡； 5、哈希函数的设计：”键“通过哈希函数得到的”索引“分布越均匀越好； 6、大整数： 通常做法：取模（陷阱-&gt;分布不均匀）； 简单解决办法：模一个素数。 7、浮点型（转成整型处理）：在计算机中都是32位或者64位的二进制表示，只不过计算机解析成了浮点数； 8、字符串：转成整型处理； 9、复合类型：转成整型处理； 10、哈希函数设计原则： 一致性：如果a==b，则hash（a）= hash（b）； 高效性：计算高效简便； 均匀性：哈希值均匀分布。 11、Java默认的hash函数是根据对象的地址计算hashcode； 12、哈希冲突处理：链地址法（Separate Chaining）； 13、Java8之前，每个位置对应一个链表； ​ Java8开始，当哈希冲突达到一定程度，每一个位置从链表转成红黑树。 14、哈希表，链地址法时间复杂度： 总共有M个地址，如果放入哈希表的元素为N， 如果每个地址是链表：O(N/M)； 如果每个地址是平衡树：O(log(N/M))。 15、哈希表： 均摊复杂度为O（1）； 牺牲了顺序性。 16、集合、映射： 有序集合、有序映射（平衡树）； 无序集合、无序映射（哈希表）。 17、哈希冲突的处理方法： 开放地址法：开放（每个地址对任何元素开放）； 线性探测（遇到哈希冲突+1）、平方探测（遇到冲突 + 1+ 4 + 9 + 16）、二次哈希（遇到哈希冲突 + hash2（key））； 负载率：哈希表存储的元素分比 链地址法：封闭； 再哈希法：用另外哈希函数找索引； Coalesced Hashing：综合了Separate Chaining 和 Open Addressing。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.util.TreeMap;public class HashTable&lt;K, V&gt; &#123; private final int[] capacity = &#123;53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469, 12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457, 1610612741&#125;;//保证扩容缩容是素数 private static final int upperTol = 10; private static final int lowerTol = 2; private int capacityIndex = 0; private TreeMap&lt;K, V&gt;[] hashtable; private int M; private int size; public HashTable() &#123; this.M = capacity[capacityIndex]; size = 0; hashtable = new TreeMap[M]; for(int i = 0; i &lt; M; i++) &#123; hashtable[i] = new TreeMap&lt;&gt;(); &#125; &#125; private int hash(K key) &#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public int getSize() &#123; return size; &#125; public void add(K key, V value) &#123; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; if(map.containsKey(key)) &#123; map.put(key, value); &#125; else &#123; map.put(key, value); size++; if(size &gt;= upperTol * M &amp;&amp; capacityIndex + 1 &lt; capacity.length) &#123; capacityIndex++; resize(capacity[capacityIndex]); &#125; &#125; &#125; public V remove(K key) &#123; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; V ret = null; if(map.containsKey(key)) &#123; ret = map.remove(key); size--; if(size &lt; lowerTol * M &amp;&amp; capacityIndex - 1 &gt;= 0) &#123; capacityIndex--; resize(capacity[capacityIndex]); &#125; &#125; return ret; &#125; public void set(K key, V value) &#123; TreeMap&lt;K, V&gt; map = hashtable[hash(key)]; if(!map.containsKey(key)) &#123; throw new IllegalArgumentException(key + \" does't exist!\"); &#125; map.put(key, value); &#125; public boolean contains(K key) &#123; return hashtable[hash(key)].containsKey(key); &#125; public V get(K key) &#123; return hashtable[hash(key)].get(key); &#125; private void resize(int newM) &#123; TreeMap&lt;K, V&gt;[] newHashTable = new TreeMap[newM]; for(int i =0; i &lt; newM; i++) &#123; newHashTable[i] = new TreeMap&lt;&gt;(); &#125; int oldM = M; this.M = newM; for(int i = 0; i &lt; oldM; i++) &#123; TreeMap&lt;K, V&gt; map = hashtable[i]; for(K key : map.keySet()) &#123; newHashTable[hash(key)].put(key, map.get(key)); &#125; &#125; this.hashtable = newHashTable; &#125;&#125; 总结 线性结构：动态数组、普通队列、栈、链表、哈希表； 树形结构：二分搜索树、AVL树、红黑树（统计性能更高）、 堆、线段树、Trie、并查集； 图结构：邻接表、邻接矩阵。 抽象数据结构： 线性表：动态数组、链表； 栈、队列； 集合（有序、无序）、映射（有序、无序）。 参考资料：https://github.com/liuyubobobo/Play-with-Data-Structures","comments":true,"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"Java集合框架","date":"2019-06-07T11:51:45.000Z","path":"2019/06/07/Java集合框架/","text":"Java集合框架（List、Set、Map）总结。 About1、按照接口、实现、算法三个方面对集合框架中的数据结构进行分类： 接口：Collection、List、Map 组成了集合框架中所有具体实现类的接口，它们定义了子类必须实现的方法。 实现：所有实现了上述3个接口的类，都被称作集合框架，实际上就是数据结构。 算法：集合框架提供了很多可以直接调用的算法，比如求最大最小值、排序、填充等。 2、继承体系： 分为两大类，一类实现了 Collection 接口，一类实现了 Map 接口。 3、集合框架核心接口及实现类： Collection：根接口，大部分数据结构都实现了 Collection 接口中的方法； List：实现 List 接口的数据结构，允许重复元素，可通过 index 访问元素，例如 LinkedList、ArrayList、Vector； Set：实现 Set 接口的数据结构，不允许重复的元素，例如 HashSet、LinkedHashSet； SortedSet：实现 SortedSet 接口的数据结构，默认可按升序打印元素，例如 TreeSet； Map：实现 Map 接口的数据结构，存储键值对，不允许重复的 key，例如 HashMap、LinkedHashMap、Hashtable； SortedMap：继承了 Map 接口，存储键值对，不允许重复的 key，默认可按 key 升序打印元素，例如 TreeMap。 SortedSet 与 SortedMap 默认的排序是自然序，可通过 Comparator 或 Comparable 接口实现自定义排序。 4、在接口与具体的实现类之间还有一些抽象类： 这些抽象类为集合增加了很多功能： HashSet：实现 Set 接口，不允许重复的元素，底层数据结构 hash table； LinkedHashSet：实现 Set 接口，不允许重复的元素，底层数据结构 hash table 与双链表； TreeSet：实现 NavigableSet 接口，不允许重复的元素，底层数据结构红黑树； ArrayList：实现 List 接口，允许重复元素，底层数据结构可变数组； LinkedList：实现 List 接口，允许重复元素，底层数据结构双链表； Vector：实现 List 接口，允许重复元素，底层数据结构可变数组； HashMap：实现 Map 接口，不允许重复的 key，底层数据结构 hash table； LinkedHashMap：实现 Map 接口，不允许重复的 key，底层数据结构 hash table 与双链表； HashTable：实现 Map 接口，不允许重复的 key，底层数据结构 hash table； TreeMap：实现 SortedMap 接口，不允许重复的 key，底层数据结构红黑树。 List一个有序的Collection（也称序列），元素可以重复。列表通常允许满足e1.equals(e2)的元素对e1和e2，并且列表允许多个null元素。实现List的类有：ArrayList、LinkedList、Vector、Stack等。其中，最常用的是ArrayList和LinkedList。List接口是有序集合、元素可以重复，次序是List接口最重要的特点，它是以元素的添加的顺序作为集合的顺序。其中ArrayList底层是通过数组实现的，数组的初始长度为10，可以扩展数组。LinkedList底层是通过双向链表实现的，因此LinkedList可以在首尾添加删减元素，因此可以作为栈、队列、双端队列使用。 ArrayList1、概述： ArrayList实现了List接口，以数组实现，允许重复，允许放入null元素，非线程安全。超出限制时会增加50%的容量，每次扩容都底层采用System.arrayCopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建数组的大小为10。 size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。 为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。 2、方法剖析： set() 1234567//既然底层是一个数组，ArrayList的set()方法也就变得非常简单，直接对数组的指定位置赋值即可。public E set(int index, E element) &#123; rangeCheck(index);//下标越界检查 E oldValue = elementData(index); elementData[index] = element;//赋值到指定位置 return oldValue; &#125; get() 123456//get()方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。public E get(int index) &#123; rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index);//注意类型转换 &#125; add() 123456789101112//在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//原来的1.5倍 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);//扩展空间并复制&#125; 空间的问题解决后，插入过程就很容易。 add(int index, E e)需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。 addAll() addAll()方法能够一次添加多个元素，根据位置不同也有两个方法，一个是在末尾添加的addAll(Collection&lt;? extends E&gt; c)方法，一个是从指定位置开始插入的addAll(int index, Collection&lt;? extends E&gt; c)方法。跟add()方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。addAll()的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。 remove() 1234567891011//remove()方法也有两个版本，一个是remove(int index)删除指定位置的元素，另一个是remove(Object o)删除第一个满足o.equals(elementData[index])的元素。删除操作是add()操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, umMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 关于Java GC这里需要特别说明一下，有了垃圾收集器并不意味着一定不会有内存泄漏。对象能否被GC的依据是，是否还有引用指向它，上面代码中如果不手动赋null值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。 LinkedList1、概述： LinkedList以双向链表实现，允许重复，线程不安全。LinkedList同时实现了List接口和Deque接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（Queue），同时又可以看作一个栈（Stack）。这样看来，LinkedList简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用LinkedList，一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是，Java里根本没有一个叫做Queue的类（它是个接口名字）。关于栈或队列，现在的首选是ArrayDeque，它有着比LinkedList（当作栈或队列使用时）更好的性能。 双向链表的每个节点用内部类Node表示。LinkedList通过first和last引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候first和last都指向null。 1234567891011//Node内部类private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; LinkedList的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率LinkedList没有实现同步（synchronized）。 2、方法剖析： add() 123456789101112131415161718192021222324252627282930//add()方法有两个版本，一个是add(E e)，该方法在LinkedList的末尾插入元素，因为有last指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是add(int index, E element)，该方法是在指定下标处插入元素，需要先通过线性查找，找到具体位置，然后修改相关引用完成插入操作。public boolean add(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode;//原来链表为空，这是插入的第一个元素 else l.next = newNode; size++; return true;&#125;//add(int index, E element)的逻辑稍显复杂，可以分成两步，1.先根据index找到要插入的位置；2.修改引用，完成插入操作。public void add(int index, E element) &#123; checkPositionIndex(index);//index &gt;= 0 &amp;&amp; index &lt;= size; if (index == size)//插入位置是末尾，包括列表为空的情况 add(element); else&#123; Node&lt;E&gt; succ = node(index);//1.先根据index找到要插入的位置 //2.修改引用，完成插入操作。 final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null)//插入位置为0 first = newNode; else pred.next = newNode; size++; &#125;&#125; 上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件index &lt; (size &gt;&gt; 1)，也即是index是靠近前端还是后端。 remove() 123456789101112131415161718192021222324//remove()方法也有两个版本，一个是删除跟指定元素相等的第一个元素remove(Object o)，另一个是删除指定下标处的元素remove(int index)。//两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。在寻找被删元素引用的时候remove(Object o)调用的是元素的equals方法，而remove(int index)使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个revome()方法都是通过unlink(Node&lt;E&gt; x)方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。E unlink(Node&lt;E&gt; x) &#123;//删除一个Node // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123;//删除的是第一个元素 first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123;//删除的是最后一个元素 last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; get() 12345//get(int index)得到指定下标处元素的引用，通过调用上文中提到的node(int index)方法实现。public E get(int index) &#123; checkElementIndex(index);//index &gt;= 0 &amp;&amp; index &lt; size; return node(index).item;&#125; set() 12345678//set(int index, E element)方法将指定下标处的元素修改成指定值，也是先通过node(int index)找到对应下表元素的引用，然后修改Node中item的值。public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125; HashSet和HashMapSet几乎都是内部用一个Map来实现, 因为Map里的KeySet就是一个Set，而value是假值，全部使用同一个Object。Set的特征也继承了那些内部Map实现的特征。HashSet里面有一个HashMap（适配器模式）。 HashMap1、概述： HashMap实现了Map接口，允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。HashMap存储着Entry(hash, key, value, next)对象。除该类未实现同步外，其余跟Hashtable大致相同，跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。Java HashMap采用的是冲突链表方式。 如果选择合适的哈希函数，put()和get()方法可以在常数时间内完成。但在对HashMap进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设的过大。 有两个参数可以影响HashMap的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。Capacity的默认值为16，负载因子的默认值为0.75。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。 将对象放入到HashMap或HashSet中时，有两个方法需要特别关心：hashCode()和equals()。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到HashMap或HashSet中，需要@Override hashCode()和equals()方法。 2、方法剖析： get() 上图中hash(k)&amp;(table.length-1)等价于hash(k)%table.length，原因是HashMap要求table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将哈希值的高位全抹掉，剩下的就是余数了。 123456789101112131415//get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.getValue()。因此getEntry()是算法的核心。//算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过key.equals(k)方法来判断是否是要找的那个entry。final Entry&lt;K,V&gt; getEntry(Object key) &#123; ...... int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-1)];//得到冲突链表 e != null; e = e.next) &#123;//依次遍历冲突链表中的每个entry Object k; //依据equals()方法判断是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; put() 123456789101112//put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry，插入方式为头插法。void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);//自动扩容，并重新哈希 hash = (null != key) ? hash(key) : 0; bucketIndex = hash &amp; (table.length-1);//hash%table.length &#125; //在冲突链表头部插入新的entry Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; remove() 123456789101112131415161718192021//remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry（修改链表的相应指针）。查找过程跟getEntry()过程类似。final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; ...... int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length);//hash&amp;(table.length-1) Entry&lt;K,V&gt; prev = table[i];//得到冲突链表 Entry&lt;K,V&gt; e = prev; while (e != null) &#123;//遍历冲突链表 Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;//找到要删除的entry modCount++; size--; if (prev == e) table[i] = next;//删除的是冲突链表的第一个entry else prev.next = next; return e; &#125; prev = e; e = next; &#125; return e;&#125; HashSetHashSet是基于HashMap来实现的，操作很简单，更像是对HashMap做了一次“封装”，而且只使用了HashMap的key来实现各种特性，而HashMap的value始终都是PRESENT。HashSet不允许重复（HashMap的key不允许重复，如果出现重复就覆盖），允许null值，非线程安全。 12345678910111213public class HashSet&lt;E&gt; &#123; ...... private transient HashMap&lt;E,Object&gt; map;//HashSet里面有一个HashMap // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; ...... public boolean add(E e) &#123;//简单的方法转换 return map.put(e, PRESENT)==null; &#125; ...... LinkedHashSet 和 LinkedHashMapLinkedHashSet和LinkedHashMap在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说LinkedHashSet里面有一个LinkedHashMap（适配器模式）。 LinkedHashMap1、概述： LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素，非线程安全。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。可将LinkedHashMap看作采用linked list增强的HashMap。 事实上LinkedHashMap是HashMap的直接子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表（doubly-linked list）的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部（是一个哑元），该双向链表的迭代顺序就是entry的插入顺序。 除了可以保证迭代顺序，这种结构还有一个好处：迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可，也就是说LinkedHashMap的迭代时间就只跟entry的个数相关，而跟table的大小无关。 有两个参数可以影响LinkedHashMap的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。 将对象放入到LinkedHashMap或LinkedHashSet中时，有两个方法需要特别关心：hashCode()和equals()。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到LinkedHashMap或LinkedHashSet中，需要@OverridehashCode()和equals()方法。 12345//通过如下方式可以得到一个跟源Map迭代顺序一样的LinkedHashMapvoid foo(Map m) &#123; Map copy = new LinkedHashMap(m); ...&#125; 2、方法剖析： get() get(Object key)方法根据指定的key值返回对应的value。该方法跟HashMap.get()方法的流程几乎完全一样。 put() 123456789101112131415161718192021222324//put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于get()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry。//这里的插入有两重含义：1、从table的角度看，新的entry需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的entry插入到冲突链表的头部。2、从header的角度看，新的entry需要插入到双向链表的尾部。void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);// 自动扩容，并重新哈希 hash = (null != key) ? hash(key) : 0; bucketIndex = hash &amp; (table.length-1);// hash%table.length &#125; // 1.在冲突链表头部插入新的entry HashMap.Entry&lt;K,V&gt; old = table[bucketIndex]; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(hash, key, value, old); table[bucketIndex] = e; // 2.在双向链表的尾部插入新的entry e.addBefore(header); size++;&#125;//上述代码中用到了addBefore()方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。addBefore()的代码如下：// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this;&#125; remove() 1234567891011121314151617181920212223242526//remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry（修改链表的相应引用）。查找过程跟get()方法类似。//这里的删除也有两重含义：1、从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。2、从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; ...... int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length);// hash&amp;(table.length-1) Entry&lt;K,V&gt; prev = table[i];// 得到冲突链表 Entry&lt;K,V&gt; e = prev; while (e != null) &#123;// 遍历冲突链表 Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;// 找到要删除的entry modCount++; size--; // 1. 将e从对应bucket的冲突链表中删除 if (prev == e) table[i] = next; else prev.next = next; // 2. 将e从双向链表中删除 e.before.after = e.after; e.after.before = e.before; return e; &#125; prev = e; e = next; &#125; return e;&#125; LinkedHashSetLinkedHashSet允许null值，保留插入顺序，非线程安全。 1234567891011121314public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; ...... // LinkedHashSet里面有一个LinkedHashMap public LinkedHashSet(int initialCapacity, float loadFactor) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; ...... public boolean add(E e) &#123;//简单的方法转换 return map.put(e, PRESENT)==null; &#125; ......&#125; TreeMap和TreeSetTreeMap1、总体介绍： Java TreeMap实现了SortedMap接口，也就是说会按照key的大小顺序对Map中的元素进行排序，key大小的评判可以通过其本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator），TreeMap是非线程安全的。 TreeMap底层通过红黑树（Red-Black tree）实现，也就意味着containsKey(), get(), put(), remove()都有着log(n)的时间复杂度。 红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍。具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）： 每个节点要么是红色，要么是黑色； 根节点必须是黑色； 红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）； 对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。 在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的条件。 预备知识当查找树的结构发生改变时，红黑树的条件可能被破坏，需要通过调整使得查找树重新满足红黑树的条件。调整可以分为两类：一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，即改变检索树的结构关系。结构调整过程包含两个基本操作：左旋（Rotate Left），右旋（Rotate Right）。 左旋：将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 1234567891011121314151617private void rotateLeft(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; &#125;&#125; 右旋：将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 123456789101112131415private void rotateRight(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; &#125;&#125; 方法剖析get() 123456789101112131415161718//get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.value。因此getEntry()是算法的核心。算法思想是根据key的自然顺序（或者比较器顺序）对二叉查找树进行查找，直到找到满足k.compareTo(p.key) == 0的entry。final Entry&lt;K,V&gt; getEntry(Object key) &#123; ...... if (key == null)//不允许key值为null throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序 Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0)//向左找 p = p.left; else if (cmp &gt; 0)//向右找 p = p.right; else return p; &#125; return null;&#125; put() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束，还需要进行调整（旋转，改变某些节点的颜色）。//首先在红黑树上找到合适的位置，然后创建新的entry并插入（当然，新插入的节点一定是树的叶子）。难点是调整函数fixAfterInsertion()，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。public V put(K key, V value) &#123; ...... int cmp; Entry&lt;K,V&gt; parent; if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left;//向左找 else if (cmp &gt; 0) t = t.right;//向右找 else return t.setValue(value); &#125; while (t != null); Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);//创建并插入新的entry if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e);//调整 size++; return null;&#125;//调整函数fixAfterInsertion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况。private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123;//如果y为null，则视为BLACK setColor(parentOf(x), BLACK); // 情况1 setColor(y, BLACK); // 情况1 setColor(parentOf(parentOf(x)), RED); // 情况1 x = parentOf(parentOf(x)); // 情况1 &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); // 情况2 rotateLeft(x); // 情况2 &#125; setColor(parentOf(x), BLACK); // 情况3 setColor(parentOf(parentOf(x)), RED); // 情况3 rotateRight(parentOf(parentOf(x))); // 情况3 &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); // 情况4 setColor(y, BLACK); // 情况4 setColor(parentOf(parentOf(x)), RED); // 情况4 x = parentOf(parentOf(x)); // 情况4 &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); // 情况5 rotateRight(x); // 情况5 &#125; setColor(parentOf(x), BLACK); // 情况6 setColor(parentOf(parentOf(x)), RED); // 情况6 rotateLeft(parentOf(parentOf(x))); // 情况6 &#125; &#125; &#125; root.color = BLACK;&#125; remove() remove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entry&lt;K,V&gt; entry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束，因此有可能要进行调整。 寻找节点后继： 对于一棵二叉查找树，给定节点t，其后继（树种比大于t的最小的那个元素）可以通过如下方式找到： t的右子树不空，则t的后继是其右子树中最小的那个元素。 t的右孩子为空，则t的后继是其第一个向左走的祖先。 123456789101112131415161718static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.right != null) &#123;// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素 Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; &#125; else &#123;// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先 Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.right) &#123; ch = p; p = p.parent; &#125; return p; &#125;&#125; remove() getEntry()函数前面已经讲解过，这里重点放deleteEntry()上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用fixAfterDeletion(Entry&lt;K,V&gt; x)进行调整。 由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况： 删除点p的左右子树都为空，或者只有一棵子树非空。 删除点p的左右子树都非空。 对于上述情况1，处理起来比较简单，直接将p删除（左右子树都为空时），或者用非空子树替代p（只有一棵子树非空时）；对于情况2，可以用p的后继s（树中大于x的最小的那个元素）代替p，然后使用情况1删除s（此时s一定满足情况1，可以画画看）。 基于以上逻辑，红黑树的节点删除函数deleteEntry()代码如下： 1234567891011121314151617181920212223242526272829303132333435private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; if (p.left != null &amp;&amp; p.right != null) &#123;// 2. 删除点p的左右子树都非空。 Entry&lt;K,V&gt; s = successor(p);// 后继 p.key = s.key; p.value = s.value; p = s; &#125; Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123;// 1. 删除点p只有一棵子树非空。 replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; p.left = p.right = p.parent = null; if (p.color == BLACK) fixAfterDeletion(replacement);// 调整 &#125; else if (p.parent == null) &#123; root = null; &#125; else &#123; // 1. 删除点p的左右子树都为空 if (p.color == BLACK) fixAfterDeletion(p);// 调整 if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125;&#125; 上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数fixAfterDeletion()。首先请思考一下，删除了哪些点才会导致调整？只有删除点是BLACK的时候，才会触发调整函数，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。 跟上文中讲过的fixAfterInsertion()函数一样，这里也要分成若干种情况。记住，无论有多少情况，具体的调整操作只有两种：1.改变某些节点的颜色，2.对某些节点进行旋转。 上述图解的总体思想是：将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则：a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环（因为x为红色）；b).一旦进入情况3和情况4，一定会退出循环（因为x为root）。 删除后调整函数fixAfterDeletion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); // 情况1 setColor(parentOf(x), RED); // 情况1 rotateLeft(parentOf(x)); // 情况1 sib = rightOf(parentOf(x)); // 情况1 &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); // 情况2 x = parentOf(x); // 情况2 &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); // 情况3 setColor(sib, RED); // 情况3 rotateRight(sib); // 情况3 sib = rightOf(parentOf(x)); // 情况3 &#125; setColor(sib, colorOf(parentOf(x))); // 情况4 setColor(parentOf(x), BLACK); // 情况4 setColor(rightOf(sib), BLACK); // 情况4 rotateLeft(parentOf(x)); // 情况4 x = root; // 情况4 &#125; &#125; else &#123; // 跟前四种情况对称 Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); // 情况5 setColor(parentOf(x), RED); // 情况5 rotateRight(parentOf(x)); // 情况5 sib = leftOf(parentOf(x)); // 情况5 &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); // 情况6 x = parentOf(x); // 情况6 &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); // 情况7 setColor(sib, RED); // 情况7 rotateLeft(sib); // 情况7 sib = leftOf(parentOf(x)); // 情况7 &#125; setColor(sib, colorOf(parentOf(x))); // 情况8 setColor(parentOf(x), BLACK); // 情况8 setColor(leftOf(sib), BLACK); // 情况8 rotateRight(parentOf(x)); // 情况8 x = root; // 情况8 &#125; &#125; &#125; setColor(x, BLACK);&#125; TreeSetTreeSet是对TeeMap的简单包装，对TreeSet的函数调用都会转换成合适的TeeMap方法。TreeSet不允许重复，不允许null值（如果有基于null的比较器，就可以允许为null），默认按升序排列。 12345678910111213141516public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123; ...... private transient NavigableMap&lt;E,Object&gt; m; // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); public TreeSet() &#123; this.m = new TreeMap&lt;E,Object&gt;();// TreeSet里面有一个TreeMap &#125; ...... public boolean add(E e) &#123; return m.put(e, PRESENT)==null; &#125; ......&#125; 博客转自：https://www.cnblogs.com/CarpenterLee/p/5545987.html","comments":true,"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://yoursite.com/tags/Java集合框架/"}]},{"title":"常用Linux命令","date":"2019-06-06T08:00:00.000Z","path":"2019/06/06/常用Linux命令/","text":"Linux 常用命令及解释。 很多服务器上都是Linux系统，要和服务器机器交互，就要通过shell命令。 查找文件1、find / -name filename.txt 根据名称查找/目录下的filename.txt文件 2、find . -name “*.xml” 递归查找当前目录下所有的xml文件 3、find . -name “*.xml” | xargs grep “hello world” 递归查找当前目录下所有文件内容中包含hello world的xml文件 4、grep -H ‘spring’ *.xml 查找当前目录下所有包含spring的xml文件 5、find ./ -size 0 | xargs rm -f &amp; 删除文件大小为零的文件 6、ls -l | grep ‘.jar’ 查找当前目录中的所有jar文件 7、grep ‘test’ d* 显示当前目录下所有以d开头的文件中包含test的行 8、grep ‘test’ aa bb cc 显示在aa，bb，cc文件中匹配test的行 9、grep ‘[a-z]{5}‘ aa 显示所有包含每个字符串至少有5个连续小写字符的字符串的行 查看一个程序是否运行1、ps –ef | grep tomcat 查看所有有关tomcat的进程 2、ps -ef | grep –color java 高亮要查询的关键字 终止线程kill -9 20000 终止线程号为20000的进程 查看文件，包含隐藏文件ls -al 当前工作目录pwd 复制文件1、cp source 新文件名/目录， 复制文件 2、cp -r sourceFolder targetFolder 递归复制整个文件夹 3、scp sourecFile romoteUserName@remoteIp:remoteAddr 远程拷贝 创建目录mkdir newfolder 删除目录1、rmdir deleteEmptyFolder 删除空目录 2、rm -rf deleteFile 递归删除目录中所有内容 移动文件mv /temp/movefile /targetFolder 重命名mv oldNameFile newNameFile 切换用户su -username 修改文件权限chmod 777 file.java //file.java的权限-rwx，r表示读、w表示写、x表示可执行 压缩文件tar -czf test.tar.gz /test1 /test2 列出压缩文件列表tar -tzf test.tar.gz 解压文件tar -xvzf test.tar.gz 查看文件头10行head -n 10 example.txt 查看文件尾10行tail -n 10 example.txt 查看日志类型文件tail -f exmaple.log //这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）。 使用超级管理员身份执行命令sudo rm a.txt 使用管理员身份删除文件 查看端口占用情况netstat -tln | grep 8080 查看端口8080的使用情况 查看端口属于哪个程序lsof -i :8080 查看进程1、ps aux|grep java 查看java进程 2、ps aux 查看所有进程 以树状图列出目录的内容tree a 文件下载1、wget http://file.tgz 2、curl http://file.tgz 网络检测ping www.just-ping.com 远程登录ssh userName@ip 查看ip地址ifconfig -a 打印信息echo $JAVA_HOME 打印java home环境变量的值 java 常用命令java javac jps ,jstat ,jmap, jstack 其他命令svn、 git 、maven linux命令学习网站http://explainshell.com/ linux命令搜索引擎https://jaywcjlove.gitee.io/linux-command/ 博客转自：https://www.hollischuang.com/archives/800","comments":true,"tags":[{"name":"Linux常用命令","slug":"Linux常用命令","permalink":"http://yoursite.com/tags/Linux常用命令/"}]},{"title":"设计模式-单例模式","date":"2019-06-05T02:03:09.000Z","path":"2019/06/05/单例模式/","text":"单例模式介绍。 About1、模式定义：单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 单例模式的要点有三个： 某个类只能有一个实例； 它必须自行创建这个实例； 它必须自行向整个系统提供这个实例。 单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。 2、模式结构： 单例模式只有一个Singleton角色，并且这个类自行创建自己的实例，并向系统提供这个实例。 单例模式分为懒汉式的和饿汉式，登记式的单例模式，下面我们就来介绍一下这三种单例模式。 饿汉式的单例模式1、饿汉式单例模式是Java语言中实现起来最为简单的单例模式。 2、饿汉式：初始化类时，直接就创建唯一实例，天生线程安全。 3、三要素： 一个静态类变量； 一个私有构造方法； 一个全局静态的类方法。 4、代码实现： 12345678910public class EagerSingleton &#123; //直接创建一个本类的对象 private static EagerSingleton instance = new EagerSingleton(); //覆盖默认的构造方法，将默认的构造方法声明为私有的，防止其他类直接创建对象，将 new Singleton() 堵死 private EagerSingleton() &#123;&#125; //提供一个工厂方法来返回本类的唯一对象 public static EagerSingleton getInstance() &#123; return instance; &#125;&#125; 5、饿汉式单例模式就是一开始就自己创建一个私有的静态的本类对象，当这个类被加载时，静态变量instance就会被初始化，这时这个类的私有构造方法就会被调用。这个时候，单例类的唯一实例就被创建出来了。但需要获得单例类的对象是就调用getInstance方法。需要注意的一点就是单例类的构造方法一定要声明为私有的，否则其他类就可以利用构造方法直接创建对象，使单例类不再是只有一个唯一的实例。 由于构造方法是私有的，因此此类不能被继承。 饿汉式单例模式在自己加载时就将自己实例化，所以从资源利用效率的角度来讲，饿汉式单例模式不如懒汉式单例模式节省资源，但是饿汉式单例模式的速度更快一些。 懒汉式的单例模式1、懒汉式：加载类时，第一次调用方法获得实例为唯一的实例，线程不安全。 2、三要素： 一个静态类变量； 一个私有构造方法； 一个全局静态的类方法。 3、代码实现： 12345678910111213141516171819public class LazySingleton &#123; //单例类的唯一实例，但是不是加载时初始化 private static volatile LazySingleton instacnce = null; //构造函数私有为了保证在其他地方不能new该实例 private LazySingleton() &#123;&#125; //线程互斥的获取实例 public static LazySingleton getInstance() &#123;//获得实例 if(instacnce == null) &#123; // 加锁 synchronized (LazySingleton.class) &#123; // 这一次判断也是必须的，不然会有并发问题 if(instacnce == null) &#123; instacnce = new LazySingleton(); &#125; &#125; &#125; return instacnce; &#125;&#125; 4、懒汉式单例模式的创建对象是在第一次企图获得单例类的对象时。另外我们在getInstance方法中使用了synchronization关键字，这是防止出现race condition，使两个线程new出来两个单例类的实例。构造方法同样是私有的，这也决定了子类不能继承自这个类。 懒汉式单例模式与饿汉式单例模式相比，更节省资源，但是必须处理好在多个线程同时首次引用此类时的访问限制问题，特别是当单例类作为资源控制器在实例化时必然涉及资源初始化，而资源初始化很有可能耗费时间，这就意味着出现多个线程同时首次引用此类的几率变得较大。 登记式的单例模式1、为了克服饿汉式单例模式以及懒汉式单例模式类均不可继承的缺点，产生了一种新的模式——登记式单例模式。 登记式的单例模式中父类中有一个集合，用来存储所有的子类的实例，当一个子类创建时，必须在父类的中登记，也就是把自己的实例加入到父类的集合中，当其他类想要获取子类的实例时，就到父类的集合中查找，找到了就返回，如果找不到就创建这个子类的唯一实例。 2、父类代码： 12345678910111213141516171819202122232425262728293031package com.singleton;import java.util.HashMap;public class RegSingleton &#123; //建立一个HashMap来存储子类的完整类名和子类的实例 private static HashMap&lt;String, RegSingleton&gt; registry = new HashMap&lt;&gt;(); //首先将本类的实例加入到HashMap中 static &#123; RegSingleton x = new RegSingleton(); registry.put(x.getClass().getName(), x); &#125; //构造方法不再是private的了，所以子类可以继承了 protected RegSingleton() &#123; &#125; //根据子类传来的类名返回相应的实例 public static RegSingleton getInstance(String name) &#123; //提供默认的类 if(name == null) &#123; name = \"com.singleton.RegSingleton\"; &#125; //第一次引用这个类时创建类的实例，利用了反射机制 if(registry.get(name) == null) &#123; try &#123; registry.put(name, (RegSingleton)Class.forName(name).newInstance()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //返回子类想要的类的实例 return registry.get(name); &#125;&#125; 子类代码： 12345678910package com.singleton;public class RegSingletonChild extends RegSingleton &#123; //构造方法必须是公有的，否则父类无法产生子类的对象 public RegSingletonChild() &#123; &#125; //工厂方法，获取本类的唯一实例，实际上是借助了父类的getInstance方法 public static RegSingletonChild getInstance() &#123; return (RegSingletonChild) RegSingleton.getInstance(\"com.singleton.RegSingletonChild\"); &#125;&#125; 3、登记式的单例模式解决了懒汉式和饿汉式不能继承的缺点，但是子类中的构造方法变为了public的，所以其他类可以直接通过构造方法创建类的实例而不用向父类中登记，这是登记式单例模式最大的缺点。 总结1、什么情况下使用单例模式？ 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。 在一个系统中要求一个类只有一个实例时才应当使用单例模式。 2、单例模式的优点和缺点？ 优点： 提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。 允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。 缺点： 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。 参考博客：https://www.kancloud.cn/digest/xing-designpattern/143725","comments":true,"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"设计模式-工厂模式","date":"2019-06-04T13:31:48.000Z","path":"2019/06/04/工厂设计模式/","text":"简单工厂模式、工厂模式、抽象工厂模式介绍。 About在面向对象编程中, 最通常的方法是一个new操作符产生一个对象实例，new操作符就是用来构造对象实例的。但是在一些情况下，new操作符直接生成对象会带来一些问题。举例来说, 许多类型对象的创造需要一系列的步骤: 你可能需要计算或取得对象的初始设置；选择生成哪个子对象实例；或在生成你需要的对象之前必须先生成一些辅助功能的对象。 在这些情况，新对象的建立就是一个 “过程”，不仅是一个操作，像一部大机器中的一个齿轮传动。 模式的问题：你如何能轻松方便地构造对象实例，而不必关心构造对象实例的细节和复杂过程呢？ 解决方案：建立一个工厂来创建对象。 简单工厂模式1、模式定义：简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式（同属于创建型模式的还有工厂方法模式，抽象工厂模式，单例模式，建造者模式）。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 2、模式结构： 3、简单工厂模式由三部分组成：具体工厂、具体产品和抽象产品。 工厂类（Creator）角色：担任这个角色的是简单工厂模式的核心，含有与应用紧密相关的商业逻辑。工厂类在客户端的直接调用下创建产品对象，它往往由一个具体Java类实现。 抽象产品（AbstractProduct）角色：担任这个角色的类是由简单工厂模式所创建的对象的父类，或它们共同拥有的接口。抽象产品角色可以用一个Java接口或者Java抽象类实现。 具体产品（ConcreteProduct）角色：简单工厂模式所创建的任何对象都是这个角色的实例，具体产品角色由一个具体Java类实现。 4、代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//1、创建了一个Car接口，作为所有汽车的父类，具体的实现由子类来实现。public interface Car &#123; void run(); void stop();&#125;//2、BMW实现类public class BMW implements Car &#123; @Override public void run() &#123; System.out.println(\"宝马启动了！\"); &#125; @Override public void stop() &#123; System.out.println(\"宝马熄火了！\"); &#125;&#125;//3、Benz实现类public class Benz implements Car &#123; @Override public void run() &#123; System.out.println(\"奔驰启动了！\"); &#125; @Override public void stop() &#123; System.out.println(\"奔驰熄火了！\"); &#125;&#125;//4、创建一个工厂类，这个工厂类专门负责建造各种汽车//里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。public class CarFactory &#123; public static Car createCar(String type) &#123; Car car = null; if(\"BMW\".equals(type)) &#123; car = new BMW(); &#125; else if(\"Benz\".equals(type)) &#123; car = new Benz(); &#125; else &#123; return null; &#125; return car; &#125; &#125;//5、客户端public class Client &#123; public static void main(String[] args) &#123; Car car = CarFactory.createCar(\"BMW\"); if(car != null) &#123; car.run(); car.stop(); &#125; else &#123; System.out.println(\"造不了车了！\"); &#125; &#125;&#125; 5、优点与缺点： 优点： 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 当需要引入新的产品是不需要修改客户端的代码，只需要添加相应的产品类并修改工厂类就可以了，所以说从产品的角度上简单工厂模式是符合“开-闭”原则的。 缺点： 由于工厂类集中了所有产品创建逻辑，工厂类一般被我们称作“全能类”或者“上帝类”，因为所有的产品创建他都能完成，这看似是好事，但仔细想想是有问题的。比如全国上下所有的事情都有国家主义一个人干会不会有问题，当然有！一旦不能正常工作，整个系统都要受到影响。 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。所以说从工厂的角度来说简单工厂模式是不符合“开-闭”原则的。 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 工厂方法模式1、模式定义：工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 2、模式结构： 3、工厂方法模式一共分为四个部分： 抽象工厂（AbstractCreator）角色：担任这个角色的是工厂方法模式的核心，它是与应用程序无关的。任何在模式中创建对象的工厂类必须继承或者实现这个接口，在实际的系统中，这个角色常常由Java抽象类来实现。 具体工厂（ConcreteCreator）角色：担任这个角色的是实现了抽象工厂接口的具体Java类。具体工厂角色含有与应用密切相关的逻辑，并且受到应用程序的调用以创建产品对象。 抽象产品（AbstractProduct）角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。在实际应用中这个角色常常由Java的抽象类来实现。 具体产品（ConcreteProduct）角色：这个角色实现了抽象产品角色所声明的接口，工厂方法所创建的每一个对象都是某个具体产品角色的实例。 4、代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//1、创建了一个Car接口，作为所有汽车的父类，具体的实现由子类来实现。public interface Car &#123; void run(); void stop();&#125;//2、BMW实现类public class BMW implements Car &#123; @Override public void run() &#123; System.out.println(\"宝马启动了！\"); &#125; @Override public void stop() &#123; System.out.println(\"宝马熄火了！\"); &#125;&#125;//3、Benz实现类public class Benz implements Car &#123; @Override public void run() &#123; System.out.println(\"奔驰启动了！\"); &#125; @Override public void stop() &#123; System.out.println(\"奔驰熄火了！\"); &#125;&#125;//4、定义一个CarFactory接口，定义方法createCar；用来告诉具体的工厂如何来创造汽车。public interface CarFactory &#123; Car createCar();&#125;//5、每一种车都配一个专门的生产工厂。public class BMWFactory implements CarFactory &#123; @Override public Car createCar() &#123; return new BMW(); &#125;&#125;public class BenzFactory implements CarFactory &#123; @Override public Car createCar() &#123; return new Benz(); &#125;&#125;//6、客户端，创建对应的工厂类，让特定的工厂来生产特定的汽车。public class Client &#123; public static void main(String[] args) &#123; // 先选择一个具体的工厂 CarFactory carFactory = new BMWFactory(); // 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象 Car car = carFactory.createCar(); car.run(); car.stop(); &#125;&#125; 5、优点与缺点： 优点： 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 缺点： 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 抽象工厂模式1、模式定义：抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 当涉及到产品族（代表了组成某个产品的一系列附件的集合）的时候，就需要引入抽象工厂模式了。 2、产品族： 当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。 模式结构： 3、抽象工厂方法模式一共分为四个部分： 抽象工厂（AbstractFactory）角色：担任这个角色的是抽象工厂模式的核心，是与应用系统的商业逻辑无关的。通常使用Java接口或者抽象Java类实现。所有的具体工厂必须实现这个Java接口或继承这个抽象的Java类。 具体工厂（Factory）角色：这个角色直接在客户端的调用下创建产品的实例，这个角色含有选择合适的产品对象的逻辑，而这个逻辑是与应用系统商业逻辑紧密相关的。 抽象产品（AbstractProduct）角色：担任这个角色的类是抽象工厂模式所创建的对象的父类，或它们共同拥有的接口。通常使用Java接口或者抽象Java类实现这一角色。 具体产品（Product）角色：抽象工厂模式所创建的任何产品对象都是一个具体的产品类的实例。这是客户端最终需要的东西，其内部一定充满了应用系统的商业逻辑。通常使用具体Java类实现这个角色。 与工厂方法模式不同的是，抽象工厂模式中的具体工厂不再是只能创建一种产品，一个具体的工厂可以创建一个产品族的产品。 4、代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//1、创建CPU和MainBoard接口public interface CPU &#123; void show();&#125;public interface MainBoard &#123; void show();&#125;//2public class AmdCPU implements CPU &#123; @Override public void show() &#123; System.out.println(\"AMD CPU!\"); &#125;&#125;public class AmdMainBoard implements MainBoard &#123; @Override public void show() &#123; System.out.println(\"AMD MainBoard!\"); &#125;&#125;public class InterCPU implements CPU &#123; @Override public void show() &#123; System.out.println(\"Intel CPU!\"); &#125;&#125;public class IntelMainBoard implements MainBoard &#123; @Override public void show() &#123; System.out.println(\"Intel MainBoard!\"); &#125;&#125;//3、创建电脑工厂接口public interface ComputerFactory &#123; CPU makeCPU(); MainBoard makeMainBoard();&#125;//4public class AmdFactory implements ComputerFactory &#123; @Override public CPU makeCPU() &#123; return new AmdCPU(); &#125; @Override public MainBoard makeMainBoard() &#123; return new AmdMainBoard(); &#125;&#125;public class IntelFactory implements ComputerFactory &#123; @Override public CPU makeCPU() &#123; return new InterCPU(); &#125; @Override public MainBoard makeMainBoard() &#123; return new IntelMainBoard(); &#125;&#125;//5、客户端/** * 对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等， * 直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。 * */public class Client &#123; public static void main(String[] args) &#123; // 第一步就要选定一个“大厂” ComputerFactory cf = new AmdFactory(); // 从这个大厂造 CPU CPU cpu = cf.makeCPU(); // 从这个大厂造主板 MainBoard mainBoard = cf.makeMainBoard(); cpu.show(); mainBoard.show(); &#125;&#125; 5、优点与缺点： 优点： 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点： 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。 参考博客： https://www.kancloud.cn/digest/xing-designpattern https://javadoop.com/post/design-pattern","comments":true,"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Java反射","date":"2019-06-03T11:41:46.000Z","path":"2019/06/03/Java反射/","text":"Java反射总结。 No reflection，No most frameworks. 什么是反射？反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。 通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。 反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 .class 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。 反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。 Java 反射主要提供以下功能： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）； 在运行时调用任意一个对象的方法。 动态编译可以最大程度地支持多态，而多态最大的意义在于降低类的耦合性，因此反射的优点就很明显了：解耦以及提高代码的灵活性。 反射的优点缺点： 优点：运行期类型的判断，动态类加载：提高代码灵活度； 缺点：性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多； 反射的应用： JDBC 的数据库的连接： ​ 通过Class.forName()加载数据库的驱动程序 （通过反射加载，前提是引入相关了Jar包）； Spring 框架的使用： ​ Java的反射机制在做基础框架的时候非常有用，行内有一句这样的老话：反射机制是Java框架的基石。一般应用层面很少用，不过这种东西，现在很多开源框架基本都已经封装好了，自己基本用不着写。典型的除了hibernate之外，还有spring也用到很多反射机制。最经典的就是xml的配置模式。 Spring 通过 XML 配置模式装载 Bean 的过程： 将程序内所有 XML 或 Properties 配置文件加载入内存中； Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息； 使用反射机制，根据这个字符串获得某个类的Class实例； 动态配置实例的属性； Spring这样做的好处是： 不用每一次都要在代码里面去new或者做其他的事情； 以后要改的话直接改配置文件，代码维护起来就很方便了； 有时为了适应某些需求，Java类里面不一定能直接调用另外的方法，可以通过反射机制来实现。 反射基本功能获取反射中的Class对象在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。获取 Class 类对象有三种方法： 使用 Class 类的 forName 静态方法：知道该类的全路径名； 1Class.forName(); 直接获取某一个对象的 class：适合在编译前就知道操作的 Class； 1类名.class; 使用类对象的 getClass() 方法。 12类名 对象名 = new 类名();Class c = 对象名.getClass(); 通过反射创建类对象通过反射创建类对象主要有两种方式： 通过 Class 对象的 newInstance() 方法； 12Class c = 类名.class;类名 对象名 = (类名)c.newInstance(); 通过 Constructor 对象的 newInstance() 方法。 123Class c = 类名.class;Constructor constructor = c.getConstructor();类名 对象名 = (类名)constructor.newInstance(); 通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。 123Class c = 类名.class;Constructor constructor = c.getConstructor(String.class, int.class);类名 对象名 = (类名)constructor.newInstance(\"xxx\", 15); 获取类属性方法及构造器1、通过 Class 对象的 getFields() 方法可以获取所有 public 访问权限的属性(包括本类声明的和从父类继承的)； 12345678910Class c = 类名.class;Field[] fields = c.getFields();//遍历属性并输出属性信息for(Field field : fields) &#123; //获取访问权限并输出 int modifiers = field.getModifiers(); System.out.print(Modifier.toString(modifiers) + \" \"); //输出属性的类型及属性名 System.out.println(field.getType().getName() + \" \" + field.getName());&#125; 2、通过 Class 对象的 getDeclaredFields() 方法则可以获取所有本类声明的(不管访问权限)属性； 12Class c = 类名.class;Field[] fields = c.getDeclaredFields(); 3、通过 Class 对象的 getMethods() 方法可以获取所有 public 访问权限的方法(包括本类声明的和从父类继承的)； 12345678910111213141516171819202122232425Class c = 类名.class;Method[] methods = c.getMethods();//遍历属性并输出属性信息for(Method method : methods) &#123; //获取并输出方法的访问权限（Modifiers：修饰符） int modifiers = method.getModifiers(); System.out.print(Modifier.toString(modifiers) + \" \"); //获取并输出方法的返回值类型 Class returnType = method.getReturnType(); System.out.println(returnType.getName() + \" \" + method.getName() + \"(\"); //获取并输出方法的所有参数 Parameter[] parameters = method.getParameters(); for(Parameter parameter : parameters) &#123; System.out.print(parameter.getType().getName() + \" \" + parameter.getName() + \",\"); &#125; //获取并输出方法抛出的异常 Class[] exceptionTypes = method.getExceptionTypes(); if(exceptionTypes.length == 0) &#123; System.out.println(\")\"); &#125; else &#123; for(Class cla: exceptionTypes) &#123; System.out.println(\") throws \" + cla.getName()); &#125; &#125;&#125; 4、通过 Class 对象的 getDeclaredMethods() 方法可以获取所有本类声明的(不管访问权限)方法； 12Class c = 类名.class;Method[] methods = c.getDeclaredMethods(); 5、通过 Class 对象的 getConstructors() 方法可以获取所有 public 访问权限的构造方法； 123456789101112Class c = 类名.classConstructor[] constructors = c.getConstructors();for(Constructor constructor : constructors) &#123; //获取并输出构造方法的访问权限（Modifiers：修饰符） int modifiers = constructor.getModifiers(); System.out.print(Modifier.toString(modifiers) + \" \"); //获取并输出构造方法的所有参数 Parameter[] parameters = constructor.getParameters(); for(Parameter parameter : parameters) &#123; System.out.print(parameter.getType().getName() + \" \" + parameter.getName() + \",\"); &#125;&#125; 6、通过 Class 对象的 getDeclaredConstructors() 方法可以获取所有本类声明的(不管访问权限)构造方法； 12Class c = 类名.classConstructor[] constructors = c.getDeclaredConstructors(); 访问或操作类的私有变量和方法1、访问类的私有方法： 123456789101112131415161718192021//1. 获取 Class 类实例类名 对象名 = new 类名();Class c = 对象名.getClass(); //2. 获取私有方法/** * 第一个参数为要获取的私有方法的名称 * 第二个为要获取方法的参数的类型，参数为 Class...，没有参数就是null * 方法参数也可这么写 ：new Class[]&#123;String.class , int.class&#125; */Method privateMethod = c.getDeclaredMethod(\"私有方法名\", String.class, int.class);//3. 开始操作方法if(privateMethod != null) &#123; //获取私有方法的访问权(只是获取访问权，并不是修改实际权限) privateMethod.setAccessible(true); /** * 使用 invoke 反射调用私有方法 * privateMethod 是获取到的私有方法 * 类对象 要操作的对象 * 后面两个参数传实参 */ privateMethod.invoke(类对象, \"Java Reflect\", 666); 2、修改类的私有变量： 12345678910111213141516171819 //1. 获取 Class 类实例类名 对象名 = new 类名();Class c = 对象名.getClass(); //2. 获取私有变量Field privateField = c.getDeclaredField(\"私有属性名\");//3. 操作私有变量if(privateField != null) &#123; //获取私有变量的访问权 privateField.setAccessible(true); //修改私有变量，并输出以测试 System.out.println(\"Before Modify：私有属性名 = \" + 对象名.getXXX()); /** * 调用 set(object , value) 修改变量的值 * privateField 是获取到的私有变量 * 对象名 要操作的对象 * \"Modified\" 为要修改成的值 */ privateField.set(对象名, \"Modified\"); System.out.println(\"After Modify：私有属性名 = \" + testClass.getXXX()); 3、修改类的私有常量： 常量是指使用 final 修饰符修饰的成员属性，与变量的区别就在于有无 final 关键字修饰。Java 虚拟机（JVM）在编译 .java 文件得到 .class 文件时，会优化我们的代码以提升效率。其中一个优化就是：JVM 在编译阶段会把引用常量的代码替换成具体的常量值，如下所示。 1234567891011121314//编译前的 .java 文件：//注意是 String 类型的值private final String FINAL_VALUE = \"hello\";if(FINAL_VALUE.equals(\"world\"))&#123; //do something&#125;//编译后得到的 .class 文件（当然，编译后是没有注释的）：private final String FINAL_VALUE = \"hello\";//替换为\"hello\"if(\"hello\".equals(\"world\"))&#123; //do something&#125; 但是，并不是所有常量都会优化。经测试对于 int 、long 、boolean 以及 String 这些基本类型 JVM 会优化，而对于 Integer 、Long 、Boolean 这种包装类型，或者其他诸如 Date 、Object 类型则不会被优化。总结：对于基本类型的静态常量，JVM 在编译阶段会把引用此常量的代码替换成具体的常量值。 通过反射修改类的常量： 1234567891011121314151617//1. 获取 Class 类实例类名 对象名 = new 类名();Class c = 对象名.getClass();//2. 获取私有常量Field finalField = c.getDeclaredField(\"私有常量名\");//3. 修改常量的值if(finalField != null) &#123; //获取私有常量的访问权 finalField.setAccessible(true); //调用 finalField 的 getter 方法,输出 FINAL_VALUE 修改前的值 System.out.println(\"Before Modf: 私有常量名 = \" + finalField.get(对象名)); //修改私有常量 finalField.set(对象名, \"Modified\"); //调用 finalField 的 getter 方法,输出 FINAL_VALUE 修改后的值 System.out.println(\"After Modify：私有常量名 = \" + finalField.get(对象名)); //使用对象调用类的 getter 方法,获取值并输出 System.out.println(\"Actually ：私有常量名 = \" + testClass.getXXX); 结果是： 第一句打印修改前的值，没有异议； 第二句打印修改后常量的值，说明确实通过反射修改了； 第三句打印通过 getXXX() 方法获取的常量值，但还是初始值，导致修改无效！ 如果非要修改，类中在声明常量时不赋值，然后添加构造函数并为其赋值，即可修改。 参考博客： https://juejin.im/post/598ea9116fb9a03c335a99a4#heading-7 https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html","comments":true,"tags":[{"name":"Java反射","slug":"Java反射","permalink":"http://yoursite.com/tags/Java反射/"}]},{"title":"JUnit介绍","date":"2019-06-03T11:17:28.000Z","path":"2019/06/03/JUnit介绍/","text":"JUnit用到的设计模式介绍。 keep the bar green to keep the code clean. About1、JUnit最初由Erich Gamma 和Kent Beck所开发，是一个开源的java测试框架，它是Xuint测试体系架构的一种实现。在JUnit单元测试框架的设计时，设定了三个总体目标： 简化测试的编写，这种简化包括测试框架的学习和实际测试单元的编写； 使测试单元保持持久性； 可以利用既有的测试来编写相关的测试。 2、Junit的设计思想是通过从零开始来应用设计模式，然后一个接一个，直至获得最终合适的系统架构。 3、junit：判断程序执行的结果是否和我们所期待的结果一致。 ​ 测试之前是什么状态，测试之后就应该是什么状态，而不应该由于测试执行的原因导致状态发生了变化。 设计模式1、Template Method（模板方法）：需要复用的是算法的结构，也就是步骤，而步骤的实现可以在子类中完成。 问题：在实际的测试中，为了测试业务逻辑，必须构造一些参数或者一些资源，然后才可进行测试，最后必须释放这些系统资源。如测试数据库应用时，必须创建数据库连接Connection，然后执行数据库的操作，最后实现释放数据库的连接。 模式的选择：接下来要解决的问题是给开发者一个便捷的“地方”，用于放置他们的初始化代码，测试代码，和释放资源的代码，类似对象的构造函数，业务方法，析构函数一样。并且必须保证每次运行测试代码之前，都运行初始化代码，最后运行释放资源代码，并且每一个测试的结果都不会影响到其它的测试结果。这样就达到了代码的复用，提供了开发人员的效率。 Template Method（模板方法）比较好地涉及到我们的问题。摘引其意图，“定义一个操作中算法的骨架，并将一些步骤延迟到子类中。Template Method使得子类能够不改变一个算法的结构便可重新定义该算法的某些特定步骤。”这完全恰当。这样可以使测试者能够分别来考虑如何编写初始化和释放代码，以及如何编写测试代码。不管怎样，这种执行的次序对于所有测试都将保持相同，而不管初始化代码如何编写，或测试代码如何编写。 组成： 父类角色：提供模板（抽象类）； 子类角色：为模板提供实现。 在JUnit中的应用：Before()，Test()，After()。 123456789101112131415161718// JUnit在TestCase类中应用了模板方法模式。//具体的模板方法，定义出逻辑骨架public void runBare() throws Throwable &#123; Throwable exception = null; setUp(); try &#123; runTest(); &#125; catch (Throwable running) &#123; exception = running; &#125; finally &#123; try &#123; tearDown(); &#125; catch (Throwable tearingDown) &#123; if (exception == null) exception = tearingDown; &#125; &#125; if (exception != null) throw exception;&#125; 效果： 在各个测试用例中的公共的行为（初始化信息和释放资源等）被提取出来，可以避免代码的重复，简化了开发人员的工作； 在TestCase中实现一个算法的不变部分，并且将可变的行为留给子类来实现。增强了系统的灵活性。使JUnit框架仅负责算法的轮廓和骨架，而测试的开发人员则负责给出这个算法的各个逻辑步骤。 2、Command（命令）模式。 问题：JUnit是一个测试framework，测试人员只需开发测试用例。然后把这些测试用例组成请求(有时可能是一个或者多个)，发送到JUnitFrameWork，然后由JUnit执行测试，最后报告详细测试结果。其中包括执行的时间，错误方法，错误位置等。这样测试用例的开发人员就不需知道JUnit内部的细节，只要符合它定义的请求格式即可。从JUnit的角度考虑，它并不需要知道请求TestCase的操作信息，仅把它当作一种命令来执行，然后把执行测试结果发给测试人员。这样就使JUnit 框架和TestCase的开发人员独立开来，使得请求的一方不必知道接收请求一方的详细信息，更不必知道是怎样被接收，以及怎样被执行的，实现系统的松耦合。 模式的选择：Command（命令）模式能够比较好地满足需求。摘引其意图，将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求进行排队或记录请求日志…Command告诉我们可以为一个操作生成一个对象并给出它的一个execute（执行）方法。 在JUnit中的应用。 12345678910111213141516171819202122232425//为了实现Command模式，首先定义了一个接口Test,其中Run便是Command的Execute方法。public interface Test &#123; /** * Counts the number of test cases that will be run by this test. */ public abstract int countTestCases(); /** * Runs a test and collects its result in a TestResult instance. */ public abstract void run(TestResult result);&#125;//TestCase是该接口的抽象实现，它增加了一个测试名称，因为每一个TestCase在创建时都要有一个名称，因此若一个测试失败了，你便可识别出是哪个测试失败。public abstract class TestCase extends Assert implements Test &#123; /** * the name of the test case */ private String fName; /** * Runs the test case and collects the results in TestResult. */ public void run(TestResult result) &#123; result.run(this); &#125;&#125; 效果： Command模式将实现请求的一方（TestCase开发）和调用一方（JUnit Fromwork）进行解藕； Command模式使新的TestCase很容易的加入，无需改变已有的类，只需继承TestCase类即可，这样方便了测试人员； Command模式可以将多个TestCase进行组合成一个复合命令，实际你将看到TestSuit就是它的复合命令，当然它使用了Composite模式； Command模式容易把请求的TestCase组合成请求队列，这样使接收请求的一方（Junit Fromwork）,容易的决定是否执行请求，或者一旦发现测试用例失败或者错误可以立刻停止进行报告。 3、Composite（组合）。 问题：通过我们使用Command模式，JUnit能够方便的运行一个单独的测试案例之后产生测试结果。可是在实际的测试过程中，需要把多个测试用例进行组合成为一个复合的测试用例，当作一个请求发送给JUnit。这样JUnit就为面临一个问题，必须考虑测试请求的类型，是一个单一的TestCase还是一个复合的TestCase，甚至于要区分到底有多少个TestCase。怎样设计JUnit才可以实现不需要区分单个TestCase还是复合TestCase，把它们统一成相同的请求？ 模式的选择：当测试调用者不必关心其运行的是一个或多个测试案例的请求时，能够轻松地解决这个问题模式就是Composite（组合）模式。摘引其意图，将对象组合成树形结构以表示部分-整体的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。在这里部分-整体的层次结构是解决问题的关键，可以把单个的TestCase看作部分，而把复合的TestCase(TestSuit)看作整体。这样我们使用该模式便可以恰到好处得解决这个难题。 组成： Component：这是一个抽象角色，它给参加组合的对象规定一个接口。这个角色，给出共有的接口和默认的行为。其实就我们的Test接口，它定义出run方法； Composite：实现共有接口并维护一个测试的集合。就是我们的复合TestCase，TestSuit； Leaf：代表参加组合的对象，它没有下级子对象，仅定义出参加组合的原始对象的行为，其实就是单一的测试用例TestCase，它仅实现Test接口的方法。 在JUnit中的应用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//composite模式中的Component角色public interface Test &#123; public abstract int countTestCases(); public abstract void run(TestResult result);&#125;//composite模式中的Leaf角色public abstract class TestCase extends Assert implements Test &#123; /** * Runs the test case and collects the results in TestResult. */ public void run(TestResult result) &#123; result.run(this); &#125;&#125;/***下面，列出Composite源码。将其取名为TestSuit类。TestSuit有一个属性fTests (Vector类型)中保存了*其子测试用例（child test），提供addTest方法来实现增加子对象TestCase ,并且还提供testCount 和*tests等方法来操作子对象。最后通过run()方法实现对其子对象进行委托（delegate），最后还提供*addTestSuite方法实现递归，构造成树形。*/public class TestSuite implements Test &#123; private Vector&lt;Test&gt; fTests = new Vector&lt;Test&gt;(10); public void addTest(Test test) &#123; fTests.add(test); &#125; public int testCount() &#123; return fTests.size(); &#125; public Enumeration&lt;Test&gt; tests() &#123; return fTests.elements(); &#125; /** * Runs the tests and collects their result in a TestResult. */ public void run(TestResult result) &#123; for (Test each : fTests) &#123; if (result.shouldStop()) &#123; break; &#125; runTest(each, result); &#125; &#125; /** * Adds the tests from the given class to the suite */ public void addTestSuite(Class&lt;? extends TestCase&gt; testClass) &#123; addTest(new TestSuite(testClass)); &#125;&#125;/***所有上面的代码是对Test接口进行实现的。由于TestCase和TestSuit两者都符合Test接口，我们可以通过*addTestSuite递归地将TestSuite再组合成TestSuite，这样将构成树形结构。所有开发者都能够创建他们自*己的TestSuit。测试人员可创建一个组合了这些套件的TestSuit来运行它们所有的TestCase。*/ 效果： 简化了JUnit的代码JUnit可以统一处理组合结构TestSuite和单个对象TestCase。使JUnit开发变得简单容易，因为不需要区分部分和整体的区别，不需要写一些充斥着if else的选择语句； 定义了TestCase对象和TestSuite的类层次结构 基本对象TestCase可以被组合成更复杂的组合对象TestSuite，而这些组合对象又可以被组合，这样不断地递归下去。客户代码中，任何使用基本对象的地方都方便的使用组合对象，大大简化系统维护和开发； 使得更容易增加新的类型的TestCase。 4、dapter（适配器）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 问题：如果实现一个测试用例，就必须实现继承Testcase，然后实现run方法，实际是（testRun），然而这样我们就把所有的测试用例都实现相同类的不同方法，这样的结果就会造成产生大量的子类，使系统的测试维护相当困难，并且setUp和tearDown仅为这个testRun服务，其他的测试也必须完成相应的代码，从而增加了开发人员的工作量，怎样解决这个问题？ 为了避免类的急剧扩散，试想一个给定的测试用例类（testcase class）可以实现许多不同的方法，每一个方法都有一个描述性的名称，如testMoneyEquals或testMoneyAdd。这样测试案例并不符合简单的command接口。因此又带来另外一个问题就是，使所有测试方法从测试调用者的角度（JUnit框架）上看都是相同的。怎样解决这个问题？ 模式的选择：Adapter具有以下意图“将一个类的接口转换成客户希望的另外一个接口”。这听起来非常适合。把具有一定规则的描述性方法如testMoneyEquals，转化为JUnit框架所期望的Command（TestCase的run）从而方便框架执行测试。Adapter模式又分为类适配器和对象适配器。类适配器是静态的实现在这里不适合使用，于是使用了对象适配器。 组成： 目标抽象角色（Target）：定义客户要用的特定领域的接口； 适配器（Adapter）-中介：调用另一个接口，作为一个转换器； 适配器（Adaptee）：定义一个接口，Adapter需要接入； 客户端（Client）：协同对象符合Adapter适配器。 在JUnit中的应用：testXXX()。 1234567891011121314151617181920212223242526//junit在TestCase类中应用了适配器模式protected void runTest() throws Throwable &#123; assertNotNull(\"TestCase.fName cannot be null\", fName); // Some VMs crash when calling getMethod(null,null); Method runMethod = null; try &#123; // use getMethod to get all public inherited // methods. getDeclaredMethods returns all // methods of this class but excludes the // inherited ones. runMethod = getClass().getMethod(fName, (Class[]) null); &#125; catch (NoSuchMethodException e) &#123; fail(\"Method \\\"\" + fName + \"\\\" not found\"); &#125; if (!Modifier.isPublic(runMethod.getModifiers())) &#123; fail(\"Method \\\"\" + fName + \"\\\" should be public\"); &#125; try &#123; runMethod.invoke(this); &#125; catch (InvocationTargetException e) &#123; e.fillInStackTrace(); throw e.getTargetException(); &#125; catch (IllegalAccessException e) &#123; e.fillInStackTrace(); throw e; &#125;&#125; 在runBare方法中，通过runTest方法将我们自己编写的testXXX方法进行了适配，使得junit可以执行我们自己编写的Test Case。 在runTest方法中，首先获得我们自己编写的testXXX方法所对应的Method对象（不带参数），然后检查该Method所对应的方法是否是Public的，如果是则调用Method对象的invoke方法来去执行我们自己编写的testXXX方法。 效果： 使用Adapter模式简化测试用例的开发，通过按照方法命名的规范来开发测试，不需要进行大量的类继承，提高代码的复用，减轻测试人员的工作量； 使用Adapter可以重新定义Adaptee的部分行为，如增强异常处理等。 参考博客：http://www.voidcn.com/article/p-uxchkbof-ez.html","comments":true,"tags":[{"name":"Java单元测试框架","slug":"Java单元测试框架","permalink":"http://yoursite.com/tags/Java单元测试框架/"}]},{"title":"排序算法（二）","date":"2019-06-02T10:48:51.000Z","path":"2019/06/02/SortAlgorithm/","text":"排序算法（快速排序、希尔排序、堆排序、归并排序）的Java实现。 快速排序About快速排序是一种交换排序 。 思想通过一趟排序将要排序的数据分割成独立的两部分：分割点左边都是比它小的数，右边都是比它大的数。 然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 动态效果 Java实现123456789101112131415161718192021222324252627282930313233343536import java.util.Arrays;public class QuickSort &#123; public static void sort(int[] arr, int left, int right) &#123; if(left &gt; right) &#123; return; &#125; else &#123; int base = divide(arr, left, right); sort(arr, left, base - 1); sort(arr, base + 1, right); &#125; &#125; public static int divide(int[] arr, int left, int right) &#123;//重新找基准数 int base = arr[left]; //以最左边的数（left）为基准 while (left &lt; right) &#123; while (left &lt; right &amp;&amp; arr[right] &gt;= base) &#123;// 从数组右端开始，向左遍历，直到找到小于base的数 right--; &#125; arr[left] = arr[right];// 找到了比base小的元素，将这个元素放到最左边的位置 while (left &lt; right &amp;&amp; arr[left] &lt;= base) &#123;// 从数组左端开始，向右遍历，直到找到大于base的数 left++; &#125; arr[right] = arr[left];// 找到了比base大的元素，将这个元素放到最右边的位置 &#125; // 最后将base放到left位置。此时，left位置的左侧数值应该都比left小,而left位置的右侧数值应该都比left大。 arr[left] = base; return left; &#125; public static void main(String[] args) &#123; int[] n = &#123;6, 4, 8, 9, 2, 3, 1&#125;; QuickSort.sort(n, 0, 6); System.out.println(Arrays.toString(n)); &#125;&#125; 算法分析 希尔排序About希尔(Shell)排序又称为缩小增量排序，它是一种插入排序。它是直接插入排序算法的一种威力加强版。 思想步长的选择是希尔排序的重要部分。算法最开始以一定的步长进行排序，然后会继续以更小的步长进行排序，最终算法以步长为 1 进行排序。当步长为 1 时，算法变为直接插入排序，这就保证了数据一定会被全部排序。 图示效果 Java实现12345678910111213141516171819202122232425import java.util.Arrays;public class ShellSort &#123; public static void sort(int[] arr) &#123; int increment = arr.length / 2; while (increment &gt; 0) &#123; for(int i = increment; i &lt; arr.length; i++) &#123; int j = i - increment; int temp = arr[i]; while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) &#123; arr[j + increment] = arr[j]; j -= increment; &#125; arr[j + increment] = temp; &#125; increment /= 2; &#125; &#125; public static void main(String[] args) &#123; int[] n = &#123;50, 123, 543, 187, 49, 30, 0, 2, 11, 100&#125;; sort(n); System.out.println(Arrays.toString(n)); &#125;&#125; 算法分析 堆排序About堆排序是一种选择排序。 思想堆是一种特殊的树形数据结构，其每个节点都有一个值，通常提到的堆都是指一颗完全二叉树，根结点的值小于（或大于）两个子节点的值，同时，根节点的两个子树也分别是一个堆。 堆排序是利用堆的性质进行的一种选择排序。 图示效果构建初始堆：构造了初始堆后，堆排序处理： Java实现123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Arrays;public class HeadSort &#123; public static void buildHeap(int[] arr, int parent, int length) &#123; for(int child = 2 * parent + 1; child &lt; length; child = 2 * child + 1) &#123; if(child + 1 &lt; length &amp;&amp; arr[child] &lt; arr[child + 1]) &#123;// 让child先指向子节点中最大的节点 child++; &#125; if(arr[parent] &lt; arr[child]) &#123;// 如果发现子节点更大，则进行值的交换 swap(arr, parent, child); // 下面就是非常关键的一步了 // 如果子节点更换了，那么，以子节点为根的子树会不会受到影响呢？ // 所以，循环对子节点所在的树继续进行判断 parent = child; &#125; else &#123; break; &#125; &#125; &#125; public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; public static void sort(int[] arr)&#123; for(int parent = arr.length / 2 - 1; parent &gt;= 0; parent--) &#123;//构建最大堆 buildHeap(arr, parent, arr.length); &#125; for(int i = arr.length - 1; i &gt; 0; i--) &#123;//把最大的元素扔在最后面 swap(arr, 0, i); buildHeap(arr, 0, i);//将arr中前i - 1个记录重新调整为最大堆 &#125; &#125; public static void main(String[] args) &#123; int a[] = &#123;6, 4, 8, 9, 2, 3, 1&#125;; sort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 算法分析 归并排序About归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 思想该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 图示效果 分阶段： 治阶段： Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Arrays;public class MergeSort &#123; public static void sort(int[] arr, int low, int high) &#123; int mid = (low + high) / 2; if(low &lt; high) &#123; sort(arr, low, mid);//左 sort(arr, mid + 1, high);//右 merge(arr, low, mid, high);//左右归并 &#125; &#125; public static void merge(int[] arr, int low, int mid, int high) &#123; int[] temp = new int[high - low + 1]; int i = low;//左指针 int j = mid + 1;//右指针 int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= high) &#123;// 把较小的数先移到新数组中 if(arr[i] &lt; arr[j]) &#123; temp[k++] = arr[i++]; &#125; else &#123; temp[k++] = arr[j++]; &#125; &#125; // 把左边剩余的数移入数组 while (i &lt;= mid) &#123; temp[k++] = arr[i++]; &#125; // 把右边剩余的数移入数组 while (j &lt;= high) &#123; temp[k++] = arr[j++]; &#125; // 新数组中的数覆盖arr数组 k = 0; while (low &lt;= high) &#123; arr[low++] = temp[k++]; &#125; &#125; public static void main(String[] args) &#123; int arr[] = &#123;6, 4, 8, 9, 2, 3, 1&#125;; sort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); &#125;&#125; 算法分析 参考博客： https://cuijiahua.com/blog/2018/01/alogrithm_9.html https://blog.csdn.net/jianyuerensheng/article/category/6203559","comments":true,"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://yoursite.com/tags/排序算法/"}]},{"title":"排序算法（一）","date":"2019-05-31T06:27:07.000Z","path":"2019/05/31/排序算法/","text":"排序算法（冒泡排序、直接插入排序、选择排序）的Java实现。 排序分类 算法分析 冒泡排序About冒泡排序是一种交换排序，两两比较待排序的关键字，并交换不满足次序要求的那对数，直到整个数组都满足次序要求为止。 思想它重复地走访要排序的数组，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数组的工作是重复地进行直到没有再需要交换，也就是说该数组已经排序完成。 这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数组的顶端，故名冒泡排序。 动态效果 Java实现12345678910111213141516171819202122232425import java.util.Arrays;public class bubbleSort &#123; //大的往后调 public static void sort(int[] num) &#123; if(num == null || num.length == 0) &#123; return; &#125; for(int i = 0; i &lt; num.length - 1; i++) &#123; for(int j = 0; j &lt; num.length - i - 1; j++) &#123; if(num[j] &gt; num[j + 1]) &#123; int temp = num[j]; num[j] = num[j + 1]; num[j + 1] = temp; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] n = &#123;6, 4, 8, 9, 2, 3, 1&#125;; bubbleSort.sort(n); System.out.println(Arrays.toString(n)); &#125;&#125; 优化当冒泡中途发现已经为正序了，便无需继续比对下去。 改进：12345678910111213141516171819202122232425262728293031import java.util.Arrays;public class bubbleSortOptimize &#123; //对冒泡排序常见的改进方法是加入标志性变量，用于标志某一趟排序过程中是否有数据交换。 public static void sort(int[] num) &#123; if(num == null || num.length == 0) &#123; return; &#125; boolean flag; for(int i = 0; i &lt; num.length; i++) &#123; flag = false; for(int j = 0; j &lt; num.length - 1 - i; j++) &#123; if(num[j] &gt; num[j + 1]) &#123; int temp = num[j]; num[j] = num[j + 1]; num[j + 1] = temp; flag = true; &#125; &#125; if(flag == false) &#123; break; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] n = &#123;6, 4, 8, 9, 2, 3, 1&#125;; bubbleSortOptimize.sort(n); System.out.println(Arrays.toString(n)); &#125;&#125; 算法分析 直接插入排序About直接插入排序（Insertion Sort）是一种最简单的插入排序。 思想每一趟将一个待排序的记录，按照其关键字的大小插入到有序队列的合适位置里，直到全部插入完成。 动态效果 Java实现123456789101112131415161718192021222324import java.util.Arrays;public class InsertSort &#123; public static void sort(int[] arr) &#123; //第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列 for(int i = 1; i &lt; arr.length; i++) &#123; //取出第i个数，和前i-1个数比较，插入合适位置 int temp = arr[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) &#123;//如果要插入的数小于第j个数，将第j个数后移 arr[j + 1] = arr[j]; j--; &#125; arr[j + 1] = temp; &#125; &#125; public static void main(String[] args) &#123; int[] n = &#123;6, 4, 8, 9, 2, 3, 1&#125;; InsertSort.sort(n); System.out.println(Arrays.toString(n)); &#125;&#125; 注意：此处第二个循环不可替换为for循环，否则会出现逻辑❌。如果替换为for循环，变量变化得写在大括号里。 算法分析 选择排序About每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列头部，直到全部排序结束为止。 思想 从待排序序列中，找到关键字最小的元素； 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换； 从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。 动态效果 Java实现12345678910111213141516171819202122import java.util.Arrays;public class SelectSort &#123; //每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列头部，直到全部排序结束为止。 public static void sort(int[] arr) &#123; for(int i = 0; i &lt; arr.length - 1; i++) &#123; for(int j = i + 1; j &lt; arr.length; j++) &#123; if(arr[i] &gt; arr[j]) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] n = &#123;6, 4, 8, 9, 2, 3, 1&#125;; SelectSort.sort(n); System.out.println(Arrays.toString(n)); &#125;&#125; 算法分析 参考博客：https://cuijiahua.com/blog/2018/01/alogrithm_9.html","comments":true,"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://yoursite.com/tags/排序算法/"}]},{"title":"测试基础理论（二）","date":"2019-04-27T09:42:02.000Z","path":"2019/04/27/软件测试实例/","text":"软件测试实例分析 1、给你一个字符串，你怎么判断是不是ip地址？ ​ IP的格式：(1~255).(0~255).(0~255).(0~255) 123456789101112131415161718192021222324public class IpLegal &#123; //正则表达式 public static boolean isIpLegal(String ipStr) &#123; String ipRegEx = \"^([1-9]|([1-9][0-9])|(1[0-9][0-9])|(2[0-4][0-9])|(25[0-5]))\" + \"(\\\\.([0-9]|([1-9][0-9])|(1[0-9][0-9])|(2[0-4][0-9])|(25[0-5])))&#123;3&#125;$\"; Pattern pattern = Pattern.compile(ipRegEx); Matcher matcher = pattern.matcher(ipStr); if (matcher.matches()) &#123; return true; &#125; else &#123; return false; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); String ipStr = scanner.next(); boolean ipLegal = isIpLegal(ipStr); if(ipLegal) &#123; System.out.println(ipStr + \"合法\"); &#125; else &#123; System.out.println(ipStr + \"非法\"); &#125; &#125;&#125; 2、进行测试用例设计：一串数字，闰年的判别？ 判断闰年的标准是:能整除4且不能整除100，能整除400。设定合法的年份为1-9999 1234567891011121314public class LeapYear &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int year = in.nextInt(); if(year &lt;= 0 &amp;&amp; year &gt; 9999) &#123; System.out.println(\"请输入正确的年份\"); &#125; if((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0) &#123; System.out.println(\"闰年\"); &#125; else &#123; System.out.println(\"不是闰年\"); &#125; &#125;&#125; 测试用例： 3、请说一说简单用户界面登录过程都需要做哪些分析？ 4、对朋友圈点赞功能进行测试？ 是否可以正常点赞和取消； 点赞的人是否在可见分组里； 点赞状态是否能即时更新显示； 点赞状态，共同好友是否可见； 性能检测，网速快慢对其影响； 点赞显示的是否正确，一行几个； 点赞是否按时间进行排序，头像对应的是否正确； 是否能在消息列表中显示点赞人的昵称； 不同手机，系统显示界面如何； 可扩展性测试，点赞后是否能发表评论； 是否在未登录时可查看被点赞的信息。 5、如果做一个杯子的检测，如何测试？ 6、如何对一个页面进行测试？ UI测试：页面布局、页面样式检查、控件长度是否够长；显示时，是否会被截断；支持的快捷键，Tab键切换焦点顺序正确性等； 功能测试：页面上各类控件的测试范围，测试点。结合控件的实际作用来补充检查点： 比如， 密码框是否*显示， 输入是否做trim处理等； 安全测试：输入特殊字符，sql注入，脚本注入测试。后台验证测试，对于较重要的表单 ，绕过js检验后台是否验证；数据传输是否加密处理，比如， 直接请求转发，地址栏直接显示发送字符串； 兼容性测试； 性能测试。 7、 如何对淘宝搜索框进行测试？ 8、如何对一瓶矿泉水进行测试？ 界面测试:查看外观是否美观； 功能：查看水瓶漏不漏；瓶中水能不能被喝到； 安全性：瓶子的材质有没有毒或细菌； 可靠性：从不同高度落下的损坏程度； 可移植性：再不同的地方、温度等环境下是否都可以正常使用； 兼容性：是否能够容纳果汁、白水、酒精、汽油等； 易用性：是否烫手、是否有防滑措施、是否方便饮用； 用户文档：使用手册是否对的用法、限制、使用条件等有详细描述； 疲劳测试：将盛上水（案例一）放24小时检查泄漏时间和情况；盛上汽油（案例二）放24小时检查泄漏时间和情况等； 压力测试：用根针并在针上面不断加重量，看压强多大时会穿透； 跌落测试:测试在何种高度跌落会破坏水瓶。 9、请说一下购物车的测试用例？ 10、请问web测试如何写的？ 功能测试，主要做链接测试，表单测试，cookies测试，设计语言测试等； 性能测试，考虑连接速度测试，以及负载测试，例如：Web应用系统能允许多少个用户同时在线？如果超过了这个数量，会出现什么现象？Web应用系统能否处理大量用户对同一个页面的请求？还有压力测试； 可用性测试，比如导航测试，图形测试，内容测试，整体界面测试等； 兼容性测试，市场上有很多不同的操作系统类型，最常见的有Windows、Unix、Macintosh、Linux等。Web应用系统的最终用户究竟使用哪一种操作系统，取决于用户系统的配置。这样，就可能会发生兼容性问题，同一个应用可能在某些操作系统下能正常运行，但在另外的操作系统下可能会运行失败。因此，在Web系统发布之前，需要在各种操作系统下对Web系统进行兼容性测试； 安全性测试； 11、如何测试手机开机键？ 功能测试：按下开机键，屏幕能否亮起； 性能测试：按下开机键，屏幕能否在规定时间内亮起； 压力测试：连续多次按下开机键，观察屏幕是否能一直亮起，到多久时间失灵； 健壮性测试：给定一个中了病毒的手机或者是淘汰许久的老机子，安歇开机键观察屏幕能否亮起； 可靠性测试：连续按下开机键有限次数，比如1万次，记录屏幕未亮起的次数； 可用性测试：开机键按下费不费力，开机键的形状设计是否贴合手指，开机键的位置设计是否方便。 12、接口测试出现bug的原因有哪些？ 特殊值处理不当导致程序异常退出或者崩溃； 类型边界溢出，导致数据独处和写入不一致； 取值边界外未返回正确的错误信息； 权限未处理，可以访问其他用户的信息； 逻辑校验不完善，可以利用漏洞获取非正当利益； 状态处理不当，导致逻辑出现错误； 数组类型item个数为0或者item重复时程序异常退出。 13、请你设计一个微信朋友圈点赞的测试用例？ 功能测试：点赞某条朋友圈，验证是否成功； 接口测试：点赞朋友圈，验证朋友能否收到提示信息； 性能测试：点赞朋友圈，是否在规定时间显示结果，是否在规定时间在朋友手机上进行提示； 兼容性测试：在不同的终端比如ipad,手机上点赞朋友圈，验证是否成功。","comments":true,"tags":[{"name":"测试基础知识","slug":"测试基础知识","permalink":"http://yoursite.com/tags/测试基础知识/"}]},{"title":"测试基础理论（一）","date":"2019-04-26T02:20:40.000Z","path":"2019/04/26/测试基础理论/","text":"软件测试基础知识 1、单元测试、集成测试、系统测试、回归测试、验收测试介绍： 单元测试：完成最小的软件设计单元（模块）的验证工作，目标是确保模块被正确的编码，使用过程设计描述作为指南，对重要的控制路径进行测试以发现模块内的错误，通常情况下是白盒的，对代码风格和规则、程序设计和结构、业务逻辑等进行静态测试，及早的发现和解决不易显现的错误。 集成测试：通过测试发现与模块接口有关的问题。目标是把通过了单元测试的模块拿来，构造一个在设计中所描述的程序结构，应当避免一次性的集成（除非软件规模很小），而采用增量集成。 自顶向下集成：模块集成的顺序是首先集成主模块，然后按照控制层次结构向下进行集成，隶属于主模块的模块按照深度优先或广度优先的方式集成到整个结构中去。 自底向上集成：从原子模块开始来进行构造和测试，因为模块是自底向上集成的，进行时要求所有隶属于某个给顶层次的模块总是存在的，也不再有使用稳定测试桩的必要。 系统测试：是基于系统整体需求说明书的黑盒类测试，应覆盖系统所有联合的部件。系统测试是针对整个产品系统进行的测试，目的是验证系统是否满足了需求规格的定义，找出与需求规格不相符合或与之矛盾的地方。系统测试的对象不仅仅包括需要测试的产品系统的软件，还要包含软件所依赖的硬件、外设甚至包括某些数据、某些支持软件及其接口等。因此，必须将系统中的软件与各种依赖的资源结合起来，在系统实际运行环境下来进行测试。 回归测试：回归测试是指在发生修改之后重新测试先前的测试用例以保证修改的正确性。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。根据修复好了的缺陷再重新进行测试。回归测试的目的在于验证以前出现过但已经修复好的缺陷不再重新出现。一般指对某已知修正的缺陷再次围绕它原来出现时的步骤重新测试。 验收测试：验收测试是指系统开发生命周期方法论的一个阶段，这时相关的用户或独立测试人员根据测试计划和结果对系统进行测试和接收。它让系统用户决定是否接收系统。它是一项确定产品是否能够满足合同或用户所规定需求的测试。验收测试包括Alpha测试和Beta测试。 Alpha测试：是由用户在开发者的场所来进行的，在一个受控的环境中进行。 Beta测试：由软件的最终用户在一个或多个用户场所来进行的，开发者通常不在现场，用户记录测试中遇到的问题并报告给开发者，开发者对系统进行最后的修改，并开始准备发布最终的软件。 2、单元测试、集成测试、系统测试、验收测试、回归测试这几步中最重要的是哪一步？ ​ 这些测试步骤分别在软件开发的不同阶段对软件进行测试，对软件完整功能进行测试的系统测试很重要，因为此时单元测试和集成测试已完成，能够对软件所有功能进行功能测试，能够覆盖系统所有联合的部件，是针对整个产品系统进行的测试，能够验证系统是否满足了需求规格的定义，因此系统测试很重要。 3、集成测试和系统测试的区别，以及它们的应用场景主要是什么？ 区别： 计划和用例编制的先后顺序：从V模型来讲，在需求阶段就要制定系统测试计划和用例，HLD的时候做集成测试计划和用例，有些公司的具体实践不一样，但是顺序肯定是先做系统测试计划用例，再做集成。 用例的粒度：系统测试用例相对很接近用户接受测试用例，集成测试用例比系统测试用例更详细，而且对于接口部分要重点写，毕竟要集成各个模块或者子系统。 执行测试的顺序：先执行集成测试，待集成测试出的问题修复之后，再做系统测试。 应用场景： 集成测试：完成单元测试后，各模块联调测试；集中在各模块的接口是否一致、各模块间的数据流和控制流是否按照设计实现其功能、以及结果的正确性验证等等；可以是整个产品的集成测试，也可以是大模块的集成测试；集成测试主要是针对程序内部结构进行测试，特别是对程序之间的接口进行测试。集成测试对测试人员的编写脚本能力要求比较高。测试方法一般选用黑盒测试和白盒测试相结合。 系统测试：针对整个产品的全面测试，既包含各模块的验证性测试（验证前两个阶段测试的正确性）和功能性（产品提交个用户的功能）测试，又包括对整个产品的健壮性、安全性、可维护性及各种性能参数的测试。系统测试测试软件《需求规格说明书》中提到的功能是否有遗漏，是否正确的实现。做系统测试要严格按照《需求规格说明书》，以它为标准。测试方法一般都使用黑盒测试法。 4、黑盒测试与白盒测试： 黑盒测试也称功能测试或数据驱动测试，是在已知产品所应具有的功能，通过测试来检测每个功能是否都能正常使用，在测试时，把程序看作一个不能打开的黑盆子，在完全不考虑程序内部结构和内部特性的情况下，测试者在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数锯而产生正确的输出信息，并且保持外部信息（如数据库或文件）的完整性。 “黑盒”法着眼于程序外部结构、不考虑内部逻辑结构、针对软件界面和软件功能进行测试； “黑盒”法是穷举输入测试，只有把所有可能的输入都作为测试情况使用，才能以这种方法查出程序中所有的错误； 实际上测试情况有无穷多个，因此不仅要测试所有合法的输入，而且还要对那些不合法但是可能的输入进行测试。 白盒测试也称为结构测试或逻辑驱动测试，根据程序的控制结构设计测试用例，主要用于软件或程序验证。白盒测试法检查程序内部逻辑结构，对所有的逻辑路径进行测试，是一种穷举路径的测试方法，但即使每条路径都测试过了，但仍然有可能存在错误：穷举路径测试无法检查出程序本身是否违反了设计规范、穷举路径测试不可能检查出程序因为遗漏路径而出错、穷举路径测试不可能检查出程序因为遗漏路径而出错。 5、手动测试与自动化测试： 手工测试 ： 优点：测试人员具有经验和对错误的猜测能力、测试人员具有审美能力和心理体验、测试人员具有是非判断和逻辑推理能力。 缺点：重复的手工回归测试，代价昂贵、容易出错；依赖于软件测试人员的能力。 自动化测试： 优点：对程序的回归测试更方便、可以运行更多更繁琐的测试、可以执行一些手工测试困难或不可能进行的测试、更好地利用资源、测试具有一致性和可重复性。 缺点：不能取代手工测试、手工测试比自动测试发现的缺陷更多、对测试质量的依赖性极大、测试自动化不能提高有效性、工具本身并无想像力。 6、测试和开发需要怎么结合才能使软件的质量得到更好的保障？ ​ 测试和开发应该按照W模型的方式进行结合，测试和开发同步进行，能够尽早发现软件缺陷，降低软件开发的成本。W模型强调：测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、设计等同样要测试，也就是说，测试与开发是同步进行的。W模型有利于尽早地全面的发现问题。例如，需求分析完成后，测试人员就应该参与到对需求的验证和确认活动中，以尽早地找出缺陷所在。同时，对需求的测试也有利于及时了解项目难度和测试风险，及早制定应对措施，这将显著减少总体测试时间，加快项目进度。 7、测试的相关流程：需求测试-&gt;概要设计测试-&gt;详细设计测试-&gt;单元测试-&gt;集成测试-&gt;系统测试-&gt;验收测试。 8、如何写测试用例？ 测试人员尽早介入，彻底理解清楚需求，这个是写好测试用例的基础； 清楚输入、输出的各种可能性，以及各种输入的之间的关联关系，理解清楚需求的执行逻辑，通过等价类、边界值、判定表等方法找出大部分用例； 找到需求相关的一些特性，补充测试用例； 根据自己的经验分析遗漏的测试场景； 多总结类似功能点的测试点，才能够写出质量越来越高的测试用例。 9、测试项目具体工作是什么？ 搭建测试环境 撰写测试用例 执行测试用例 写测试计划，测试报告 测试，并提交BUG表单 跟踪bug修改情况 执行自动化测试，编写脚本，执行，分析，报告 进行性能测试，压力测试等其他测试，执行，分析，调优，报告 10、如果想进行bug的测评，怎么去评测bug？ Bug的priority（）和severity（）是两个重要属性，通常人员在提交bug的时候，只定义severity，而将priority交给leader定义，通常bug管理中，severity分为四个等级blocker、critical、major、minor/trivial，而priority分为五个等级immediate、urgent、high、normal、low。 Severity： blocker：即系统无法执行，崩溃，或严重资源不足，应用模块无法启动或异常退出，无法测试，造成系统不稳定。常见的有严重花屏、内存泄漏、用户数据丢失或破坏、系统崩溃/死机/冻结、模块无法启动或异常退出、严重的数值计算错误、功能设计与需求严重不符、其它导致无法测试的错误， 如服务器500错误。 critical：即映像系统功能或操作，主要功能存在严重缺陷，但不会映像到系统稳定性。常见的有：功能未实现，功能错误、系统刷新错误、数据通讯错误、轻微的数值计算错误、影响功能及界面的错误字或拼写错误。 major：即界面、性能缺陷、兼容性，常见的有：操作界面错误，边界条件错误，提示信息错误，长时间操作无进度提示，系统未优化，兼容性问题。 minor/trivial：即易用性及建议性问题。 Priority immediate：即马上解决 urgent：急需解决 high：高度重视，有时间要马上解决 normal：正常处理” low：在系统发布前解决，或确认可以不用解决 11、app性能测试的指标？ 内存：内存消耗测试节点的设计目标是为了让应用不占用过多的系统资源，且及时释放内存，保障整个系统的稳定性。当然关于内存测试，在这里我们需要引入几个概念：空闲状态、中等规格、满规格。空闲状态指打开应用后，点击home键让应用后台运行，此时应用处于的状态叫做空闲；中等规格和满规格指的是对应用的操作时间的间隔长短不一，中等规格时间较长，满规格时间较短。 CPU： 使用Android提供的view plaincopy在CODE上查看代码片派生到我的代码片 adbshell dumpsys CPUinfo |grep packagename &gt;/address/CPU.txt来获取； 使用top命令view plaincopy在CODE上查看代码片派生到我的代码片 adbshell top |grep packagename&gt;/address/CPU.txt来获取。 流量： 网络流量测试是针对大部分应用而言的，可能还有部分应用会关注网速、弱网之类的测试。 流量测试包括以下测试项：应用首次启动流量提示、应用后台连续运行2小时的流量值、应用高负荷运行的流量峰值。 电量： 测试手机安装目标APK前后待机功耗无明显差异； 常见使用场景中能够正常进入待机，待机电流在正常范围内； 长时间连续使用应用无异常耗电现象。 启动速度： 第一类：首次启动–应用首次启动所花费的时间； 第二类：非首次启动–应用非首次启动所花费的时间； 第三类：应用界面切换–应用界面内切换所花费的时间。 滑动速度、界面切换速度 与服务器交互的网络速度 12、bug的周期，以及描述一下不同类别的bug？ New:（新的） 当某个“bug”被第一次发现的时候，测试人员需要与项目负责人沟通以确认发现的的确是一个bug，如果被确认是一个bug，就将其记录下来，并将bug的状态设为New Assigned（已指派的） 当一个bug被指认为New之后，将其反馈给开发人员，开发人员将确认这是否是一个bug，如果是，开发组的负责人就将这个bug指定给某位开发人员处理，并将bug的状态设定为“Assigned” Open（打开的） 一旦开发人员开始处理bug的时候，他（她）就将这个bug的状态设置为“Open”，这表示开发人员正在处理这个“bug” Fixed（已修复的） 当开发人员进行处理（并认为已经解决）之后，他就可以将这个bug的状态设置为“Fixed”并将其提交给开发组的负责人，然后开发组的负责人将这个bug返还给测试组 Pending Reset（待在测试的） 当bug被返还到测试组后，我们将bug的状态设置为Pending Reset” Reset(再测试) 测试组的负责人将bug指定给某位测试人员进行再测试，并将bug的状态设置为“Reset” Closed（已关闭的） 如果测试人员经过再次测试之后确认bug 已经被解决之后，就将bug的状态设置为“Closed” Reopen（再次打开的） 如果经过再次测试发现bug（指bug本身而不是包括因修复而引发的新bug）仍然存在的话，测试人员将bug再次传递给开发组，并将bug的状态设置为“Reopen” Pending Reject（拒绝中） 如果测试人员传递到开发组的bug被开发人员认为是正常行为而不是bug时，这种情况下开发人员可以拒绝，并将bug的状态设置为“Pending Reject” Rejected(被拒绝的) 测试组的负责人接到上述bug的时候，如果他（她）发现这是产品说明书中定义的正常行为或者经过与开发人员的讨论之后认为这并不能算作bug的时候，开发组负责人就将这个bug的状态设置为“Rejected” Postponed（延期） 有些时候，对于一些特殊的bug的测试需要搁置一段时间，事实上有很多原因可能导致这种情况的发生，比如无效的测试数据，一些特殊的无效的功能等等，在这种情况下，bug的状态就被设置为“Postponed“ Bug类型：代码错误、界面优化、设计缺陷、配置相关、安装部署、安全相关、性能问题、标准规范、测试脚本和其他。 13、web测试和app测试的不同点？ 系统架构方面：web项目，一般都是b/s架构，基于浏览器的 app项目，则是c/s的，必须要有客户端，用户需要安装客户端。 web测试只要更新了服务器端，客户端就会同步会更新。App项目则需要客户端和服务器都更新。 性能方面: web页面主要会关注响应时间 而app则还需要关心流量、电量、CPU、GPU、Memory这些。 它们服务端的性能没区别，都是一台服务器。 兼容方面： web是基于浏览器的，所以更倾向于浏览器和电脑硬件，电脑系统的方向的兼容 app测试则要看分辨率，屏幕尺寸，还要看设备系统。 web测试是基于浏览器的所以不必考虑安装卸载。 而app是客户端的，则必须测试安装、更新、卸载。除了常规的安装、更新、卸载还要考虑到异常场景。包括安装时的中断、弱网、安装后删除安装文件 。 此外APP还有一些专项测试：如网络、适配性。 14、自动化测试框架？ 模块化测试框架：在一个组件上方建立一个抽象层使其在余下的应用中隐藏起来，这是众所周知的编程技巧。这样应用同组件中的修改隔离开来，提供了程序设计的模块化特性。模块化测试脚本框架使用这一抽象或者封装的原理来提高自动测试组合的可维护性和可升级性。 测试库框架：测试库框架把待测应用程序分解为过程和函数而不是脚本。这个框架需要创建描述模块、片断以及待测应用程序的功能库文件。 关键字驱动或表驱动的测试框架：在一个关键字驱动测试中，把待测应用程序的功能和每个测试的执行步骤一起写到一个表中。这个测试框架可以通过很少的代码来产生大量的测试用例。同样的代码在用数据表来产生各个测试用例的同时被复用。 数据驱动测试框架：测试的输入和输出数据是从数据文件中读取（数据池，ODBC源，CSV文件，EXCEL文件，ADO对象等）并且通过捕获工具生成或者手工生成的代码脚本被载入到变量中。在数据驱动测试中，数据文件中只包含测试数据。这个框架意图减少需要执行所有测试用例所需要的总的测试脚本数。数据驱动需要很少的代码来产生大量的测试用例，这与表驱动极其类似。 混合测试自动化（Hybrid Test Automation）框架：最普遍的执行框架是上面介绍的所有技术的一个结合，取其长处，弥补其不足。 15、黑盒测试和白盒测试有哪些方法？ 黑盒测试方法有等价类划分，边界值分析，错误推测，因果图法 白盒测试方法有逻辑覆盖法，程序插桩技术，基本路径法，符号测试，错误驱动测试 16、怎么看待测试，知道哪些测试的类型？ 测试是软件开发中不可或缺的一环，测试通过经济，高效的方法，捕捉软件中的错误，从而达到保重软件内在质量的目的。测试分为功能测试和非功能测试，非功能测试又可以分为性能测试、压力测试、容量测试、健壮性测试、安全性测试、可靠性测试、恢复性测试、备份测试、协议测试、兼容性测试、可用性测试、配置测试、GUI测试。","comments":true,"tags":[{"name":"测试基础知识","slug":"测试基础知识","permalink":"http://yoursite.com/tags/测试基础知识/"}]},{"title":"计算机网络总结","date":"2019-04-19T08:26:10.000Z","path":"2019/04/19/计算机网络总结/","text":"计算机网络基础总结 计算机网络体系结构 1、五层协议： 应用层（用户对用户） 任务：提供系统与用户的接口功能：文件传输、访问和管理、电子邮件服务协议：FTP、SMTP、POP3、HTTP、DNS 传输层（应用对应用、进程对进程） 传输单位：报文段（TCP）或用户数据报（UDP）任务：负责主机中两个进程之间的通信功能：为端到端连接提供可靠的传输服务；为端到端连接提供流量控制、差错控制、服务质量等管理服务协议：TCP、UDP 网络层（主机对主机） 传输单位：数据报所实现的硬件：路由器任务：将传输层传下来的报文段封装成分组；选择适当的路由，使传输层传下来的分组能够交付到目的主机协议：ICMP、ARP、RARP、IP、IGMP 数据链路层 传输单位 ：帧所实现的硬件：交换机、网桥任务：将网络层交下来的IP数据报组装成帧功能：链路连接的建立拆除、分离；帧定界和帧同步；差错检测 物理层 传输单位：比特所实现的硬件：集线器、中继器任务：透明地传输比特流功能：为数据端设备提供传送数据通路 2、OSI： 表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题； 会话层 ：建立及管理会话； 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理； 3、TCP/IP： 将五层协议中数据链路层和物理层合并为网络接口层； TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层； 物理层1、物理层的作用：实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异； 2、透明传送比特流：表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的； 3、数据传输方式： 电路交换：通信之前要在通信双方之间建立一条被双方独占的物理通路； 报文交换：采用存储转发的传输方式； 分组交换：采用存储转发的传输方式，可能出现失序、丢失或重复分组现象； 数据链路层1、数据链路层（链路层）：两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧； 2、数据链路层：封装成帧、透明传输、差错检测； 2、封装成帧：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束； 3、透明传输：当两个主机互相传送信息时，网络层的分组必须封装成帧，并以帧的格式进行传送； 帧定界：将一段数据的前后分别添加首部和尾部，就构成了帧，首部和尾部中含有很多控制信息，这些信息的重要作用之一是确定帧的界限； 4、差错检测：目前数据链路层广泛使用循环冗余检验（CRC）来检查比特差错； 5、信道复用技术： 频分复用：所有主机在相同的时间占用不同的频率带宽资源； 时分复用：所有主机在不同的时间占用相同的频率带宽资源； 统计时分复用：是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送； 波分复用：光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波； 码分复用：为每个用户分配 m bit 的码片，并且所有的码片正交； 6、CSMA/CD（载波监听多路访问 / 冲突检测）协议：每个站在发送数据报之前要先检测一下总线上是否有其他计算机在发送数据，若有，则暂时不发送数据，以免发生冲突；若没有，则发送数据。计算机在发送数据的同时检测信道上是否有冲突发生，若有，则采用截断二进制指数类型退避算法来等待一段随机时间后再次重发。（先听后发、边听边发、冲突停发、随机重发）； 7、PPP点对点协议：互联网用户通常需要连接到某个 ISP （互联网服务提供商）之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议； 8、MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）； 9、局域网：局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限； 10、广域网：由一些结点交换机以及连接这些交换机的链路组成； 11、以太网：采用总线拓扑结构，所有计算机共享一条总线，信息以广播方式发送； 12、交换机（多端口的网桥）：具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射，由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容； 网络层1、网络层：负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫IP数据报，简称数据报； 2、网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络； 3、与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protocol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） 4、IP数据报格式： 5、IP地址编址方式： 分类：由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的； IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 子网划分：从主机号借用若干个比特作为子网号（子网号绝不能全1和全0），而主机号也就相应减少了若干个比特，网络号不变，把两级 IP 地址划分为三级 IP 地址； IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 子网掩码：1对应于IP地址中的网络号和子网号，0对应于主机号，子网掩码与IP地址逐位“与”可得到网络地址； 无分类编址（CIDR）：为解决IP地址耗尽，使用各种长度的“网络前缀”来代替分类编址中的网络号和子网号； IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} 6、地址解析协议ARP：将IP地址转为物理（MAC）地址，每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表； 7、网际控制报文协议ICMP：检测出错误的路由器或主机都能把这些错误报告通过一些控制消息告诉发送数据的主机，ICMP分为两种：ICMP差错报告报文和ICMP询问报文； 8、路由器：从功能上可以划分为：路由选择和分组转发，分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口； 9、路由选择协议： 自治系统内部的路由选择：RIP 和 OSPF； RIP（UDP） 是一种基于距离向量的路由选择协议。距离是指跳数（范围限制在15跳之内），超过 15 表示不可达； 三要素： 仅和相邻路由器交换信息；交换的信息是当前本路由器所知道的全部信息，即自己的路由表；按固定的时间间隔交换路由信息； OSPF（IP）：链路状态协议； 三要素： 向本自治系统中所有路由器发送信息；发送的信息是否是与本路由器相邻的所有路由器的链路状态；只有当链路状态发生变化时，路由器才用洪犯法向所有路由器发送此信息； 自治系统间的路由选择：BGP（TCP），路径-向量路由选择协议； 总结： 主要特点 RIP OSPF BGP 网关协议 内部 内部 外部 路由表内容 目的网络，下一跳，距离 目的网络，下一跳，距离 目的网络，完整路径 最优通路依据 跳数 费用 的多种有关策略 算法 距离–向量协议 链路状态协议 路径-向量协议 传送方式 UDP IP数据报 TCP 10、NAT：将专用网内部使用的本地IP地址转换为有效的外部全球IP地址； 运输层1、运输层：负责向两台主机进程之间的通信提供通用的数据传输服务； 2、网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道； 3、UDP（一般用于即时通信，比如QQ语音 、QQ视频 、直播）主要特点： UDP是无连接的； UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）； UDP是面向报文的； UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）； UDP支持一对一、一对多、多对一和多对多的交互通信； UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短； 4、TCP（一般用于文件传输、发送和接收邮件、远程登录等场景）主要特点： TCP是面向连接的；（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）； 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）； TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达； TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据； 面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流； 5、TCP三次握手： 为什么要三次握手？ 三次握手的目的是建立可靠的通信信道，防止报文段在传输连接建立过程中出现差错； 6、TCP四次挥手： 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接； 7、TCP协议保证可靠传输： 超时重传： 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段； 利用滑动窗口实现流量控制的机制：发送窗口里面的序号表示允许发送的序号。如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收； 拥塞控制：在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载； 流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度； TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复； 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口； 慢开始（呈指数增长）：当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍； 拥塞避免（线性增长）：让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1； 快重传与快恢复：在TCP/IP中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有FRR，如果数据包丢失了，TCP将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作； 应用层1、应用层：通过应用进程间的交互来完成特定网络应用； 2、域名系统（DNS）：DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。这里的分布式数据库是指，每个站点只保留它自己的那部分数据； 3、文件传送协议：FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件； 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答； 数据连接：用来传送一个文件数据； 4、电子邮件协议： 一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议； 邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP； SMTP：SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则； POP3：只要用户从服务器上读取了邮件，就把该邮件删除，但是目前改进的 POP3 已经全面支持下载而不删除原邮件。 它的另一个主要特点是：无论你在客户端做了任何操作（如移动、标记），都不会反映到服务器上，也就是只能单方面地从服务器“读取”； IMAP：客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被自动删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 同时它与 POP3 的本质区别在于，在客户端的操作（包括删除）都会反映到服务器上，是一个双向的通信； 5、常用端口： 6、HTTP协议：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法； 7、浏览器输入url地址，显示主页的过程： 8、各种协议与HTTP协议之间的关系： 9、HTTP长连接、短连接： 在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话； 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码： 1Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接； 10、状态码： 11、HTTP和HTTPS的基本概念： HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少； HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL； HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性； 12、HTTP和HTTPS的区别： https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用； http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议； http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443； http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全； 参考博文链接：这篇和这篇～ 附图TCP、UDP互联网协议： TCP 三次握手和四次挥手： 从浏览器 URL 输入到页面显示经历过程： HTTPS与HTTP的区别，以及HTTP2： 附图来源： https://github.com/Joe19970619/Learning-materials/tree/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84","comments":true,"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"利用西门子数据集获取函数调用序列","date":"2019-04-12T08:07:10.000Z","path":"2019/04/12/利用西门子数据集获取函数调用序列/","text":"利用pvtrace工具获取测试集 replace 的函数调用关系图 About西门子数据集的目录结构参见此篇博文，本篇博文主要介绍根据需求编写测试脚本，利用pvtrace工具动态的将测试用例传入程序并获取函数调用关系图。由于在西门子的7个子测试集中，replace测试集含有的函数最多，因此本篇博文选用replace测试集作为例子，其他数据集也一样操作。 测试脚本范例理解上篇博文已经介绍replace数据集给我们提供了范例脚本，存储在scripts目录中，该脚本用于运行source.alt / source.orig 目录中被测程序的正确原型，但是研究软件缺陷定位不可能只运行正确的程序，将测试用例动态传入错误版本的程序并分析其运行结果更为重要，下面我们介绍如何利用套件中已经给出的范例脚本修改得到自己需要的运行脚本。 打开scripts目录下的runall.sh脚本，部分截图如下： 可以看出，该脚本的功能： 遍历inputs文件夹下的所有测试用例（replace测试集的inputs文件夹下包含3个子文件夹，里面的测试用例共计5542个）； 将每个测试用例依次传入被测程序中，并指定输出结果存放的路径； 如果想要将该脚本修改为执行错误版本程序的脚本，我们需要修改： 可执行程序的路径； 程序执行结果存放的路径； 手工修改该脚本中5542个路径显然不可行，需要手工编写程序使其自动修改路径，生成新的脚本文件。 在实际情况中，仅仅获取被测程序的运行结果通过与否是不足够的，根据需求还应获取程序执行信息（这里我示范的是获取程序的函数调用关系图）。 我们还需要了解pvtrace工具的使用，这个工具可以获取程序的函数调用关系，通过Graphviz 可以将函数调用关系可视化展示，下面介绍下pvtrace和Graphviz的安装： 安装pvtrace： 12345678#进入fl文件目录下：wget http://www.mtjones.com/developerworks/pvtrace.zip#解压下载包，如果出现命令找不到，需下载压缩工具yum install -y unzip zip 或者 sudo apt-get install zipunzip pvtrace.zipcd pvtracemakesudo make install 安装Graphviz： 1yum install graphviz 这里给出pvtrace和Graphviz的使用介绍链接： http://www.voidcn.com/article/p-xlemghrq-xb.html https://www.ibm.com/developerworks/cn/linux/l-graphvis/ 如果需要获取函数调用关系，为了避免路径出错，我们直接将pvtrace路径下的instrument.c文件拷贝到跟源码文件同级目录下，在GCC编译代码文件时需要加入指定编译选项即可： 1gcc -g -finstrument-functions replace.c instrument.c -o replace.exe 简单获取函数动态调用关系图示例这里先简单介绍下，如何获取函数动态调用关系图： 将pvtrace路径下的instrument.c文件拷贝到source.alt / source.orig目录下，然后将源程序代码replace.c和instrument.c一起编译，命令如下： 12cd source.alt/source.origgcc -g -finstrument-functions replace.c instrument.c -o replace.exe 将scripts目录中的脚本进行修改（命名为runV1.sh），这里示例一个测试用例，后面写代码批量修改路径： 12replace.exe '-?' 'a&amp;' &lt; ../../inputs/temp-test/1.inp.1.1 &gt; ../../outputs/t1pvtrace replace.exe 执行脚本文件： 1source ./runV1.sh source.alt / source.orig目录下生成graph.dot文件，用graphviz将它可视化： 1dot -Tpng graph.dot -o graph.png 执行命令后会报错，打开graph.dot文件将第一行的graph.dot改为graph即可，再执行上面命令； 执行完后，目录下会生成一个graph.png的图，这个图就是程序replace.c在传入t1这个测试用例生成的函数调用关系图： 从上图还可以看到函数之间调用的次数，当然，我们如果需要数据处理的话，利用graph.dot文件就够了，这个文件里包含函数之间调用关系，调用顺序，调用次数，这些信息根据需要自己进行处理； 生成测试脚本下面我参考这篇博文根据范例脚本生成错误版本执行的脚本，脚本生成使用lua语言实现。 首先初始化，指定子套件名称”replace”，测试用例个数5542和错误版本程序个数32； 12345678910SUITE_NAME = \"replace\"CASE_NUM = 5542VERSION_NUM = 32 --should be 32 in replace--VARIABLES--buff = &#123;&#125;i = 0j = 0k = 0line_num = 0tmp = \"\" 接着我们要将范例给的的runall.sh 读入，以便在下一步的文本分析中可以按行进行文本匹配，下面的程序段完成了将范例给出的runall.sh 文本读入，并按行存储至一个缓冲字符串数组buff 中： 12345678--SAVE ORIG SCRIPT INTO BUFFER--file = io.open(\"runall.sh\", \"r\")for line in file:lines() do i = i + 1; buff[i] = lineendline_num = ifile:close() 最后就是将buff 数组中的每一行进行文本匹配，将”/source.alt/source.orig/”字段全部替换为”/../../versions.alt/versions.orig/vX/”(其中”X”为相应的错误版本号)，将”/inputs/”字段全部替换为”/../../inputs/”，将”/outputs/”字段全部替换为”/../../newoutputs/vX”(其中”X”为相应的错误版本号)，其余保持不变，实现代码如下： 12345678910111213141516171819--GENERATE RUN SCRIPT FOR VERSIONS--for i = 1, VERSION_NUM do k = 1 file = io.open(\"run_v\"..i..\".sh\", \"w\") for j = 1, line_num do tmp = buff[j] if string.find(tmp, \"/source.alt/source.orig/\") ~=nil then tmp = string.gsub(tmp,\"/source.alt/source.orig/\", \"/../../versions.alt/versions.orig/v\"..i..\"/\") --modefy paths-- tmp = string.gsub(tmp,\"/inputs/\", \"/../../inputs/\") tmp = string.gsub(tmp,\"/outputs/\", \"/../../newoutputs/v\"..i..\"/\") tmp = tmp..\"\\ncd ../../../versions.alt/versions.orig/v\"..i..\" &amp;&amp; pvtrace replace.exe\" tmp = tmp..\"\\nmv trace.txt ./tra\"..k.. \" &amp;&amp; mv graph.dot ./tra\"..k k = k + 1 end file:write(tmp..\"\\n\") tmp = \"\" end file:close()end 上面这段代码为每次错误版本都生成了一个名为run_vX.sh 的运行脚本，其中X为相应的错误版本号。并且在每个测试用例执行之后，进入错误版本目录下运行命令pvtrace replace.exe，生成函数调用关系trace.txt和graph.dot文件，因为每个测试用例运行生成的dot文件名都是graph、txt文件名都是trace，因此为了避免覆盖需要将各个版本的每个测试用例生成的dot和txt文件移入对应的文件夹（下面需要在每个版本文件夹下建立5542个名为traX的文件夹—X为相对应执行的测试用例）； 123456789101112#下面是用python代码在每个错误版本程序文件夹下生成5542个存放dot和txt的文件夹#make_dir.pyimport osimport shutildir = os.getcwd()for index1 in range(1, 33): if index1 &gt; 0: new_dir = dir + '/v'+ str(index1) for index2 in range(5543): if index2 &gt; 0: os.mkdir(new_dir + '/tra' + str(index2)) pass 执行命令：python make_dir.py即可生成文件夹； 接着在versions.alt/versions.orig目录下建立一个存放shell脚本的文件夹sh，并将范例脚本runall.sh拷贝至sh目录下； 最后我们就可以执行前面的lua程序了，完整代码链接如下： 链接：https://pan.baidu.com/s/1aEO52uidTEVSKNJuzg2_mg 提取码：kqyz 12#运行make_sh.lua程序lua make_sh.lua 运行完后，可以在sh目录下发现生成的错误版本相对应的32个sh脚本，如下图： 批量编译在执行错误版本的测试脚本之前，首先需要对错误版本的代码进行自动批量编译，在这里，我们使用makefile 进行自动编译，makefile的结构如下： 12replace: gcc -g -finstrument-functions replace.c instrument.c -o replace.exe 由于我对makefile还不熟悉，因此采用的笨办法，将这个makefile文件在每个错误版本文件夹下拷贝一份，然后再写代码自动编译（在编译之前需要修改程序源码使其编译通过，修改方式参考这篇博文。","comments":true,"tags":[{"name":"软件缺陷定位","slug":"软件缺陷定位","permalink":"http://yoursite.com/tags/软件缺陷定位/"}]},{"title":"软件缺陷定位西门子数据集介绍","date":"2019-04-08T01:25:03.000Z","path":"2019/04/08/软件缺陷定位西门子数据集介绍/","text":"Siemens suite 的下载及使用详细步骤 AboutSiemens suite是软件缺陷定位领域研究中最常用的测试套件，可从SIR（software infrastructurerepository）下载，这个测试套件被很多有关软件缺陷定位的文献中使用。 Siemens suite下载进入SIR网址，如下图： 此时需要注册经审核后才可以登录下载，点即Get Access进入登录注册界面： 点击Register进入注册界面，注册需要填写自己所在机构或公司（我填的是学校名称），还有关于自己研究方向的简短描述，填完基本信息后，经过审核就可以登录进行下载了。 登录后，可以点击Download Objects进行下载： 这里我把Siemens suite包含的7个测试集都下载好了，链接如下： 链接：https://github.com/xuexuehan/Siemens-suite Siemens suite使用首先看下Siemens suite包含的7个测试集主要信息： Program Description Lines of Code Faulty versions Test cases print_tokens lexical analyzer 565 7 4130 print_tokens2 lexical analyzer 510 10 4115 schedule priority scheduler 412 9 2650 schedule2 priority scheduler 307 10 2710 replace pattern replacement 563 32 5542 tcas altitude separation 173 41 1608 tot_info information measure 406 23 1052 这几个测试集的文件组织结构和使用方法基本雷同，只要掌握一个，其他也是一样的方法。接下来主要以replace测试集为例介绍下该套件的目录组织结构： 首先建立一个存放测试集的文件夹fl，将下载的replace测试集放在fl文件夹下，在此目录下解压： 1tar zxvf replace_2.1.tar.gz 解压完成后，会在解压目录下生成replace文件夹，打开文件夹可以看到其目录组织结构： 在这些目录中，我们需要用到的有inputs、newoutputs、outputs、scripts、source.alt、versions.alt，这里面source和versions文件夹是空的，可以忽略； 先看source.alt / source.orig里面有replace.c这个被测程序的代码文件，在执行测试程序以前，需要将其提前编译为replace.exe 的二进制文件以供测试程序调用。进入source.alt / source.orig目录下，利用Linux平台上 GCC编译器编译被测代码，使用命令： 1gcc -O2 replace.c -o replace.exe 注意：”-O2”中是大写字母”O”而不是数字”0”,表示使用2级优化，而后面的”-o”中是小写字母”o”,表示指定输出文件名。执行命令后可以看到： 可以看到编译器弹出警告，这是由于Siemens Suite 套件中，代码大多完成于90年代，而我们使用的GCC 编译器的版本较新。在此期间，C语言的国际标准发生了很大变化，在replace中，如果想要编译器编译通过，需要修改replace.c代码文件： 主要修改的还是将一些库函数加入到include中，把内置函数和关键字重命名： 首先将 ctype.h 和 stdlib.h 头文件加入到include中； 将函数名为getline的全部替换为get_line（因为getline函数在stdio.h中已经定义，重命名即可）； 将# define NULL 0 修改为 define NUL 0（因为NULL是关键字，提示重复定义）； 此时，修改完毕，再继续编译，即可通过，会在同目录下生成replace.exe； 这里放上我修改后的replace.c代码文件链接： 链接：https://pan.baidu.com/s/1c4mKAcqNegs7kMBa_abVdg 提取码：upkh 在编译其他测试套件代码文件时也会弹出警告，甚至报出错误无法编译，需要按照相应的提示修改代码文件； versions.alt / versions.orig 目录中保存了该被测程序的每个错误版本（在正确的程序之中，随机植入若干错误，产生的错误代码供大家测试），打开versions.alt / versions.orig 目录可以看到replace的32个错误版本文件夹（里面的replace.c里有植入错误，同理按照上面的步骤修改使其编译通过）： 在这32个错误版本中，错误产生的地方在代码文件中有注释标明； inputs / input 目录里保存了所有的测试用例的输入； outputs 目录用于保存被测程序的正确原型（即source.alt / source.orig 目录中的replace.c代码）对于每个测试用例给出的预期输出，在测试含有错误的版本时用于比较相同测试用例得到的执行结果是否相同。在未执行任何测试程序之前，outputs 目录暂时为空； newoutputs 目录用于保存被测程序的每个错误版本对于每个测试用例得到的实际输出，在测试含有错误的版本时用于比较相同测试用例得到的执行结果是否相同。在未执行任何测试程序之前，newoutputs 目录暂时为空； scripts 目录中保存了子测试套件给出的测试脚本范例，打开scripts 目录后可以看到该目录下有一个名为runall.sh 的shell 脚本文件，该脚本文件用于运行source.alt / source.orig目录中被测程序正确原型，将测试用例输入到被测程序正确原型中后，将执行结果输出到replace 中outputs 目录下，按每个测试用例组织文件，runall.sh 中共定义了5542 个测试用例（replace 子套件共有5542 个测试用例），在scripts 目录中输入命令 source ./runall.sh 即可运行该脚本文件，在运行该脚本之前，需要先将source.alt / source.orig 中的replace.c代码文件编译并且修改runall.sh脚本文件replace.exe存放的路径。因为现在新版的套件replace.c程序文件在source.alt / source.orig目录下而非source目录下，将脚本文件中所有的 ../source 替换为 ../source.alt/source.orig； 这里给出我修改后的runall.sh脚本文件链接： 链接：https://pan.baidu.com/s/1efga4E3dI5uh7tk2YFZJWA 提取码：6tan 当运行完runall.sh脚本后，在outputs目录下可以看到这5542个测试用例执行后的结果文件，下图是部分截图： 至此，西门子测试集的子套件目录结构介绍完毕。 参考博文：https://blog.csdn.net/mangoer_ys/article/details/25974067#commentBox （这个博主写的真详细，我基本就是参考这个博文了解的西门子测试集使用方法）","comments":true,"tags":[{"name":"软件缺陷定位","slug":"软件缺陷定位","permalink":"http://yoursite.com/tags/软件缺陷定位/"}]},{"title":"阿里云部署SpringBoot项目","date":"2019-04-07T09:07:25.000Z","path":"2019/04/07/阿里云部署SpringBoot项目/","text":"阿里云部署Spring Boot 项目详细步骤 购买云服务器首先需要在阿里云购买云服务器，进入链接后选择弹性计算，选择所需的类型购买（如果是学生党，完成学生认证后，有学生专享优惠，9.5/月，不能再划算了…），购买完成后，点击控制台就可看到自己购买云服务器的详情； 设置密码，这个密码就是用ssh连接云服务器的密码； 这里我使用了两个软件：SecureCRT（用来连接云服务器） 和 WinSCP（用来从本机给云服务器上传文件）； WinSCP图形化界面如下： 左边面板显示的是本机文件目录，右边是云服务器文件目录；（如果目录不显示压缩包的话，记得在传输选项里的配置里在面板选项去掉“默认目录是主目录”）； 这两个软件下载地址：https://pan.baidu.com/s/1zUnhqBffaqiDG3wYFM6dpg 提取码：1zxb 然后就开始在云服务器上安装配置MySQL和JDK； 安装配置MySQL这里安装配置需要细心，因为有挺多需要修改的配置文件，当然用docker安装配置更加方便，这里用的常规安装配置； 首先将MySQL安装包用WinSCP从本机上传至云服务器； 这里提供我安装MySQL所使用的版本： 链接：https://pan.baidu.com/s/1t8wBXQy89AF-XYxeN3Et1g提取码：az6k 具体安装配置步骤如下面链接文档所示（因为步骤有点多，直接提供文档，步骤很详细）： 链接：https://pan.baidu.com/s/1eLal9b3j5Aca_vcA0VCf0A 提取码：gfxy链接里的配置文档主要操作就是安装MySQ、添加用户组和用户、授权、配置环境变量、修改密码、关闭防火墙…，在修改了配置文件后需要flush privileges，最后就是需要在阿里云添加安全组规则，开放MySQL端口号3306； 安装配置JDK首先将JDK安装包用WinSCP从本机上传至云服务器，我上传到云服务器/opt目录里面； 这里提供我安装JDK所使用的版本： 链接：https://pan.baidu.com/s/1IyQqgMepQj4kQthiE9FITA 提取码：uizg 解压文件： 12cd /opttar -zxvf jdk的文件名 将jdk移动到/home目录：mv jdk1.8.0_171/ /home/ 配置环境变量： vim /etc/profile 在末尾行添加，打开后按 i 编辑, 按 ctrl+c 停止编辑，然后 :wq 保存退出 12export JAVA_HOME=/home/jdk1.8.0_171export PATH=$PATH:$JAVA_HOME/bin: 使更改的配置立即生效：source /etc/profile java -vsion查看JDK版本信息，如果显示出1.8.0证明成功 阿里云发布项目将打包后的项目用WinSCP从本机上传至云服务器，然后向mysql云服务器执行项目sql脚本，在阿里云添加安全组规则，开放端口号8080和80，进入上传项目的目录下执行命令： 12//后台进程执行项目nohup java -jar spring-boot-10-bill-0.0.1-SNAPSHOT.jar --serverport=80 &amp; 停止运行项目： 1234//查看进程ps -ef|grep java//找到项目的进程id，杀死该进程kill -9 进程id 至此，项目部署完毕，可以通过云服务器的ip地址访问项目。当然如果买了域名，挂到云服务器的ip地址下，就可以解析ip，直接通过域名访问。 MySQL中文乱码部署完项目，访问时可能会出现中文乱码问题，首先登录mysql； 12#查看数据库编码：show variables like '%char%'; 如果character_set_database 和 character_set_server显示字符编码为latin1,此时修改mysql配置文件/etc/my.cnf： 123456[mysqld]character-set-server=utf8 [client]default-character-set=utf8 [mysql]default-character-set=utf8 然后再重启，登录mysql，查看字符编码： 1show variables like '%char%'; 出现如上图字符编码为utf-8,则成功。 参考博客链接：https://blog.csdn.net/u012410733/article/details/61619656","comments":true,"tags":[{"name":"Spring-Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot基础总结","date":"2019-04-03T06:53:02.000Z","path":"2019/04/03/Spring-Boot基础总结/","text":"关于Spring Boot一些基础总结 About1、尽快启动和运行，使用“习惯优于配置”（项目中存在大量的配置，而 Spring Boot 内置一个习惯性的配置，让你无须手动进行配置）的理念让项目快速运行起来； 2、Spring Boot 优点 ： 快速构建独立运行的Spring项目； 无须依赖外部Servlet容器，应用无需打成WAR包；项目可以打成jar包独自运行； 提供一系列 starter pom 来简化 Maven 的依赖加载； 大量的自动配置，对主流开发框架的无配置集成； 无须配置XML，开箱即用，简化开发，同时也可以修改默认值来满足特定的需求； Spring Boot 并不是对 Spring 功能上的增强，而是提供了一种快速使用 Spring 的方式； 极大提高了开发、部署效率 ； 入门1、两种启动方式： 直接main； 打成jar包，在dos命令下java -jar 项目名称； 2、Spring Boot底层依赖： 123456789101112131415161718192021222324252627282930 /* spring-boot-starter-parent：是当前项目的父依赖 spring-boot-starter-parent继承spring-boot-dependencies spring-boot-dependencies里面定义了很多组件版本号，我们引用对应依赖时，不需要写&lt;version&gt; */&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; /* spring-boot-starter-web：构建web项目，比如：Tomcat、SpringMVC spring-boot-starter：它是SpringBoot的场景启动器，针对不同场景定义了很多不同的场景启动器 你的项目需要哪些场景启动器，则直接依赖对应的启动器就可以了 */ &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; //将当前项目打成一个jar包运行 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 3、Spring Boot底层源码： 1234567891011121314/** * @SpringBootApplication 用于标识为引导类,说明当前是一个SpringBoot项目 * @SpringBootConfiguration * @Configuration 它属于spring中的一个注解，定义配置类，等价于配置文件 * @Component 添加到spring容器中，表示是一个组件 * @EnableAutoConfiguration * @AutoConfigurationPackage 将引导类所在包及其子包下面所有的组件添加到spring容器中 * @Import(&#123;AutoConfigurationImportSelector.class&#125;) * 1、将所有组件以全类名的方式返回，并且添加到spring容器中 * 2、会给容器中导入非常多的自动配置类（*****AutoiConfiguration），就是导入并配置好很多当 前项目中所需要的组件 * 省去我们手动编写配置然后注入到组件中 * @ComponentScan 被该注解标识的类，会被spring容器进行管理 **/@SpringBootApplication//组合注解 核心配置1、spring boot全局配置： application.properts application.yml 2、YAML： YAML不是一个标记语言； 以数据为中心，配置数据的时候具有面向对象的特征；比json、xml更适合做配置文件； 3、YAML语法格式： YAML基本语法： key: value 表示一对键值对（冒号后面必须有空格）； 使用空格缩进表示层级关系； 左侧缩进的空格数目不重要，只要同一层级的元素左侧对齐即可 ； key 与 value大小写敏感； YMAL常用写法： 字面量： 数值，字符串，布尔，日期； 字符串默认不用加上引号： “ ” 使用双引号会转义特殊字符，特殊字符最终会转成本来想表示含义输出； ‘ ‘ 使用单引号不会转义特殊字符，特殊字符当作一个普通的字符串输出； 对象 &amp; Map ： key: value value存储对象，每个值换一行写，注意值要左对齐； 1234emp: lastName: xiaomeng age: 22 salary: 10000 行内写法： 1emp: &#123;lastName: xiaomeng, age: 22, salary: 10000&#125; 数组（List、Set）： 用 - 值表示数组中的一个元素： 1234fortes: - java - python - hadoop 行内写法： 1fortes: [java, python, hadoop] ​4、YAML全局配置文件注入值： 12345/** ConfigurationProperties: 告诉spring boot将配置文件中的对应属性值，映射到这个组件类中，进行一一绑定* prefix = \"emp\": 配置文件中的前缀名，配置了哪个前缀就会与下面的所有属性进行一一映射* @Component: 将当前组件作为springboot中的一个组件来使用，这样才会纳入容器中管理* */ 5、@Value注解获取注入值： 1234567/** * 类似于spring框架中使用配置文件中的数据注入方式 * &lt;bean class=\"Emp\"&gt; * &lt;property name=\"lastName\" value=\"字面量/#&#123;SpEL&#125; spring表达式/$&#123;key&#125;从配置文件获取\"&gt; &lt;/property&gt; * &lt;/bean&gt; * */ @Value(\"$&#123;emp.last-name&#125;\") 6、比较@Value和@ConfigurationProperties获取值： @ConfigurationProperties @Value 示例 实现功能 批量注入配置文件的属性值 一个一个指定 松散绑定（松散语法） 支持 不支持 last_name == lastNamelast-name == lastName SpEL 不支持 支持 #{10*2} 复杂类型封装 支持 不支持 ${emp.map} JSR303数据校验 支持 不支持 使用场景： 如果只是在某个业务逻辑中需要获取配置文件中的某个属性值，就使用 @Value； 如果专门使用javaBean和配置文件进行映射，就使用 @ConfigurationProperties； 7、加载局部配置文件： 1@PropertySource(value = &#123;\"classpath:emp.properties\"&#125;) 8、加载XML配置文件： 12//用于导入spring的配置文件，并将它加载到容器中@ImportResource(locations = &#123;\"classpath:spring01.xml\"&#125;) 9、自定义配置类： 123456789101112131415/***@Configuration: 它属于spring中的一个注解,用于标识当前类是一个配置类，来表示对应spring配置文件**/@Configurationpublic class EmpConfig &#123; /** * @Bean 标识的方法用于向容器中注入组件 * 1、返回值就是注入容器中组件对象 * 2、方法名就是这个组件的 id 值 * */ @Bean public EmpService empService2() &#123; System.out.println(\"EmpService 组件注入成功\"); return new EmpService(); &#125; 10、多环境项目配置支持： 12345678910111213141516171819//properties#激活profile文件spring.profiles.active=prod//ymlserver: port: 8081 #默认配置的端口号spring: profiles: active: dev #激活哪个profile---server: port: 8082spring: profiles: dev #指定属于哪个环境，dev环境使用---server: port: 8088spring: profiles: prod #指定属于哪个环境，prod环境使用 程序参数、命令行（jar包运行时）：–spring.profiles.active=prod； 虚拟机指定参数：-Dspring.profiles.active=prod； 11、配置文件加载位置： 配置文件位置 说明 file: ./config/ 当前项目的config目录下（最高级别） file: ./ 当前项目的根目录下（第三级别） classpath: /config/ 类路径的config目录下（第二级别） classpath: / 类路径的根目录下（最低级别） 按照优先级从低到高的顺序，将所有位置的配置文件全部加载，高优先级的配置内容会覆盖低优先级的配置内容； 日志配置1、日志框架： 日志抽象层 日志实现 jboss-logging（不适合企业项目开发使用）JCL（Jakarta Commons Logging）—2014年后不再维护SLF4j（Simple Logging Facade for Java）—与log4j、Logback同一个人开发 JUL（java.util.logging）—担心被抢市场，推出的Log4j（存在性能问题）Logback（Log4j同一个人开发的新框架，做了重大升级）Log4j2（apache开发的很强大，借了log4j的名，但当前很多框架未适配上） Spring Boot 采用了 slf4j+logback 的组合形式，Spring Boot也提供对JUL、log4j2、Logback提供了默认配置； 2、log五大日志级别：（由低到高） 12345678910111213//1、下面定义的都是日志级别，由低到高：trace &lt; debug &lt; info &lt; warn &lt; error//2、spring boot默认设定的是 info 级别日志（日志默认级别也称为root级别）//3、可以通过配置文件进行修改 日志级别，设置某一个级别后，就只打印这个级别及后面更高级别的日志信息，没有指定级别的就用springBoot默认规定的级别，root级别//跟踪运行信息logger.trace(\"这是 trace 日志信息\");//调试信息logger.debug(\"这是 debug 日志信息\");//自定义信息logger.info(\"这是 info 日志信息\");//警告信息logger.warn(\"这是 warn 日志信息\");//错误信息logger.error(\"这是 error 日志信息\"); 1234//调整指定包的日志级别logging.level.com.xx=debug//修改springboot的root级别（默认级别）logging.level.root=debug 3、修改日志默认配置： 修改日志文件生成路径： 1234//输出到当前项目根路径下的springboot.log文件中logging.file=springboot.log//输出到当前项目所在磁盘根路径下的/springboot/log目录中的spring.log文件中 E:\\springboot\\log\\spring.loglogging.path=/springboot/log 修改日志输出的格式： 1234567891011/**日志输出格式说明：* %d 输出日期时间，* %thread 输出当前线程名，* %-5level 输出日志级别，左对齐5个字符宽度# %logger&#123;50&#125; 输出全类名最长50个字符，超过按照句点分割# %msg 日志信息# %n 换行符 *///修改控制台输出的日志格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; == [%thread] %-5level %logger&#123;50&#125; - %msg%n//修改文件中输出的日志格式logging.pattern.file=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-5level &gt;&gt;&gt; %logger&#123;50&#125; - %msg%n 4、自定义日志配置： logback.xml ：是直接就被日志框架加载了； logback-spring.xml：配置项不会被日志框架直接加载，而是由 SpringBoot 解析日志配置文件，进而可以使用 SpringBoot 的 Profile 特殊配置 ； 使用日志profile特殊配置，可根据不同的环境激活不同的日志配置： 1234567891011&lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; //根据不同的环境要求进行配置不同的日志信息 &lt;springProfile name=\"dev\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; === [%thread] === %-5level === %logger&#123;50&#125; === %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-5level &gt;&gt;&gt; %logger&#123;50&#125; &gt;&gt;&gt; %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; 5、切换日志框架： 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; //采用log4j2的日志框架 //将spring-boot-starter-logging移除 &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; web开发1、springboot web启动器包括嵌入的Servlet容器和SpringMVC； 2、springboot对静态资源（webjars/静态文件）的映射： 123456789101112public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;if (!this.resourceProperties.isAddMappings()) &#123;logger.debug(\"Default resource handling disabled\");&#125; else &#123;Duration cachePeriod =this.resourceProperties.getCache().getPeriod();CacheControl cacheControl =this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123;//收到 /webjars/**请求后 ，会去classpath:/META-INF/resources/webjars/ 查找资源文件this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;\"/webjars/**\"&#125;).addResourceLocations(new String[]&#123;\"classpath:/METAINF/resources/webjars/\"&#125;).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); 访问 localhost:8080/webjars/jquery/3.3.1/jquery.js 会在下面路径中查找： 123456//引入jquery webjars&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt; 当接受到 /** 请求访问资源时, 会被映射到下面4个 类路径下的静态资源目录中查找 ： 1234classpath:/META-INF/resources/classpath:/resources/classpath:/static/classpath:/public/ 访问 localhost:8080/style.css 会在上面四个静态资源路径中查找文件 ； 3、欢迎页的映射： 会从 4个静态资源目录 + 根路径 / 中 查找 index.html 页面： 12345classpath:/META-INF/resources/classpath:/resources/classpath:/static/classpath:/public//: 当前项目根路径下 会在 静态资源目录下 与 根路径查找 (按该顺序) index.html页面； 收到 “/**” 请求映射； 访问 localhost:8080/ 会在上面5个目录中查找 index.html页面（因为/也属于/**）； 4、项目ico图标的映射： Spring Boot 会在静态资源目录下 与 根路径(按该顺序) 查找 faicon.ico 页面； 如果存在这样的文件，springboot会自动将其设置为应用图标； 5、Thymeleaf模板引擎： 嵌入式tomcat默认不支持jsp； Spring Boot 官方推荐使用 Thymeleaf 作为模板引擎， 因为 Thymeleaf 提供了完美的 SpringMVC 的支持； pom.xml 加入 Thymeleaf 启动器： 12345//thymeleaf 模板启动器&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 模板文件放在哪里 ? DEFAULT_PREFIX = “classpath:/templates/“； 将 HTML 页面放到 classpath:/templates/ 目录下， Thymeleaf 就能自动渲染； 在 html 页面加上以下名称空间, 使用 Thymeleaf 时就有语法提示 ： 1&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt; 6、Thymeleaf语法： 常用属性： 标准表达式语法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273一、Simple expressions（表达式语法） 1. Variable Expressions(变量表达式): $&#123;...&#125; （参考： 4.2 Variables） 1)、获取变量值；使用OGNL表达式； 2）、获取对象的属性, 调用方法 3）、使用内置的基本对象： #ctx : the context object.(当前上下文对象) #vars: the context variables.(当前上下文里的变量) #locale : the context locale. (当前上下文里的区域信息) 下面是Web环境下的隐式对象 #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. 示例: $&#123;session.foo&#125; (用法参考: 18 Appendix A: Expression Basic Objects) 4）、使用内置的工具对象：(用法参考: 19 Appendix B: Expression Utility Objects) #execInfo : information about the template being processed. #messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration) 2. Selection Variable Expressions(选择表达式): *&#123;...&#125; （参考：4.3 Expressions on selections） 1）、和$&#123;&#125;在功能上是一样， 额外新增：配合 th:object 使用 &lt;div th:object=\"$&#123;session.user&#125;\"&gt; 省得每次写$&#123;session.user.firstName&#125;, 直接取出对象，然后写对象名即可 &lt;p&gt;Name: &lt;span th:text=\"*&#123;firstName&#125;\"&gt;Sebastian&lt;/span&gt; &lt;/p&gt; &lt;p&gt;Email: &lt;span th:text=\"*&#123;email&#125;\"&gt;Saturn&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; 3. Message Expressions（获取国际化内容）: #&#123;...&#125; （参考：4.1 Messages） 4. Link URL Expressions（定义URL）: @&#123;...&#125; （参考：4.4 Link URLs） 5. Fragment Expressions（片段引用表达式）: ~&#123;...&#125; （参考：4.5 Fragments） &lt;div th:insert=\"~&#123;commons :: main&#125;\"&gt;...&lt;/div&gt;二、Literals（字面量） （参考： 4.6 Literals） 1. Text literals: 'one text' , 'Another one!' ,… 2. Number literals: 0 , 34 , 3.0 , 12.3 ,… 3. Boolean literals: true , false 4. Null literal: null 5. Literal tokens: one , sometext , main, ... 三、Text operations（文本操作） （参考： 4.7 Appending texts） 1. String concatenation: + 2. Literal substitutions: |The name is $&#123;name&#125;|四、Arithmetic operations（数学运算） （参考： 4.9 Arithmetic operations） 1. Binary operators: + , - , * , / , % 2. Minus sign (unary operator): -五、Boolean operations（布尔运算） 1. Binary operators: and , or 2. Boolean negation (unary operator): ! , not六、Comparisons and equality（比较运算） （参考： 4.10 Comparators and Equality） 1. Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) 2. Equality operators: == , != ( eq , ne )七、Conditional operators(条件表达式;三元运算符) （参考： 4.11 Conditional expressions） 1. If-then: (if) ? (then) 2. If-then-else: (if) ? (then) : (else) 3. Default: (value) ?: (defaultvalue)八、Special tokens（特殊操作） (参考： 4.13 The No-Operation token) 1. No-Operation: - 12345678&lt;!-- th:insert 和 th:replace的区别 th:insert和th:replace都可以引入片段，两者的区别在于 th:insert： 保留引入时使用的标签 th:replace：不保留引入时使用的标签, 将声明片段直接覆盖当前引用标签 --&gt; &lt;div th:replace=\"header :: #header_common_id\" class=\"success\"&gt;&lt;/div&gt; &lt;h2 th:insert=\"header :: #header_common_id\"&gt;&lt;/h2&gt; 17、迭代(th:each)： 12345678910111213141516171819202122 &lt;!--th:each作用在哪个标签上面，对应的就会根据它的值迭代多少次--&gt; &lt;!-- user : 第1个值,代表每次迭代出对象,名字任意取 iterStat : 第2个值,代表每次迭代器内置对象, 名字任意取, 并有如下属性: index : 当前迭代下标 0 开始 count : 当前迭代下标 1 开始 size : 获取总记录数 current : 当前迭代出的对象 even/odd : 当前迭代是偶数还是奇数 (1开始算,返回布尔值) first : 当前是否为第一个元素 last : 当前是否为最后一个元素 --&gt; &lt;tr th:each=\"user, iterStat: $&#123;userList&#125;\"&gt; &lt;td th:text=\"$&#123;iterStat.count&#125;\"&gt;000&lt;/td&gt; &lt;td th:text=\"$&#123;user.username&#125;\"&gt;xxx&lt;/td&gt; &lt;td th:text=\"$&#123;user.gender == 1 ? '男' : '女'&#125;\"&gt;1&lt;/td&gt; &lt;td th:text=\"$&#123;iterStat.size&#125;\"&gt;xxx&lt;/td&gt; &lt;td th:text=\"$&#123;iterStat.even&#125;? '偶数' : '奇数'\"&gt;xxx&lt;/td&gt; &lt;td th:text=\"$&#123;iterStat.first&#125;\"&gt;xxx&lt;/td&gt; &lt;td th:text=\"$&#123;iterStat.last&#125;\"&gt;xxx&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 8、条件判断： 1234567&lt;h3 th:if=\"not $&#123;#lists.isEmpty(userList)&#125;\"&gt;显示出来则userList集合不为空&lt;/h3&gt;&lt;h3 th:unless=\"$&#123;#lists.isEmpty(userList)&#125;\"&gt;显示出来则userList集合不为空&lt;/h3&gt;&lt;div th:switch=\"$&#123;sex&#125;\"&gt; &lt;p th:case=\"$&#123;man&#125;\"&gt;男&lt;/p&gt; &lt;p th:case=\"2\"&gt;女&lt;/p&gt; &lt;p th:case=\"*\"&gt;未知&lt;/p&gt;&lt;/div&gt; 9、显示标签体内容： 1234&lt;!--不转义字符--&gt;&lt;div th:text=\"$&#123;desc&#125;\"&gt;&lt;/div&gt;&lt;!--转义字符--&gt;&lt;div th:utext=\"$&#123;desc&#125;\"&gt;&lt;/div&gt; 显示对象： 12345&lt;div th:object=\"$&#123;session.user&#125;\"&gt; &lt;!--上面已经将对象获取出来，下面直接写属性值即可获取到值--&gt; &lt;p&gt;姓名：&lt;span th:text=\"*&#123;username&#125;\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;性别：&lt;span th:text=\"*&#123;gender&#125; == 1 ? '男' : '女'\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt; 10、springboot热部署： 12345678//开发环境建议关闭thymeleaf缓存spring.thymeleaf.cache=false//热部署依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;//Ctrl + F9 编译 11、扩展springmvc功能： 1234567891011121314151617/** * 1、创建一个WebMvcConfigurer类型的子类 * 2、类上用@Configuration标识它是一个配置类 * 3、不能@EnableWebMvc标识 * 原理： * 1、@Import(&#123;WebMvcAutoConfiguration.EnableWebMvcConfiguration.class&#125;) * 2、public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration * */@Configurationpublic class MySpringConfigurer implements WebMvcConfigurer &#123; //增加视图控制 @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //发送 /xuexue 请求来到 success.html registry.addViewController(\"/xuexue\").setViewName(\"success\"); &#125;&#125; 12、全面控制springmvc： 在自定义的Web配置类上添加 @Configuration 和 @EnableWebMvc 注解； 总结SpringMVC 配置： 在Spring Boot中自已配置组件的时候，先看容器中有没有公司自已配置的（@Bean、@Component）,如果 有就用公司自已配置的; 如果没有，才自动配置； 在Spring Boot中会有非常多的xxxConfigurer帮助我们进行扩展配置； 在Spring Boot中会有很多的xxxCustomizer帮助我们进行定制配置； Spring Boot Restful架构Restful架构：通过HTTP请求方式区别对资源CRUD操作，请求URI是/资源名称/资源标识； 普通CRUD RestfulCRUD 查询 getPrvider provider —GET 添加 addProvider?xxx provider —POST 修改 updateProvider?id=xxx provider /{id} —PUT 删除 deleteProvider?id=1 provider /{id} —DELETE springboot错误处理机制1、几种常见错误（状态码）： 浏览器发送一个不存在的请求时，会报404； 500； 2、timestamp：时间戳， status：状态码， error：错误提示， exception：异常对象， message：异常消息， errors：JSR303数据校验出现的错误； 嵌入式Sevlet容器自定义配置1、注册Servlet三大组件 Servlet/Filter/Listener： ServletRegistrationBean ：注册自定义Servlet ； FilterRegistrationBean：注册自定义Filter； ServletListenerRegistrarionBean：注册自定义Listener； 2、修改嵌入式servlet 容器配置： 123456//修改服务相关的配置server.port=8081//修改关于servlet的相关配置server.servlet.context-path=/servlet//修改tomcat相关配置server.tomcat.max-connections=8000 3、自定义定制器修改嵌入式servlet容器配置： 12345678910111213@Beanpublic WebServerFactoryCustomizer webServerFactoryCustomizer() &#123; return new WebServerFactoryCustomizer() &#123; @Override public void customize(WebServerFactory factory) &#123; ConfigurableServletWebServerFactory factory1 = (ConfigurableServletWebServerFactory)factory; //修改端口号，如果配置文件中与定制器中的配置冲突，默认采用定制器的配置 factory1.setPort(8082); factory1.setContextPath(\"/servlet2\"); &#125; &#125;;&#125; 事务管理123//默认创建表类型是MyISAM，是非事务安全的，所以无法实现事物回滚//指定如下方言: 创建的表类型是Innodb，才可以进行对事物的回滚database-platform: org.hibernate.dialect.MySQL57Dialect 事务管理步骤： 在启动类上 ，使用 @EnableTransactionManagement 开启注解方式事务支持； 在 Service层方法上添加 @Transactional 进行事务管理； 定时任务使用的注解： @EnableScheduling 启动类上开启基于注解的定时任务 ； @Scheduled 标识的方法会进行定时处理 ； 需要通过 cron 属性来指定 cron 表达式： 秒 分 时 日 月 星期几； 在线cron表达式生成器：http://cron.qqe2.com/ 附windows环境下Redis软件下载： https://pan.baidu.com/s/1TPsFnoVJ3e0UhUR5y4K2sw 提取码：qa25 Spring Boot参考文档： https://pan.baidu.com/s/1ai0azTuXtwGSOKEbefIOHw 提取码：hqlv Thymeleaf模板引擎参考文档： https://pan.baidu.com/s/1wymLJ8gbWzzWQG1SRH3NQw 提取码：j5pp ​","comments":true,"tags":[{"name":"Spring-Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Python基础","date":"2019-03-23T05:52:00.000Z","path":"2019/03/23/Python基础/","text":"Python一些基础语法概念 About1、实践、练习 ​ 实践、认识、再实践、再认识 2、实践、实践、实践 基本语法1、程序设计基本方法： 计算机与程序设计：计算机发展按照摩尔定律发展； 编译和解释： 编译：将源代码一次性转为目标代码； 解释：将源代码逐条转成目标代码同时逐条运行的过程； 程序的基本编写方法：IPO（input、process、output）； 2、编程解决问题的步骤： 分析问题：分析问题的计算部分，想清楚； 划分边界：划分问题的功能边界，规划IPO； 设计算法：设计问题的求解算法，关注算法； 编写程序：编写问题的计算程序，编程序； 调试测试：调试程序使正确运行，运行调试； 升级维护：适应问题的升级维护，更新完善； 3、程序语法元素： 注释：单行#，多行’‘’ ‘’‘ 命名（大小写敏感）与保留字（python有33个保留字）；数据类型：字符串（编号索引从0开始）–正向递增序号和反向递减序号、数字类型（整数、浮点数）、列表（有序序列）–使用in判断一个元素是否在列表中； 字符串的使用：使用[]获取字符串中一个或多个字符； 索引：返回字符串中单个字符； 切片：返回字符串中一段字符子串； 语句与函数：赋值语句、分支语句、eval()评估函数–去掉参数最外侧引号并执行余下语句的函数； python程序的输入输出：输入（input—从控制台获取用户输入）、输出（print—以字符形式向控制台输出结果）； 基本图形绘制1、编程语言的多样初心（600多种）： c语言：（指针、内存、数据类型）；语言本质：理解计算机系统结构；解决问题：性能； java：（对象、跨平台、运行时）；语言本质：理解主客体关系；解决问题：跨平台； c++：（对象、多态、继承）；语言本质：理解主客体关系；解决问题：大规模程序； VB：（对象、按钮、文本框）；语言本质：理解交互逻辑；解决问题：桌面应用； python：（编程逻辑、第三方库）；语言本质：理解问题求解；解决问题：各类问题； 2、python语言特点：（通用、脚本、开源、跨平台、多模型）： 特点与优势：强制可读性、较少的底层语法元素、多种编程方式、支持中文字符、（语法简洁）， &gt;13万第三方库、快速增长的计算生态、避免重复造轮子、开放共享、跨操作系统平台、（生态高产） 3、turtle库的使用： turtle（海龟）库基本介绍：python语言的标准库之一，入门级的函数绘制库； python计算生态 = 标准库 + 第三方库 标准库：随解释器直接安装到操作系统中的功能模块 第三方库：需要经过安装才能使用的功能模块 库Library、包Package、模块Module，统称模块 turtle绘图窗体布局：最小单位是像素； 1turtle.setup(width, height, startx, starty) turtle空间坐标体系： 1turtle.goto(x, y) turtle角度坐标体系： 1turtle.seth(angle)#seth()只改变方向但不行进 RGB色彩体系： 1turtle.colormde(mode) 基本数据类型1、数字类型及操作：（整数类型、浮点数类型、复数类型、数值运算操作符、数值运算函数） 整数类型：可正可负，无取值范围限制；pow（x， y）-&gt;计算x的y次方；表示形式（十进制、二进制、八进制、十六进制）； 浮点数类型：带有小数点及小数的数字；浮点数间运算存在不确定尾数，不是bug；round（x， d）-&gt;对x四舍五入，d是小数截取位数；可采用科学计数法表示-&gt;使用字母e或E作为幂的符号； 复数类型：z.real获得实部；z.imag获得虚部； 数值运算操作符：+、-、*、/、//（整数除）； 数值运算函数： 2、天天向上的力量：（GRIT：perseverance and passion for long-term goals） pow(1.01, 365) = 37.78 pow(1.019, 365) = 962.89 GRIT，坚毅，对长期目标的持续激情及持久耐力； 3、字符串类型及操作; 字符串类型的表示：由一对单引号或一对双引号表示； 字符串是字符的有序序列，可以对其中的字符进行索引；字符串两个重要操作：索引（返回字符串中单个字符）和切片（返回字符串中一段字符子串）； 12#使用[M:N:K]根据步长对字符串切片“o一二三四五六七八九十” [::-1] “十九八七六五四三二一o” 转义符（\\）：表达特定字符的本意；转义符形成一些组合，表达一些不可打印的含义； 字符串（由0个或多个字符组成的有序字符序列）操作符： 字符串处理函数： 字符串处理方法： 123\"A, B, C\".split(\",\") #['A', 'B', 'C']\"= python= \".strip(\" =np\") #\"ytho\"\",\".join(\"12345\") #\"1, 2, 3, 4, 5\" 字符串类型的格式化：使用.format()方法 12#字符串中槽&#123;&#125;的默认顺序 = format()中参数的顺序\"&#123;&#125;:计算机&#123;&#125;的CPU占有率为&#123;&#125;%\".format(\"2018-10-10\", \"C\", 10) 4、time库（python中处理时间的标准库）的使用： 时间获取：time（）、ctime（）、gmtime（）； 时间格式化：strftime（）、strptime（）； %Y：年份，%m：月份，%B：月份名称，%b：月份名称缩写，%d：日期，%A：星期，%a：星期缩写， %H：小时（24h制），%h：小时（12h制），%p：上/下午，%M：分钟，%S：秒 程序计时：sleep（）、perf_counter（）； 程序控制结构1、程序的分支结构： 单分支结构：if 二分支结构：if-else（紧凑形式：&lt;表达式1&gt; if &lt;条件&gt; else &lt;表达式2&gt;） 多分支结构：if-elif-else 条件判断及组合：判断（&lt;、&lt;=、&gt;=、&gt;、==、！=），组合（and, or, not） 程序的异常处理：try-except-else-finally 2、程序的循环结构： 遍历循环（遍历某个结构形成的循环运行方式）：for &lt;循环变量&gt; in &lt;遍历结构&gt;: ​ &lt;语句块&gt; 从遍历结构中逐一提取元素，放在循环变量中；由保留字for和in组成，完整遍历所有元素后结束；每次循环，所获得元素放入循环变量，并执行一次语句块；应用：计数循环、字符串遍历循环、文件遍历循环； 无限循环（由条件控制的循环运行方式）： while &lt;条件&gt;： ​ &lt;语句块&gt; 反复执行语句块，直到条件不满足时结束； 循环控制保留字： break：跳出并结束当前整个循环，执行循环后的语句（仅跳出当前最内层循环）； continue：结束当次循环，继续执行后续次数循环； 循环的高级用法（与break有关）：循环与else 当循环没有被break语句退出时，执行else语句块； else语句块作为“正常”完成循环的奖励； 这里else的用法与异常处理中else用法相似； 3、random库（使用随机数的python标准库）的使用： 4、程序运行有80%的时间花在不到10%的代码上（二八法则）； 理解方法思维： 数学思维：找到公式，利用公式求解； 计算思维：抽象一种过程，用计算机自动化求解； 函数和代码复用1、函数的定义与使用： 函数的理解和定义： 函数是一段具有特定功能的、可重用的语句组； 函数是一种功能的抽象，一般函数表达特定功能； 两个作用：降低编程难度、代码复用； 函数是一段代码的表示：def &lt;函数名&gt;(&lt;参数（0个或多个）&gt;): ​ &lt;函数体&gt; ​ return &lt;返回值&gt; —函数定义时，所指定的参数是一种占位符； —函数定义后，如果不经过调用，不会被执行； —函数定义时，参数是输入、函数体是处理、结果是输出（IPO）； 函数的使用及调用过程： 调用是运行函数代码的方式：调用时要给出实际参数；实际参数替换定义中的参数；函数调用后得到返回值； 函数的参数传递： 参数个数：函数可以有参数，也可以没有，但必须保留括号； 可选参数传递：函数定义时可以为某些参数指定默认值，构成可选参数； def &lt;函数名&gt;(&lt;非可选参数&gt;, &lt;可选参数&gt;)： ​ &lt;函数体&gt; return &lt;返回值&gt; 可变参数传递：函数定义时可以设计可变数量参数，既不确定参数总数量； def &lt;函数名&gt;(&lt;参数&gt;, *b)： ​ &lt;函数体&gt; return &lt;返回值&gt; 参数传递的两种方式 ：函数调用时，参数可以按照位置或名称方式传递； 函数的返回值：（函数可以返回0个或多个结果） return保留字用来传递返回值； 函数可以有返回值，也可以没有，可以有return，也可以没有； return可以传递0个返回值，也可以传递任意多个返回值； 局部变量和全局变量：局部变量和全局变量是不同变量； —局部变量是函数内部的占位符，与全局变量可能重名但不同； —函数运算结束后，局部变量被释放； —可以使用global保留字在函数内部使用全局变量； 局部变量为组合数据类型且未创建，等同于全局变量；使用规则： —基本数据类型，无论是否重名，局部变量与全局变量不同； —可以通过global保留字在函数内部声明全局变量； —组合数据类型，如果局部变量未真实创建，则是全局变量； lambda函数（返回函数名作为结果）：lambda函数是一种匿名函数，即没有名字的函数；—使用lambda保留字定义，函数名是返回结果；—lambda函数用于定义简单的、能够在一行内表示的函数； &lt;函数名&gt; = lambda &lt;参数&gt; : &lt;表达式&gt; 等价于 def &lt;函数名&gt; (&lt;参数&gt;) : ​ &lt;函数体&gt; ​ return &lt;返回值&gt; 谨慎使用lambda函数： —lambda函数主要用作一些特定函数或方法的参数； —lambda函数有一些固定使用方式，建议逐步掌握； —一般情况，建议使用def定义的普通函数； 2、理解方法思维： 模块化思维：确定模块接口，封装功能； 规则化思维：抽象过程为规则，计算机自动执行； 化繁为简：将大功能变为小功能组合，分而治之； 3、代码复用与函数递归： 代码复用与模块化设计： 代码复用（把代码当成资源进行抽象）： —代码资源化：程序代码是一种用来表达计算的“资源”； —代码抽象化：使用函数等方法对代码赋予更高级别的定义； —代码复用：用一份代码在需要时可以被重复使用； 函数和对象是代码复用的两种主要形式； 模块化设计（分而治之）： —通过函数或对象封装将程序划分为模块及模块间的表达； —具体包括：主程序、子程序和子程序间关系； —分而治之：一种分而治之、分层抽象、体系化的设计思想； 模块内部紧耦合、模块之间松耦合； 函数递归（函数定义中调用自身的方式）：类似数学归纳法1） 递归是数学归纳法编程的一种体现； 两个关键特征：链条（计算过程存在递归链条）、基例（存在一个或多个不需要再次递归的基例）； 函数递归的调用过程： 递归的实现：函数 + 分支语句 —递归本身是一个函数，需要函数定义方式描述； —函数内部，采用分支语句对输入参数进行判断； —基例和链条，分别编写对应代码； 函数递归实例解析：字符串反转：s[::-1]，斐波那契数列，汉诺塔； 4、PyInstaller库（将.py源代码转换成无需源代码的可执行文件）使用：pyinstaller -F &lt;文件名.py&gt; 组合数据类型1、集合类型及操作： 集合类型定义：集合是多个元素的无序组合；—集合类型与数学中的集合概念一致；—集合元素之间无序，每个元素唯一，不存在相同元素；—集合元素不可更改，不能是可变数据类型；—集合用大括号{}表示，元素间用逗号分隔；—建立集合类型用{}或set();—建立空集合类型，必须使用set(); 集合操作符：6个操作符： 4 个增强操作符： 集合处理方法： 集合类型应用场景：包含关系比较、数据去重（集合类型所有元素无重复）； 2、序列类型及操作： 序列类型定义：序列是具有先后关系的一组元素；—序列是一维元素向量，元素类型可以不同；—类似数学元素序列：s0， S1, … , Sn-1;—元素间由序号引导，通过下标访问序列的特定元素；序列是一个基类类型（字符串类型、元组类型、列表类型）； 序列处理函数及方法：6个操作符： 5个函数和方法： 元组类型及操作：元组是序列类型的一种扩展；—元组是一种序列类型，一旦创建就不能被修改；—使用小括号（）或tuple（）创建，元素间用逗号，分隔；—可以使用或不使用小括号；元组继承序列类型的全部通用操作；元组因为创建后不能修改，因此没有特殊操作；使用或不使用小括号； 列表类型及操作：列表是序列类型的一种扩展，十分常用；—列表是一种序列类型，创建后可以随意被修改；—使用方括号[]或list（）创建，元素间用逗号，分隔；—可以使用或不使用小括号；方括号[]真正创建一个列表，赋值仅传递引用；列表类型操作函数和方法：序列类型应用场景： 元组用于元素不改变的应用场景，更多用于固定搭配场景（数据保护：如果不希望数据被程序所改变，转换成元组类型）； 列表更加灵活，它是常见的序列类型； 最主要作用：表示一组有序数据，进而操作它们； 3、字典类型及操作： 字典类型定义：理解”映射“：映射是一种键（索引）和值（数据）的对应；—字典类型是“映射”的体现；—键值对：键是数据索引的扩展；—字典是键值对的集合，键值对之间无序；—采用大括号{}和dict（）创建，键值对用冒号：表示；{&lt;键1&gt; : &lt;值1&gt;, &lt;键2&gt; : &lt;值2&gt;, …, &lt;键n&gt; : &lt;值ni&gt;}在字典变量中，通过键获得值：&lt;字典变量&gt; = {&lt;键1&gt; : &lt;值1&gt;, … , &lt;键n&gt; : &lt;值n&gt;}&lt;值&gt; = &lt;字典变量&gt; [&lt;键&gt;] &lt;字典变量&gt; [&lt;键&gt;] = &lt;值&gt;[] 用来向字典变量中索引或增加元素； 字典处理函数及方法： 字典类型应用场景：—映射无处不在，键值对无处不在；—例如：统计数据出现的次数，数据是键，次数是值；—最主要作用：表达键值对数据，进而操作它们； 4、jieba库（优秀的中文分词第三方库）的使用： jieba分词依靠中文词库：利用一个中文词库，确定汉字之间的关联概率；汉字间概率大的组成词组，形成分词结果；除了分词，用户还可以添加自定义的词组； 使用说明：精确模式（把文本精确的切分开，不存在冗余单词）；全模式（把文本中所有可能的词语都扫描出来，有冗余）；搜索引擎模式（在精确模式基础上，对长词再次切分）； 文件和数据格式化1、文件操作基础： 文件是数据的抽象和集合（展现形态：文本文件和二进制文件）； 文本文件：由单一特定编码组成的文件（txt、.py）； 二进制文件：直接由0和1组成，无统一的字符编码（.png、视频等）； 文件的打开关闭：打开-操作-关闭； 123#文件的打开 &lt;变量名&gt; = open(&lt;文件名&gt;, &lt;打开模式&gt;)#打开模式：只读（‘r’）、覆盖写（’w‘）、创建写（’x‘）、追加写（‘a’）、二进制文件模式（‘b’）、文本文件模式（‘t’）、与r/w/x/a一同使用，在原有功能基础上增加同时读写功能（‘+’）#文件的关闭 &lt;变量名&gt;.close() 文件的读取： 文件的写入： 2、自动化思维（数据和功能分离，数据驱动的自动进行）、接口化设计（格式化设计接口，清晰明了）； 3、一维数据格式化： 一维数据（由对等关系的有序或无序数据构成，采用线性方式组织）-对应列表、数组和集合等概念；二维数据（由多个一维数据构成，是一维数据的组合形式）-表格是典型的二维数据； 数据的操作周期：存储（存储格式）-表示（数据类型）-操作（操作方式）； 一维数据的表示： 如果数据间有序：使用列表类型； 如果数据间无序：使用集合类型； 一维数据的存储： 空格分隔（数据中不能存在空格）； 逗号分隔； 其他方式（使用其他符号或符号组合分隔，建议采用特殊符号）； 一维数据的处理： 将存储的数据读入程序 将程序表示的数据写入文件； 4、二维数据格式化： 二维数据的表示： 列表类型可以表达二维数据； 使用二维列表； CSV格式与二维数据的存储：CSV（Comma-Separated Values）数据存储格式： 每行一个一维数据，采用逗号分隔，无空行； 如果某个元素缺失，逗号仍要保留； 逗号为英文半角逗号，逗号与数据之间无额外空格； 二维数据的存储： 按行存或者按列存都可以，具体由程序决定； 一般索引习惯，先行后列； 二维数据的处理：for循环 + .split() 和 .join() 5、wordcloud库：是优秀的词云展示第三方库； 词云以词语为基本单位，更加直观和艺术的展示文本； 库基本使用： wordcloud.WordCloud()代表一个文本对应的词云； 可以根据文本中词语出现的频率等参数绘制词云； 绘制词云的形状、尺寸和颜色都可以设定； 配置参数、加载文本、输出文件； python的wordcloud默认字体不支持中文； 程序设计方法学 1、自顶向下的设计思维：分而治之；自底向上的执行思维：模块化集成； 2、计算思维：抽象问题的计算过程，利用计算机自动化求解； 3、用户体验：进度展示、异常处理等； 4、os库的基本使用： 123os.path.abspath(path)#返回path在当前系统中的绝对路径；os.getcwd()#返回程序的当前路径； 总结python基础语法： 基本数据类型：整数、浮点数、复数、字符串； 程序的控制结构：分支结构与异常处理、遍历循环、无限循环； 函数和代码复用：函数定义和使用、函数递归； 组合数据类型：集合类型、序列类型（元组和列表）、字典类型； 文件和数据格式化：文件的使用、一二维数据的表示存储和处理。 参考：MOOC北京理工大学嵩天老师课程笔记","comments":true,"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"SQL必知必会","date":"2019-03-22T06:22:36.000Z","path":"2019/03/22/SQL必知必会/","text":"SQL必知必会总结 About1、数据库是一个以某种有组织的方式存储的数据集合；表是一种结构化的文件，可用来存储某种特定类型的数据；模式 ：关于数据库和表的布局及特性的信息 ； 2、主键（primary key）：一列（或一组列），其值能够唯一标识表中每一行 ； 任意两行都不具有相同的主键值 ； 每一行都必须具有一个主键值（主键列不允许NULL值）； 主键列中的值不允许修改或更新； 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）； ​ 主键通常定义在表的一列上，但并不是必需这么做，也可以一起使用多个列作为主键。在使用多列作为主键时，上述条件必须应用到所有列， 所有列值的组合必须是唯一的（但单个列的值可以不唯一）； 3、SQL是结构化查询语言（Structured Query Language）的缩写，SQL是一种专门用来与数据库沟通的语言； 检索数据1、SQL语句不区分大小写 ； 检索单个列 SELECT prod_name FROM Products; 检索多个列 SELECT prod_id, prod_name, prod_price FROM Products; 检索所有列 SELECT * FROM Products; 检索不同的值 （ DISTINCT） SELECT DISTINCT vend_id FROM Products; 限制结果（LIMIT） SELECT prod_name FROM Products LIMIT 5; LIMIT 5 OFFSET 5 SELECT prod_name FROM Products LIMIT 5 OFFSET 5; 2、总结： 一般而言，除非你确实需要表中的每一列，否则最好别使用*通配符。虽然使用通配符能让你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能； 不能部分使用DISTINCT ：DISTINCT关键字作用于所有的列，不仅仅是跟在其后的那一列； LIMIT 5指示MySQL等DBMS返回不超过5行的数据，LIMIT 5 OFFSET 5 （LIMIT 5, 5）指示MySQL等DBMS返回从第5行起的5行数据。第一个数字是指从哪儿开始，第二个数字是检索的行数。第一个被检索的行是第0行，而不是第1行 ； 排序检索数据1、ORDER BY子句，根据需要排序检索出的数据； 排序数据 SELECT prod_name FROM Products ORDER BY prod_name; 按多个列排序 SELECT prod_id, prod_price, prod_name FROM Products ORDER BY prod_price, prod_name; 按列位置排序 SELECT prod_id, prod_price, prod_name FROM Products ORDER BY 2, 3; 指定排序方向 SELECT prod_id, prod_price, prod_name FROM Products ORDER BY prod_price DESC; 2、总结： ORDER BY子句的位置 ：在指定一条ORDER BY子句时，应该保证它是SELECT语句中最后一条子句。如果它不是最后的子句，将会出现错误消息； 通过非选择列进行排序： 通常，ORDER BY子句中使用的列将是为显示而选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的； 按列位置排序：指定的是选择列的相对位置而不是列名 ； 数据排序不限于升序排序（从A到Z），这只是默认的排序顺序。还可以使用ORDER BY子句进行降序（从Z到A）排序。为了进行降序排序，必须指定DESC关键字； 在多个列上降序排序： 如果想在多个列上进行降序排序，必须对每一列指定DESC关键字；（DESC是DESCENDING的缩写，与DESC相对的是ASC（或ASCENDING），升序是默认的 ）； 过滤数据1、WHERE子句指定搜索条件 ； 检查单个值 SELECT prod_name, prod_price FROM Products WHERE prod_price = 3.49; 检查单个值 SELECT prod_name, prod_price FROM Products WHERE prod_price &lt; 10; 不匹配检查 SELECT vend_id, prod_name FROM Products WHERE vend_id ！= ‘DLL01’; 范围值检查 SELECT prod_name, prod_price FROM Products WHERE prod_price BETWEEN 5 AND 10; 空值检查 SELECT prod_name FROM Products WHERE prod_price IS NULL; 2、总结： WHERE子句的位置 ：在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后，否则将会产生错误； 在使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用AND关键字分隔。BETWEEN匹配范围 中所有的值，包括指定的开始值和结束值； NULL和非匹配 ：通过过滤选择不包含指定值的所有行时，你可能希望返回含NULL值的行。但是这做不到。因为未知（unknown）有特殊的含义，数据库不知道它们是否匹配，所以在进行匹配过滤或非匹配过滤时，不会返回这些结果； 高级数据过滤1、为了进行更强的过滤控制，SQL允许给出多个WHERE子句。这些子句有两种使用方式，即以AND子句或OR子句的方式使用 ； 2、求值顺序 ： SQL（像多数语言一样）在处理OR操作符前，优先处理AND操作符。在WHERE子句中使用圆括号 ：任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符 ； 3、IN操作符 ：用来指定条件范围，范围中的每个条件都可以进行匹配。IN取一组由逗号分隔、括在圆括号中的合法值； 12345SELECT prod_name, prod_priceFROM ProductsWHERE vend_id IN ( &apos;DLL01&apos;, &apos;BRS01&apos; )ORDER BY prod_name;#IN操作符完成了与OR相同的功能 IN操作符优点为 ： 在有很多合法选项时，IN操作符的语法更清楚，更直观 ； 在与其他AND和OR操作符组合使用IN时，求值顺序更容易管理； IN操作符一般比一组OR操作符执行得更快； IN的最大优点是可以包含其他SELECT语句，能够更动态地建立WHERE子句； 4、NOT操作符：否定其后所跟的任何条件； 1234SELECT prod_nameFROM ProductsWHERE NOT vend_id = &apos;DLL01&apos;ORDER BY prod_name; 用通配符进行过滤1、LIKE操作符 ：为在搜索子句中使用通配符，必须使用LIKE操作符（后跟的搜索模式利用通配符匹配而不是简单的相等匹配进行比较 ） ；利用通配符，可以创建比较特定数据的搜索模式； 通配符搜索只能用于文本字段（串），非文本数据类型字段不能使用通配符搜索； 百分号（%）通配符 ：%表示任何字符出现任意次数； 除了能匹配一个或多个字符外，%还能匹配0个字符。%代表搜索模式中给定位置的0个、1个或多个字符。 注意NULL ：通配符%看起来像是可以匹配任何东西，但有个例外，这就是NULL； 123SELECT prod_id, prod_nameFROM ProductsWHERE prod_name LIKE &apos;Fish%&apos;; 下划线（_）通配符：只匹配单个字符，而不是多个字符； 通配符搜索一般比前面讨论的其他搜索要耗费更长的处理时间 ； —不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符； —在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的； —仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据； 创建计算字段1、计算字段：计算字段并不实际存在于数据库表中，计算字段是运行时在SELECT语句内创建的； 2、拼接字段 ： 拼接（concatenate）：将值联结到一起（将一个值附加到另一个值）构成单个值—concat()； 123SELECT CONCAT(TRIM(vend_name),&apos; (&apos;,TRIM(vend_country),&apos;)&apos;)#TRIM()---去掉左右两边空格FROM VendorsORDER BY vend_name; 别名（alias）是一个字段或值的替换名。别名用AS关键字赋予； 12345SELECT CONCAT(TRIM(vend_name),&apos; (&apos;,TRIM(vend_country),&apos;)&apos;)AS vend_titleFROM VendorsORDER BY vend_name; #计算字段之后跟了文本AS vend_title，它指示SQL创建一个包含指定计算结果的名为vend_title的计算字段，现在列名为vend_title，任何客户端应用都可以按名称引用这个列，就像它是一个实际的表列一样。 AS通常可选：AS关键字是可选的，不过最好使用它，这被视为一条最佳实践 ； 别名的其他用途：常见的用途包括在实际的表列名包含不合法的字符（如空格）时重新命名它，在原来的名字含混或容易误解时扩充它； 3、执行算术计算：计算字段的另一常见用途是对检索出的数据进行算术计算； 123SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_priceFROM OrderItemsWHERE order_num = 20008; 使用数据处理函数1、SQL也可以用函数来处理数据。函数一般是在数据上执行的，为数据的转换和处理提供了方便； 2、大多数SQL实现支持以下类型的函数： 用于处理文本字符串（如删除或填充值，转换值为大写或小写）的文本函数； 用于在数值数据上进行算术操作（如返回绝对值，进行代数运算）的数值函数； 用于处理日期和时间值并从这些值中提取特定成分（如返回两个日期之差，检查日期有效性）的日期和时间函数； 返回DBMS正使用的特殊信息（如返回用户登录信息）的系统函数； 文本处理函数 SELECT vend_name, UPPER(vend_name) AS vend_name_upcase 日期和时间处理函数 SELECT order_num FROM Orders WHERE YEAR(order_date) = 2012; 数值处理函数 SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法，SOUNDEX考虑了类似的发音字符和音节，使得能对字符串进行发音比较而不是字母比较 ； 123SELECT cust_name, cust_contactFROM CustomersWHERE SOUNDEX(cust_contact) = SOUNDEX(&apos;Michael Green&apos;) 汇总数据1、聚集函数：汇总数据而不用把它们实际检索出来，为此SQL提供了专门的函数。使用这些函数，SQL查询可用于检索数据，以便分析和报表生成； 聚集函数（aggregate function） 对某些行运行的函数，计算并返回一个值 ； AVG（）：返回某列的平均值—通过对表中行数计数并计算其列值之和，求得该列的平均值； 只用于单个列：AVG()只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个AVG()函数。 12SELECT AVG(prod_price) AS avg_priceFROM Products; COUNT（）：确定表中行的数目或符合特定条件的行的数目； COUNT()函数有两种使用方式： 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值； 使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值； 123456#利用COUNT(*)对所有行计数，不管行中各列有什么值SELECT COUNT(*) AS num_custFROM Customers;#COUNT(cust_email)对cust_email列中有值的行进行计数SELECT COUNT(cust_email) AS num_custFROM Customers; MAX（）：返回某列的最大值，要求指定列名 ； 123#MAX()函数忽略列值为NULL的行SELECT MAX(prod_price) AS max_priceFROM Products; MIN（）：返回某列的最小值，要求指定列名 ； 123#MIN()函数忽略列值为NULL的行SELECT MIN(prod_price) AS min_priceFROM Products; SUM（）：返回指定列值的和（总计）； 12345678#SUM()函数忽略列值为NULL的行SELECT SUM(quantity) AS items_orderedFROM OrderItemsWHERE order_num = 20005;#SUM()也可以用来合计计算值SELECT SUM(item_price*quantity) AS total_priceFROM OrderItemsWHERE order_num = 20005; 2、聚集不同值：只包含不同的值，指定DISTINCT参数； 1234SELECT AVG(DISTINCT prod_price) AS avg_priceFROM ProductsWHERE vend_id = &apos;DLL01&apos;;#DISTINCT不能用于COUNT(*)，DISTINCT必须使用列名 3、组合聚集函数： 12345SELECT COUNT(*) AS num_items,MIN(prod_price) AS price_min,MAX(prod_price) AS price_max,AVG(prod_price) AS price_avgFROM Products; 分组数据1、数据分组 ：使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算； 2、创建分组：使用SELECT语句的GROUP BY子句建立的； 123SELECT vend_id, COUNT(*) AS num_prodsFROM ProductsGROUP BY vend_id; GROUP BY子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组； 如果在GROUP BY子句中嵌套了分组，数据将在最后指定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）； GROUP BY子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子 句中指定相同的表达式。不能使用别名； 大多数SQL实现不允许GROUP BY列带有长度可变的数据类型（如文本或备注型字段）； 除聚集计算语句外，SELECT语句中的每一列都必须在GROUP BY子句中给出 ； 如果分组列中包含具有NULL值的行，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组； GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前 ； 3、过滤分组 ：HAVING子句 ，WHERE过滤行，而HAVING过滤分组； 1234SELECT cust_id, COUNT(*) AS ordersFROM OrdersGROUP BY cust_idHAVING COUNT(*) &gt;= 2; HAVING和WHERE的差别：WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤； 123456#第一行是使用了聚集函数的基本SELECT语句，WHERE子句过滤所有prod_price至少为4的行，然后按vend_id分组数据，HAVING子句过滤计数为2或2以上的分组。SELECT vend_id, COUNT(*) AS num_prodFROM ProductsWHERE prod_price &gt;= 4GROUP BY vend_idHAVING COUNT(*) &gt;= 2 使用HAVING和WHERE：HAVING与WHERE非常类似，如果不指定GROUP BY，则大多数DBMS会同等对待它们。不过，使用HAVING时应该结合GROUP BY子句，而WHERE子句用于标准的行级过滤； 4、分组和排序：GROUP BY和ORDER BY经常完成相同的工作，但它们非常不同； ORDER BY GROUP BY 对产生的输出排序 对行分组，但输出可能不是分组的顺序 任意列都可以使用（甚至非选择的列也可以使用） 只可能使用选择列表达式，而且必须使用每个选择列表达式 不一定需要 如果与聚集函数一起使用列（或表达式），则必须使用 不要忘记ORDER BY：一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据； 12345SELECT order_num, COUNT(*) AS itemsFROM OrderItemsGROUP BY order_numHAVING COUNT(*) &gt;= 3ORDER BY items, order_num; 5、SELECT子句顺序： 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 使用子查询1、子查询：嵌套在其他查询中的查询； 2、利用子查询进行过滤： 1234567SELECT cust_name, cust_contactFROM CustomersWHERE cust_id IN (SELECT cust_idFROM OrdersWHERE order_num IN (SELECT order_numFROM OrderItemsWHERE prod_id = &apos;RGAN01&apos;)); 在WHERE子句中使用子查询能够编写出功能很强且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多的子查询； 只能是单列：作为子查询的SELECT语句只能查询单个列。企图检索多个列将返回错误； 子查询和性能：这里给出的代码有效，并且获得了所需的结果。但是，使用子查询并不总是执行这类数据检索的最有效方法； 3、作为计算字段使用子查询：使用子查询的另一方法是创建计算字段； 12345678#不是解决这种数据检索的最有效方法SELECT cust_name,cust_state,(SELECT COUNT(*)FROM OrdersWHERE Orders.cust_id = Customers.cust_id) AS ordersFROM CustomersORDER BY cust_name; 联结表1、联结：SQL最强大的功能之一就是能在数据查询的执行中联结（join）表。联结是利用SQL的SELECT能执行的最重要的操作； 关系表：相同的数据出现多次决不是一件好事，这是关系数据库设计的基础。关系表的设计就是要把信息分解成多个表，一类数据一个表。各表通过某些共同的值互相关联（所以才叫关系数据库）； 关系数据可以有效地存储，方便地处理。因此，关系数据库的可伸缩性远比非关系数据库要好。可伸缩（scale）： 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称为可伸缩性好（scale well）； 如果数据存储在多个表中，怎样用一条SELECT语句就检索出数据呢？（使用联结）； 联结是一种机制，用来在一条SELECT语句中关联表，因此称为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行 ； 2、创建联结：指定要联结的所有表以及关联它们的方式即可 ； 123SELECT vend_name, prod_name, prod_priceFROM Vendors, ProductsWHERE Vendors.vend_id = Products.vend_id; 3、WHERE子句的重要性：在联结两个表时，实际要做的是将第一个表中的每一行与第二个表中的每一行配对。WHERE子句作为过滤条件，只包含那些匹配给定条件（这里是联结条件）的行。没有WHERE子句， 第一个表中的每一行将与第二个表中的每一行配对，而不管它们逻辑上是否能配在一起； 笛卡儿积（cartesian product）：由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数； 123SELECT vend_name, prod_name, prod_priceFROM Vendors, Products;#要保证所有联结都有WHERE子句，否则DBMS将返回比想要的数据多得多的数据 内联结（inner join）：目前为止使用的联结称为等值联结（equijoin），它基于两个表之间的相等测试，这种联结也称为内联结； 123SELECT vend_name, prod_name, prod_priceFROM Vendors INNER JOIN ProductsON Vendors.vend_id = Products.vend_id; 4、联结多个表 ：SQL不限制一条SELECT语句中可以联结的表的数目。创建联结的基本规则也相同，首先列出所有表，然后定义表之间的关系； 12345SELECT prod_name, vend_name, prod_price, quantityFROM OrderItems, Products, VendorsWHERE Products.vend_id = Vendors.vend_idAND OrderItems.prod_id = Products.prod_idAND order_num = 20007; 性能考虑：DBMS在运行时关联指定的每个表，以处理联结。这种处理可能非常耗费资源，因此应该注意，不要联结不必要的表。联结的表越多，性能下降越厉害； 执行任一给定的SQL操作一般不止一种方法。很少有绝对正确或绝对错误的方法。性能可能会受操作类型、所使用的DBMS、表中数据量、是否存在索引或键等条件的影响。 创建高级联结1、使用表别名：SQL除了可以对列名和计算字段使用别名，还允许给表名起别名； 缩短SQL语句； 允许在一条SELECT语句中多次使用相同的表； 1234567#表别名不仅能用于WHERE子句，还可以用于SELECT的列表、ORDER BY子句以及其他语句部分#表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户端。SELECT cust_name, cust_contactFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id = O.cust_idAND OI.order_num = O.order_numAND prod_id = &apos;RGAN01&apos;; 2、使用不同类型的联结： 自联结： 12345#许多DBMS处理联结远比处理子查询快得多SELECT c1.cust_id, c1.cust_name, c1.cust_contactFROM Customers AS c1, Customers AS c2WHERE c1.cust_name = c2.cust_nameAND c2.cust_contact = &apos;Jim Jones&apos;; 自然联结：排除多次出现，使每一列只返回一次 ； 123456SELECT C.*, O.order_num, O.order_date,OI.prod_id, OI.quantity, OI.item_priceFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id = O.cust_idAND OI.order_num = O.order_numAND prod_id = &apos;RGAN01&apos;; 外联结：联结包含了那些在相关表中没有关联行的行； 1234#在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）SELECT Customers.cust_id, Orders.order_numFROM Customers LEFT OUTER JOIN OrdersON Customers.cust_id = Orders.cust_id; 3、 使用带聚集函数的联结 ： 1234567891011SELECT Customers.cust_id,COUNT(Orders.order_num) AS num_ordFROM Customers INNER JOIN OrdersON Customers.cust_id = Orders.cust_idGROUP BY Customers.cust_id;#使用左外部联结来包含所有顾客，甚至包含那些没有任何订单的顾客SELECT Customers.cust_id,COUNT(Orders.order_num) AS num_ordFROM Customers LEFT OUTER JOIN OrdersON Customers.cust_id = Orders.cust_idGROUP BY Customers.cust_id; 4、使用联结和联结条件：联结及其使用的要点； 注意所使用的联结类型。一般我们使用内联结，但使用外联结也有效； 保证使用正确的联结条件（不管采用哪种语法），否则会返回不正确的数据；。 应该总是提供联结条件，否则会得出笛卡儿积； 在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前分别测试每个联结。这会使故障排除更为简单； 组合查询1、组合查询：多数SQL查询只包含从一个或多个表中返回数据的单条SELECT语句。但是，SQL也允许执行多个查询（多条SELECT语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）； 主要有两种情况需要使用组合查询： 在一个查询中从不同的表返回结构数据； 对一个表执行多个查询，按一个查询返回数据； 2、创建组合查询：可用UNION操作符来组合数条SQL查询。利用UNION，可给出多条SELECT语句，将它们的结果组合成一个结果集； 使用UNION ：给出每条SELECT语句，在各条语句之间放上关键字UNION ； 1234567SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN (&apos;IL&apos;,&apos;IN&apos;,&apos;MI&apos;)UNIONSELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_name = &apos;Fun4All&apos;; UNION规则： UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合四条SELECT语句，将要使用三个UNION关键字）； UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）； 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）； 包含或取消重复的行：使用UNION时，重复的行会被自动取消；如果想返回所有的匹配行，可使用UNION ALL而不是UNION； 对组合查询结果排序：在用UNION组合查询时，只能使用一条ORDER BY子句，它必须位于最后一条SELECT语句之后； 12345678SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN (&apos;IL&apos;,&apos;IN&apos;,&apos;MI&apos;)UNIONSELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_name = &apos;Fun4All&apos;ORDER BY cust_name, cust_contact; 插入数据1、数据插入：INSERT用来将行插入（或添加）到数据库表，插入有几种方式 ； 插入完整的行； 1234567#各列必须以它们在表定义中出现的次序填充，不安全，应该尽量避免使用INSERT INTO CustomersVALUES(&apos;1000000006&apos;,&apos;Toy Land&apos;,&apos;123 Any Street&apos;,&apos;New York&apos;,&apos;NY&apos;,&apos;11111&apos;,&apos;USA&apos;,NULL,NULL); #安全INSERT INTO Customers(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country, cust_contact,cust_email)VALUES(&apos;1000000006&apos;,&apos;Toy Land&apos;,&apos;123 Any Street&apos;,&apos;New York&apos;,&apos;NY&apos;,&apos;11111&apos;,&apos;USA&apos;,NULL,NULL); 插入行的一部分：使用这种语法，还可以省略列，这表示可以只给某些列提供值，给其他列不提供值； 12INSERT INTO Customers(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)VALUES(&apos;1000000006&apos;,&apos;Toy Land&apos;,&apos;123 Any Street&apos;,&apos;New York&apos;,&apos;NY&apos;,&apos;11111&apos;,&apos;USA&apos;); 如果表的定义允许，则可以在INSERT操作中省略某些列。省略的列必须满足以下某个条件： 该列定义为允许NULL值（无值或空值）； 在表定义中给出默认值。这表示如果不给出值，将使用默认值 ； 插入检索出的数据：将SELECT语句的结果插入表中，这就是所谓的INSERT SELECT。顾名思义，它是由一条INSERT语句和一条SELECT语句组成的； 1234567#这条语句将插入多少行呢？这依赖于CustNew表有多少行INSERT INTO Customers( cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state, cust_zip,cust_country)SELECT cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state, cust_zip,cust_countryFROM CustNew; INSERT通常只插入一行。要插入多行，必须执行多个INSERT语句。INSERT SELECT是个例外，它可以用一条INSERT插入多行，不管SELECT语句返回多少行，都将被INSERT插入； 2、从一个表复制到另一个表 ：使用SELECT INTO语句。与INSERT SELECT将数据添加到一个已经存在的表不同，SELECT INTO将数据复制到一个新表（有的DBMS可以覆盖已经存在的表，这依赖于所使用的具体DBMS）； INSERT SELECT与SELECT INTO：它们之间的一个重要差别是前者导出数据，而后者导入数据 ； 123#这条语句创建一个名为CustCopy的新表，并把Customers表的整个内容复制到新表中。CREATE TABLE CustCopy ASSELECT * FROM Customers; 更新和删除数据1、更新数据：更新（修改）表中的数据，可以使用UPDATE语句。有两种使用UPDATE的方式； 基本的UPDATE语句由三部分组成：要更新的表 、列名和它们的新值、确定要更新哪些行的过滤条件； 更新表中的特定行； 123456UPDATE CustomersSET cust_contact = &apos;Sam Roberts&apos;,cust_email = &apos;sam@toyland.com&apos;WHERE cust_id = &apos;1000000006&apos;#要删除某个列的值，可设置它为NULL（假如表定义允许NULL值）#其中NULL用来去除cust_email列中的值。这与保存空字符串很不同（空字符串用&apos;&apos;表示，是一个值），而NULL表示没有值 更新表中的所有行；（不加where子句） 2、删除数据 ： 从一个表中删除（去掉）数据，使用DELETE语句。有两种使用DELETE的方式； 从表中删除特定的行； 123#DELETE不需要列名或通配符。DELETE删除整行而不是删除列DELETE FROM CustomersWHERE cust_id = &apos;1000000006&apos;; 删除表的内容而不是表：DELETE语句从表中删除行，甚至是删除表中所有行。但是，DELETE不删除表本身； 更快的删除：如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，而速度更快（因为不记录数据的变动）； 从表中删除所有行； 3、更新和删除的指导原则 ： 除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句 ； 保证每个表都有主键（如果忘记这个内容，请参阅第12课），尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）； 在UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确； 创建和操纵表1、创建表：使用SQL的CREATE TABLE语句 ； 表创建基础： 12345678CREATE TABLE Products(prod_id CHAR(10) NOT NULL,vend_id CHAR(10) NOT NULL,prod_name CHAR(254) NOT NULL,prod_price DECIMAL(8,2) NOT NULL,prod_desc VARCHAR(1000) NULL); 使用NULL值：主键和NULL值— 主键是其值唯一标识表中每一行的列。只有不允许NULL值的列可作为主键，允许NULL值的列不能作为唯一标识 ； 指定默认值：用关键字DEFAULT指定； 12345678CREATE TABLE OrderItems(order_num INTEGER NOT NULL,order_item INTEGER NOT NULL,prod_id CHAR(10) NOT NULL,quantity INTEGER NOT NULL DEFAULT 1,item_price DECIMAL(8,2) NOT NULL); 2、更新表：使用ALTER TABLE语句； 1234ALTER TABLE VendorsADD vend_phone CHAR(20);ALTER TABLE VendorsDROP COLUMN vend_phone; 3、删除表：使用DROP TABLE语句； 1DROP TABLE CustCopy; 4、重命名表 ：使用RENAME语句，要求指定旧表名和新表名； 使用视图1、视图：视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询； 视图的一些常见应用 ： 重用SQL语句； 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道其基本查询细节； 使用表的一部分而不是整个表； 保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限 ； 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据； 视图仅仅是用来查看存储在别处数据的一种设施。视图本身不包含数据，因此返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据； 视图的规则和限制： 与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）； 对于可以创建的视图数目没有限制； 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。所允许的嵌套层数在不同的DBMS中有所不同（嵌套视图可能会严重降低查询的性能，因此在产品环境中使用之前，应该对其进行全面测试）； 视图不能索引，也不能有关联的触发器或默认值； 2、 创建视图：用CREATE VIEW语句来创建 ，只能用于创建不存在的视图； ​ 删除视图，可以使用DROP语句，其语法为DROP VIEW viewname；覆盖（或更新）视图，必须先删除它，然后再重新创建； 利用视图简化复杂的联结 ： 123456#创建一个名为ProductCustomers的视图，它联结三个表CREATE VIEW ProductCustomers ASSELECT cust_name, cust_contact, prod_idFROM Customers, Orders, OrderItemsWHERE Customers.cust_id = Orders.cust_idAND OrderItems.order_num = Orders.order_num; 用视图重新格式化检索出的数据： 1234CREATE VIEW VendorLocations AS SELECT CONCAT(vend_name,&apos;(&apos;,RTRIM(vend_country),&apos;)&apos;) AS vend_titleFROM Vendors 用视图过滤不想要的数据 ： 1234CREATE VIEW CustomerEMailList ASSELECT cust_id, cust_name, cust_emailFROM CustomersWHERE cust_email IS NOT NULL; 使用视图与计算字段： 1234567CREATE VIEW OrderItemsExpanded ASSELECT order_num,prod_id,quantity,item_price,quantity*item_price AS expanded_priceFROM OrderItems; ​ 视图可极大地简化复杂数据的处理； 总结：视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种封装SELECT语句的层次，可用来简化数据处理，重新格式化或保护基础数据； 使用存储过程1、存储过程 ：存储过程就是为以后使用而保存的一条或多条SQL语句。可将其视为批文件，虽然它们的作用不仅限于批处理； 2、为什么要使用存储过程： 通过把处理封装在一个易用的单元中，可以简化复杂的操作； 由于不要求反复建立一系列处理步骤，因而保证了数据的一致性。如果所有开发人员和应用程序都使用同一存储过程，则所使用的代码都是相同的；（防止错误） 简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，那么只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化 ；（安全性） 3、执行存储过程 ：EXECUTE，EXECUTE接受存储过程名和需要传递给它的任何参数； 12345#执行一个名为AddNewProduct的存储过程，将一个新产品添加到Products表中EXECUTE AddNewProduct( &apos;JTS01&apos;,&apos;Stuffed Eiffel Tower&apos;,6.49,&apos;Plush stuffed toy with the text LaTour Eiffel in red white and blue&apos; ); 存储过程所完成的工作： 验证传递的数据，保证所有4个参数都有值 ； 生成用作主键的唯一ID； 将新产品插入Products表，在合适的列中存储生成的主键和传递的数据； 4、创建存储过程：CREATE PROCEDURE； 管理事务处理1、事务处理（transaction processing）：通过确保成批的SQL操作要么完全执行，要么完全不执行，来维护数据库的完整性； 事务处理是一种机制，用来管理必须成批执行的SQL操作，保证数据库不包含不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止，它们要么完全执行，要么完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表；如果发生错误，则进行回退（撤销），将数据库恢复到某个已知且安全的状态； 2、使用事务处理时，有几个反复出现的关键词： 事务（transaction）指一组SQL语句； 回退（rollback）指撤销指定SQL语句的过程； 提交（commit）指将未存储的SQL语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），可以对它发布回退（与回退整个事务处理不同）； 事务处理用来管理INSERT、UPDATE和DELETE语句。不能回退SELECT语句（回退SELECT语句也没有必要），也不能回退CREATE或DROP操作。事务处理中可以使用这些语句，但进行回退时，这些操作也不撤销； 3、控制事务处理：管理事务的关键在于将SQL语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退； 1START TRANSACTION COMMITT用于保存更改，ROLLBACK用于撤销； 使用ROLLBACK； 使用COMMIT； 使用保留点：要支持回退部分事务，必须在事务处理块中的合适位置放置占位符。这样，如果需要回退，可以回退到某个占位符。 在SQL中，这些占位符称为保留点； 创建占位符，可使用SAVEPOINT语句，SAVEPOINT delete1； 总结：保留点越多越好—可以在SQL代码中设置任意多的保留点，越多越好。为什么呢？因为保留点越多，你就越能灵活地进行回退； 使用游标1、游标（cursor）：有时，需要在检索出来的行中前进或后退一行或多行，这就是游标的用途所在； 游标（cursor）是一个存储在DBMS服务器上的数据库查询， 它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据； 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改； 2、使用游标： 在使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句和游标选项 ； 一旦声明，就必须打开游标以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来； 对于填有数据的游标，根据需要取出（检索）各行； 在结束游标使用时，必须关闭游标，可能的话，释放游标（依赖于具体的DBMS）； 3、创建游标 ：使用DECLARE语句创建游标； 1234DECLARE CustCursor CURSORFORSELECT * FROM CustomersWHERE cust_email IS NULL 4、使用游标：使用OPEN CURSOR语句打开游标 ； 1OPEN CURSOR CustCursor 在处理OPEN CURSOR语句时，执行查询，存储检索出的数据以供浏览和滚动； 现在可以用FETCH语句访问游标数据了。FETCH指出要检索哪些行，从何处检索它们以及将它们放于何处（如变量名）； 5、关闭游标：CLOSE CustCursor； 高级SQL特性1、高级数据处理特性：约束、索引和触发器； 2、约束（constraint）：管理如何插入或处理数据库数据的规则； 主键： 1234567CREATE TABLE Vendors(vend_id CHAR(10) NOT NULL PRIMARY KEY,vend_name CHAR(50) NOT NULL);ALTER TABLE VendorsADD CONSTRAINT PRIMARY KEY (vend_id); 外键 ： 12345678910#外键有助防止意外删除CREATE TABLE Orders(order_num INTEGER NOT NULL PRIMARY KEY,order_date DATETIME NOT NULL,cust_id CHAR(10) NOT NULL REFERENCES Customers(cust_id));ALTER TABLE OrdersADD CONSTRAINTFOREIGN KEY (cust_id) REFERENCES Customers (cust_id); 唯一约束（UNIQUE）：唯一约束用来保证一列（或一组列）中的数据是唯一的。它们类似于主键，但存在以下重要区别： 表可包含多个唯一约束，但每个表只允许一个主键； 唯一约束列可包含NULL值； 唯一约束列可修改或更新； 唯一约束列的值可重复使用； 与主键不一样，唯一约束不能用来定义外键； 检查约束：用来保证一列（或一组列）中的数据满足一组指定的条件； 1234567#对OrderItems表施加了检查约束，它保证所有物品的数量大于0CREATE TABLE OrderItems(prod_id CHAR(10) NOT NULL,quantity INTEGER NOT NULL CHECK (quantity &gt; 0)); ADD CONSTRAINT CHECK (gender LIKE &apos;[MF]&apos;) 3、索引： 用来排序数据以加快搜索和排序操作的速度，在一个或多个列上定义索引，使DBMS保存其内容的一个排过序的列表，在定义了索引后，DBMS以使用书的索引类似的方法使用它。DBMS搜索排过序的索引，找出匹配的位置，然后检索这些行 ； 索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。在执行这些操作时，DBMS必须动态地更新索引； 索引数据可能要占用大量的存储空间； 并非所有数据都适合做索引。取值不多的数据（如州）不如具有更多可能值的数据（如姓或名），能通过索引得到那么多的好处； 索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能适合做索引； 可以在索引中定义多个列（例如，州加上城市）。这样的索引仅在以州加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处； 索引用CREATE INDEX语句创建，索引必须唯一命名 ： 123#在Products表的产品名列上创建一个简单的索引CREATE INDEX prod_name_indON PRODUCTS (prod_name); 检查索引：索引的效率随表数据的增加或改变而变化。许多数据库管理员发现，过去创建的某个理想的索引经过几个月的数据处理后可能变得不再理想 了。最好定期检查索引，并根据需要对索引进行调整； 4、触发器：是特殊的存储过程，它在特定的数据库活动发生时自动执行。触发器可以与特定表上的INSERT、UPDATE和DELETE操作（或组合）相关联； 与存储过程不一样（存储过程只是简单的存储SQL语句），触发器与单个的表相关联。与Orders表上的INSERT操作相关联的触发器只在Orders表中插入行时执行。类似地，Customers表上的INSERT和UPDATE操作的触发器只在表上出现这些操作时执行； 触发器的一些常见用途： 保证数据一致。例如，在INSERT或UPDATE操作中将所有州名转换为大写； 基于某个表的变动在其他表上执行活动。例如，每当更新或删除一行时将审计跟踪记录写入某个日志表； 进行额外的验证并根据需要回退数据。例如，保证某个顾客的可用资金不超限定，如果已经超出，则阻塞插入； 计算列的值或更新时间戳； 123456789#创建一个触发器，它对所有INSERT和UPDATE操作，将Customers表中的cust_state列转换为大写CREATE TRIGGER customer_stateAFTER INSERT OR UPDATEFOR EACH ROWBEGINUPDATE CustomersSET cust_state = Upper(cust_state)WHERE Customers.cust_id = :OLD.cust_idEND; 约束比触发器更快：一般来说，约束的处理比触发器快，因此在可能的时候，应该尽量使用约束； 5、数据库安全：任何安全系统的基础都是用户授权和身份确认。这是一种处理，通过这种处理对用户进行确认，保证他是有权用户，允许执行他要执行的操作。有的DBMS为此结合使用了操作系统的安全措施，而有的维护自己的用户及密码列表，还有一些结合使用外部目录服务服务器； 一般说来，需要保护的操作有： 对数据库管理功能（创建表、更改或删除已存在的表等）的访问； 对特定数据库或表的访问； 访问的类型（只读、对特定列的访问等）； 仅通过视图或存储过程对表进行访问； 创建多层次的安全措施，从而允许多种基于登录的访问和控制 ； 限制管理用户账号的能力； 安全性使用SQL的GRANT和REVOKE语句来管理，不过，大多数DBMS提供了交互式的管理实用程序，这些实用程序在内部使用GRANT和REVOKE语句 ； 总结：约束是实施引用完整性的重要部分，索引可改善数据检索的性能，触发器可以用来执行运行前后的处理，安全选项可用来管理数据访问。 脚本链接：https://pan.baidu.com/s/1BM1Z68UuLp73cLIrqjvfjw 提取码：5cer ​ ​ ​ ​ ​ ​","comments":true,"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"设计模式-观察者模式","date":"2019-03-18T02:08:53.000Z","path":"2019/03/18/设计模式-观察者模式/","text":"简单的说模式就是一种惯性的思维方式，用于解决同一类问题。 About模式：我们处理大量问题时，在很多不同的问题中重复出现的一种性质，它使得我们可以使用一种方法来描述问题实质并用本质上相同，但细节永不会重复的方法去解决，这种性质就叫模式。简单的说模式就是一种惯性的思维方式，用于解决同一类问题； 观察者模式（Observer）：何谓观察者模式？观察者模式定义了对象之间的一对多依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。 在这里，发生改变的对象称之为观察目标，而被通知的对象称之为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，所以么可以根据需要增加和删除观察者，使得系统更易于扩展。 所以观察者提供了一种对象设计，让主题和观察者之间以松耦合的方式结合。 简单例子观察者模式具备：事件的源、事件对象、事件处理对象； 以西游记为例，唐僧就是事件源，孙悟空、猪八戒、沙僧都是事件处理对象，事件对象包含有关事件和事件的源信息（就是记录唐僧发生事件的信息）； 先写事件对象类： TangEvent（记录唐僧发生事件的信息）： 1234567891011public class TangEvent &#123; private String eventStr; public TangEvent() &#123; &#125; public TangEvent(String eventStr) &#123; this.eventStr = eventStr; &#125; public String getEventStr() &#123; return eventStr; &#125;&#125; 接着写可以处理唐僧发生事件的接口类（Apprentice），只要是唐僧的徒弟就可以处理唐僧发生的事件，徒弟的功能就是观察唐僧看是否有事件需要处理： 123public interface Apprentice &#123; public void lookTS(TangEvent e);&#125; 再写可以处理事件的具体徒弟类，实现徒弟接口： 孙悟空实现类： 12345678910public class SunApprentice implements Apprentice &#123; @Override public void lookTS(TangEvent e) &#123; if(\"白骨精\".equals(e.getEventStr())) &#123; System.out.println(\"三打白骨精!\"); &#125; else if(\"女儿国王\".equals(e.getEventStr())) &#123; System.out.println(\"全凭师父定力！\"); &#125; &#125;&#125; 猪八戒实现类： 12345678910public class ZhuApprentice implements Apprentice &#123; @Override public void lookTS(TangEvent e) &#123; if(\"白骨精\".equals(e.getEventStr())) &#123; System.out.println(\"白骨精不是妖怪!\"); &#125; else if(\"女儿国王\".equals(e.getEventStr())) &#123; System.out.println(\"将师父留在女儿国吧！\"); &#125; &#125;&#125; 沙僧实现类： 12345678910public class ShaApprentice implements Apprentice &#123; @Override public void lookTS(TangEvent e) &#123; if(\"白骨精\".equals(e.getEventStr())) &#123; System.out.println(\"千万别误伤好人!\"); &#125; else if(\"女儿国王\".equals(e.getEventStr())) &#123; System.out.println(\"担心师父在女儿国王那有事！\"); &#125; &#125;&#125; 写事件源类（三要素：私有的监听者列表，公有的向监听者列表添加监听者的方法，公有的发生事情的方法）： 12345678910111213public class Tang &#123; private List&lt;Apprentice&gt; list = new ArrayList&lt;Apprentice&gt;();//私有的监听者列表 public void addTangListener(Apprentice apprentice) &#123;//公有的向监听者列表添加监听者的方法 this.list.add(apprentice); &#125; public void tangAction(String s) &#123;//公有的发生事情的方法 TangEvent tangEvent = new TangEvent(s); for(int i = 0; i &lt; this.list.size(); i++) &#123; Apprentice apprentice = this.list.get(i); apprentice.lookTS(tangEvent); &#125; &#125;&#125; 最后写一个Run类，事件源添加监听者实现类的实例： 1234567891011121314public class Run &#123; public static void main(String[] args) &#123; Tang tang = new Tang(); SunApprentice sun = new SunApprentice(); ZhuApprentice zhu = new ZhuApprentice(); ShaApprentice sha = new ShaApprentice(); //事件源加监听者实现类的实例 tang.addTangListener(sun); tang.addTangListener(zhu); tang.addTangListener(sha); tang.tangAction(\"白骨精\"); tang.tangAction(\"女儿国王\"); &#125;&#125; 至此，一个简单的观察者模式小例子完成。其实，在java中，我们不必像上面那样全都需要自己手动写，最后那个Run才需要我们自己完成。 事件源添加监听者接口实例四种方法： 1、自己加自己 2、自己加别人（实现接口） 3、自己加别人（适配器） 4、参数匿名类（适配器） 以Java Swing为例，先看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class MyFrame extends JFrame implements MouseListener &#123; private JPanel bodyPanel = null; private JButton b1 = null; private JButton b2 = null; private JButton b3 = null; private JButton b4 = null; private void init() &#123; this.bodyPanel = (JPanel)this.getContentPane(); this.bodyPanel.setLayout(new GridLayout(2, 2)); this.b1 = new JButton(\"b1\"); this.b1.addMouseListener(this);//自己加自己 this.bodyPanel.add(this.b1); this.b2 = new JButton(\"b2\"); MyListener1 myListener1 = new MyListener1(); this.b2.addMouseListener(myListener1);//自己加别人（实现接口） this.bodyPanel.add(this.b2); this.b3 = new JButton(\"b3\"); this.b3.addMouseListener(new MyListener2());//自己加别人（适配器） this.bodyPanel.add(this.b3); this.b4 = new JButton(\"b4\"); this.b4.addMouseListener(new MouseAdapter() &#123;//参数匿名类（适配器） public void mouseEntered(MouseEvent e) &#123; b4.setBackground(Color.BLACK); &#125; @Override public void mouseExited(MouseEvent e) &#123; b4.setBackground(Color.ORANGE); &#125; &#125;); this.bodyPanel.add(this.b4); this.setBounds(10, 10, 400, 400); this.setTitle(\"监听者模式\"); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public MyFrame() &#123; this.init(); &#125; public static void main(String[] args) &#123; MyFrame frame = new MyFrame(); frame.setVisible(true); &#125; @Override public void mouseClicked(MouseEvent e) &#123; &#125; @Override public void mousePressed(MouseEvent e) &#123; &#125; @Override public void mouseReleased(MouseEvent e) &#123; &#125; @Override public void mouseEntered(MouseEvent e) &#123; if(e.getSource() == this.b1) &#123; this.b1.setBackground(Color.RED); this.b4.setBackground(Color.BLUE); &#125; &#125; @Override public void mouseExited(MouseEvent e) &#123; if(e.getSource() == this.b1) &#123; this.b1.setBackground(Color.BLUE); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728public class MyListener1 implements MouseListener &#123; @Override public void mouseClicked(MouseEvent e) &#123; &#125; @Override public void mousePressed(MouseEvent e) &#123; &#125; @Override public void mouseReleased(MouseEvent e) &#123; &#125; @Override public void mouseEntered(MouseEvent e) &#123; JButton b2 = (JButton)e.getSource(); b2.setBackground(Color.BLUE); &#125; @Override public void mouseExited(MouseEvent e) &#123; JButton b2 = (JButton)e.getSource(); b2.setBackground(Color.GREEN); &#125;&#125; 12345678910111213public class MyListener2 extends MouseAdapter &#123; @Override public void mouseEntered(MouseEvent e) &#123; JButton b3 = (JButton)e.getSource(); b3.setBackground(Color.YELLOW); &#125; @Override public void mouseExited(MouseEvent e) &#123; JButton b3 = (JButton)e.getSource(); b3.setBackground(Color.PINK); &#125;&#125; 从代码也可以看出，适配器里面其实是一些空实现的方法，可以避免代码出现过多的空方法。 参考文章：http://cmsblogs.com/?p=3396#7Observer","comments":true,"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"零基础入门C语言","date":"2019-03-09T02:31:51.000Z","path":"2019/03/09/C语言入门/","text":"轻松入门C语言，通俗易懂的小例子理解C语言的三大结构 About面向对象和面向过程 面向过程就是人看待事物的眼光和思想，关注于步骤； 面向对象是一种对现实世界理解和抽象的方法； 面向过程—&gt;怎么做、面向对象—&gt;谁在做； 学习C语言的方法（其他语言类似） 入门：先了解背景、市场占有率、这门语言主要用途、前景如何、哪个公司发明； 最小单元：常量、变量、数据类型； 次小单元：运算符、表达式； 结构：业务逻辑（顺序结构、分支结构、循环结构）； 高级部分：数组、函数； 特征（语言所特有部分）：指针； 基础部分程序的入门 程序：做一件事情的过程，作用：计算机模拟现实生活，从而达到降低成本，提高效率的效果； 计算机中的程序：为了让计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合； 算法就是对解决问题的方法的描述，算法是描述、程序是执行； 算法固性：有穷性（步骤有限）、确定性（步骤清晰不模糊） 、交互性（具有输入输出）、有效性（步骤有效）； 如何表示算法：自然语言（需求分析）、流程图（概要设计-避免歧义）、伪代码（详细设计）、程序语言（出差：需求、部署）； C语言：面向过程的结构化语言，三种基本结构：顺序结构、分支选择结构、循环结构； 基础知识 低级语言：（汇编）机器语言，可以直接操作计算机硬件；中级语言（C），指针可操作计算机硬件，人类语言；高级语言：（Java）人类语言，经过编译变成机器语言，机器才能执行； 编译：语法查错、转成机器语言（转译）； C语言优点：既能开发系统程序，又能开发应用程序； C语言：面向过程，结构化的（顺序，分支，循环），函数语言； 学习方法：wwwh（why, what, when, how），程序 = 数据结构 + 算法； 最小单元变量和常量 最小的盛放数据单元； 常量：值不能改变的量，一般常量和符号常量（用#define定义，一改全改）； 变量：值可以改变的量，变量的本质是一片连续的内存空间，变量是一个容器，用来存放数据； C语言规定：变量必须先声明，再赋值，后使用；所有变量定义在函数首部，有了执行语句，就不能再有定义语句； 变量命名规则（三条）: ​ —必须以数字，字母，下划线组成，以字母或下划线开头； ​ —见名知义，首字母小写； ​ —变量不能和关键字重名，区分大小写； 基本数据类型 基本数据类型：运算法则、约束内存空间大小的单位； 数值：整型（int，short int，long int）和非整型（float，double），非数值：char； 1个字节 = 8位 、一个中文字符 = 2个字节 、一个英文字符 = 1个字节； C语言中没有字符串变量，用字符数组模拟字符串变量（难用）； ASCII码：0~9（48~57），A~Z（65~90），a~z（97~122）， C语言中char和int完全兼容； 类型转换: ​ —&gt;自动类型转换：把范围小的类型的值转换为范围大的类型的值：（ short, int, long, float, double）； ​ —&gt;强制类型转换：(类型名)变量或数值； 转义字符：转为其他的意思（\\t， \\n等）； C语言的输入输出：getchar() ，putchar()，输入输出字符； scanf() ，printf()输入输出任何东西，（sacnf和printf中的f是format的意思，即格式化输入和输出）； 次小单元运算符&amp;表达式 表达式：操作数 + 运算符； 数学表达式、赋值表达式、关系表达式、逻辑表达式； 算数运算符：+、-、* 、/、%（二目）， /：两边都是整数取整，/：两边至少一边为实型求精确值，%：要求两边都是整型，求余； 12345678910111213141516171819202122232425262728//算数运算符练习：回文数：void main() &#123; int ge, shi, qian, wan, x; printf(\"请输入一个五位数：\"); scanf(\"%d\", &amp;x); wan = x / 10000; qian = x % 10000 / 1000; shi = x % 100 / 10; ge = x % 10; if(wan == ge &amp;&amp; qian == shi) &#123; printf(\"%d是回文数\\n\", x); &#125; else &#123; printf(\"%d不是回文数\\n\", x); &#125;&#125;//水仙花数：void main() &#123; int n, ge, shi, bai; for(n = 100; n &lt;= 999; n++) &#123; ge = n % 10; shi = n % 100 / 10; bai = n / 100; if(ge * ge * ge + shi * shi * shi + bai * bai * bai == n) &#123; printf(\"%d\\n\", n); &#125; &#125;&#125; ++、–（一目），单个语句时a++和++a效果一样，参与运算时a++和++a效果不一样； 123456789//自增自减练习：void main() &#123; int a = 1, b = 2, c = 3, d, e, f; d = ++a; e = a + b; f = (b--) + c; printf(\"%d %d %d %d %d %d\\n\", a, b, c, d, e, f);&#125; 运行结果：2 1 3 2 4 5 赋值：变量 = 表达式； 关系运算符：&gt;、&gt;=、！=、==、&lt;、&lt;=； 逻辑运算符（与、或、非）：&amp;&amp;、||、！； C语言中：用0代表假，非零代表真；sizeof：可以获得数据类型占用内存空间的大小 ；sizeof(type_name) 结果以字节为单位显示； 三种结构顺序结构分支选择结构 if：（布尔常量， 布尔变量， 比较表达式， 逻辑表达式）； 多分支（否定式： 多重if-else、 switch-case）； 123456789101112131415161718192021222324252627282930313233343536//多重if-elsevoid main() &#123; int f; printf(\"请问你送几朵花：\"); scanf(\"%d\", &amp;f); if(f &gt;= 9 &amp;&amp; f &lt; 99) &#123; printf(\"笑一笑\"); &#125; else if(f &gt;= 99 &amp;&amp; f &lt; 999) &#123; printf(\"拉拉手\"); &#125; else if(f &gt;= 999) &#123; printf(\"抱一抱\"); &#125; else &#123; printf(\"不高兴\"); &#125; &#125;解释：程序能进入到下一个elseif语句块，说明前面if里的条件不成立//switch-casevoid main() &#123; int f; printf(\"请问你送几朵花：\"); scanf(\"%d\", &amp;f); switch(f) &#123; case 9: printf(\"笑一下\"); break; case 99: printf(\"拉拉手\"); break; case 999: printf(\"抱一下\"); break; default: printf(\"不高兴\"); &#125; &#125;解释：程序能进入到下一个case语句块，说明前面case里的条件不成立，每个case后应该有break语句，否则程序会执行当前case条件满足后的所有语句，不符逻辑。 （肯定式：If嵌套）； 1234567891011121314151617181920void main() &#123; int work, house, car; printf(\"请输入你的资源：\"); scanf(\"%d %d %d\", &amp;work, &amp;house, &amp;car); if(work) &#123; if(house) &#123; if(car) &#123; printf(\"赶紧结婚\"); &#125; else &#123; printf(\"买了车就结婚\"); &#125; &#125; else &#123; printf(\"无房不嫁女\"); &#125; &#125; else &#123; printf(\"先好好提升自己\"); &#125;&#125;解释：当进入下一个if条件判断时，说明满足之前if的判断条件。 switch-case：switch()里可以是整型常量，整型变量，整型表达式；case后面必须是整型常量，case最后一句跟break；case后面不能跟相同的值，case可以随意倒顺序； 条件运算符：a &gt; b ? c : d —-如果a &gt; b成立，则结果为C，否则为d； 循环结构 循环的本质：有规律的重复的做一件事； 循环分类：（小括号—规律，花括号—重复），规律：已知循环次数（循环变量i）和未知循环次数（循环的开关）；循环体：当型、直到型； 当型（while-未知循环次数、for-已知循环次数），直到型：do-while（已知循环次数和未知循环次数）； 12345678910111213141516171819202122232425262728293031323334353637383940414243//whilevoid main() &#123; int i = 0, j = 0; while(i &lt; 10) &#123; printf(\"第%d个同学演节目开始！\", (i + 1)); while(j &lt; 3) &#123; printf(\"第%d个节目!\", (j + 1)); j++; &#125; j = 0; printf(\"第%d个同学演节目结束！\\n\", (i + 1)); i++; &#125;&#125;//forvoid main() &#123; int i, j; for(i = 0; i &lt; 10; i++) &#123; printf(\"第%d个同学演节目开始！\", (i + 1)); for(j = 0; j &lt; 3; j++) &#123; printf(\"第%d个节目！\", (j + 1)); &#125; printf(\"第%d个同学演节目结束！\\n\", (i + 1)); &#125;&#125;//do-while（猜数字）void main() &#123; int flag = 1; int num = 8, guess; printf(\"请输入一个1~10之间的数！\"); do &#123; printf(\"请输入：\"); scanf(\"%d\", &amp;guess); if(guess &lt; num) &#123; printf(\"小了！\"); &#125; else if(guess &gt; num) &#123; printf(\"大了！\"); &#125; else &#123; flag = 0; &#125; &#125; while(flag); printf(\"恭喜你答对了！\");&#125; 已知循环次数：循环变量在外面定义并初始化，循环变量在循环体里进行自增或自减； 循环的嵌套：外层一趟，内层一遍； for循环：for（表达式1；表达式2；表达式3）， ​ 表达式1：循环变量赋初值； ​ 表达式2：循环条件； ​ 表达式3：更新循环变量值； break与continue：break，终止，在多层循环中，一个break语句只向外跳一层循环；continue：中止，只能用在循环里，跳过循环体中剩余的语句而执行下一次；对于while和do-while循环（continue语句执行之后的动作是条件判断），对于for循环，随后的动作是变量更新； 一般情况下，这几种循环体用的概率：for（60%）、while（25%）、do-while（15%）； 高级部分数组 why？数据带上结构：贴近现实生活，操作、维护方便； 主要内容：数组名、数组大小、数组下标、数组容器的样子、数组类型； 变量&amp;数组比较： ​ 变量：值可变的量、一片连续的内存空间、小容器； ​ 数组：一组数放在一起、一片连续的有序的类型相同的空间、大容器； 种类：一维、二维、多维； 一维数组声明： 1datatype arrayName[size]; //（size：整型常量） 静态定义（三种）： 123int num[5] = &#123;1, 2, 3, 4, 5&#125;;int n1[] = &#123;1, 2, 3&#125;;int n2[5] = &#123;1, 2, 3&#125; 动态定义（循环初始化）； 字符数组模拟字符串变量： 1char c[2] = \"ok\"； 输入输出字符串：gets(),puts()—可输入空格； 二维数组声明： 静态定义（两种）： 12int num[2][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;;int num[][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; 动态定义（使用for循环初始化）； 1234567891011121314151617//找数字：void main() &#123; int n = 8, i; int num[10]; for(i = 0; i &lt; 10; i++) &#123; scanf(\"%d\", &amp;num[i]); &#125; for(i = 0; i &lt; 10; i++) &#123; if(n == num[i]) &#123; printf(\"找到了：%d, 位置：%d\", num[i], i + 1); break; &#125; &#125; if(i == 10) &#123; printf(\"对不起，没找到！\"); &#125;&#125; 函数 使用函数四个优点： ​ 让主调函数更简短清晰； ​ 提高代码维护效率； ​ 提高代码开发效率； ​ 提高代码复用率； 函数类型： ​ 内置函数—函数原型，功能，在哪个工具箱（头文件）放着； ​ 自定义函数； rand（）：伪随机函数； 12srand((unsigned)time(NULL))---作种函数（每次出来的随机数不一样）；//没有这句，程序运行每次随机数一样 自定义函数：返回值类型 函数名（[参数的数据类型 参数名],…），函数一次性只能返回一个值； 一个函数只做一件事；（高内聚） 函数原型说明：int add(int a, int b)或int add(int, int)； 函数的参数：函数定义中声明的参数是形参，函数调用时传入的参数就是实参； 函数参数的传递：值传递（将实参拷贝一份赋值给形参），址传递（让形参和实参共享一片内存空间，即内存地址相同）； 12345678910111213141516171819202122//值拷贝传递void add(int x, int y) &#123; x++; y++;&#125;void main() &#123; int a = 1, b = 2; add(a, b); printf(\"%d %d\", a, b);&#125;运行结果：1 2//址传递void add(int n[2]) &#123; n[0]++; n[1]++;&#125;void main() &#123; int a[2] = &#123;1, 2&#125;; add(a); printf(\"%d %d\", a[0], a[1]);&#125;运行结果：2 3 变量作用域： 变量的有效范围 —&gt; 全局、局部； 123456789101112131415161718192021222324252627//简单彩票机void main() &#123; int i = 0, j, m; int lottery[7]; srand((unsigned)time(NULL)); printf(\"请问您是否要购买彩票？\"); printf(\"请选择：1-是，0-否\\n\"); scanf(\"%d\", &amp;m); if(m) &#123; do&#123; lottery[i] = (rand() % 33) + 1; for(j = 0; j &lt; i; j++) &#123; if(lottery[j] == lottery[i]) &#123; break; &#125; &#125; if(!(j &lt; i)) &#123; i++; &#125; &#125; while(i &lt; 7); for(i = 0; i &lt; 7; i++) &#123; printf(\"%d \", lottery[i]); &#125; &#125; else &#123; return 0; &#125;&#125; 特征指针 指针：就是内存地址，一个变量只有一个指针； 指针变量：用来存放地址的变量，变量的指针：变量的地址； 关键的运算符：&amp; 取地址符、* 指针运算符； int p== (int )p； n[i - 1] = (n + (i - 1)) = (p + (i - 1))；","comments":true,"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C语言/"}]},{"title":"JavaSE基础","date":"2019-03-07T06:22:36.000Z","path":"2019/03/07/Java基础/","text":"Java一些基础语法概念总结 About1、SUN（Stanford University Network），2008年10亿美金收购mysql，2010年74亿美金被甲骨文收购； 2、语言的进化：机器、汇编、高级语言、面向对象（计算机容易识别转换为人容易识别）； 3、java之父：James Gosling； 4、java诞生记：1991年SUN公司的Green计划（让电器带上智能—编程语言跨平台）、java开发了三年；Internet带来时机，本起名Oak（橡树），1995年正式发布java1.0版本； 5、java是sun公司倡导的JamesGosling发明的面向对象的可跨平台的编程语言； 6、平台 = cpu + 操作系统； 7、跨平台：编译以后能不能跨平台，并非源代码可跨平台运行； 8、Java可以反编译（缺点）； 9、java：一次编译，到处执行（编译器、解释器）； 10、语言执行方式的三种分类： 编译执行：缺点，无法跨平台；优点，速度快； 解释执行（html、javascript）：类似同声传译； 中间码+虚拟机（解释型语言）； 11、JDK：开发java需要从源文件到中间字节码的编译器；运行java需要java解释器；JDK=Java编译器+Java解释器+其他组件； 12、优点：面向对象、平台无关、自动收集内存、多线程开发；缺点：运行速度慢，占用资源多，复杂； 13、IDE工具：Jbuild可以拉拖界面； 基础1、数据类型：基本数据类型和引用数据类型； 基本数据类型：数值型（整数（byte—1个字节、short、int、long）、浮点（float、double））、字符型（char）、布尔型（boolean）； 引用数据类型：类（class）、接口（interface）、数组； 2、字符串String； 3、数组定义（三种方式）： 123int[] num = new int[2];int[] num = &#123;1, 2&#125;;int[] num = new int[]&#123;1, 2&#125;; 4、反序数： 12345int n = 12345;while (n != 0) &#123; System.out.print(n % 10); n = n / 10;&#125; 5、冒泡排序：（第一轮可以让未排序的最大元素上浮到右侧，以此类推，5个数循环4次）： 12345678910111213int[] num = new int[]&#123;2, 6, 4, 8, 3&#125;;for(int i = 0; i &lt; num.length - 1; i++) &#123; for(int j = 0; j &lt; num.length - i - 1; j++) &#123; if(num[j] &gt; num[j+1]) &#123; int temp = num[j]; num[j] = num[j+1]; num[j+1] = temp; &#125; &#125;&#125;for(int i = 0; i &lt; num.length; i++) &#123; System.out.println(num[i]); &#125; 6、二分查找（要求数字按序排列）： 123456789101112131415161718int[] num = &#123;1, 4, 6, 8, 10, 13&#125;;int n = 4;int start = 0, end = num.length - 1, m;while(true) &#123; m = (start + end) / 2; if(num[m] &gt; n) &#123; end = m - 1; &#125; else if(num[m] &lt; n) &#123; start = m + 1; &#125; else &#123; System.out.println(\"找到了\" + num[m] + \"，位置为：\"+ (m + 1)); break; &#125; if(start &gt; end) &#123; System.out.println(\"找不到！\"); break; &#125;&#125; 类和对象1、面向对象编程（oop，Object Oriented Programming），是一种设计软件的先进的主流的思想，旨在计算机中模拟现实世界中的事物和概念，Everything is object； 2、现实生活中的任何事物，都可以用状态（属性）和行为（方法）来描述； 属性是事物（类）本身的特性，用来表示它的状态；行为（方法）用来说明这个事物（类）所具有的功能； 3、类（主观）是具有相同属性和方法的一组对象（实例）的集合； 4、对象是具体的，是类定义内容的实现，把一个类的对象称为一个类的实例（客观存在的）； 5、类是对象的抽象定义，对象是类的具体实例； 6、java声明完类并不开辟空间，new关键字为实例开辟空间； 7、构造方法（什么？作用？调用时机？分类？） 方法名与类名完全相同，但没有返回类型（跟没有返回值不一样）； 123//Person类Person() &#123; //构造方法 &#125; 作用：让类开辟空间；在类诞生的时候做一些事情（一般是初始化）； 调用时机：new的时候自动调用（开辟空间的时候），传什么参调用什么方法； 分类： 默认有隐式构造方法（空参数），显式构造方法（带参）； 如果类中不带任何构造方法，系统提供隐式构造方法； 如果自己定义了显式构造方法，系统不再提供隐式构造方法； 8、static关键字： 成员变量（实例名、引用名）：new完后才可使用的变量； 12static int num = 0; //静态变量，不需成员名直接类名可调用；成员名也可调用//Person.num static定义完就开辟空间，开辟在静态池中； 静态变量只保持一份，节省空间； 作用：保存类的信息（比如new一次加一次）； 9、包：本质是个文件夹（方便管理、避免名字冲突）；包名是类名的一部分；包是java封装机制的一部分； 10、一般先写被调，再写主调； 封装和继承1、面向对象特征：封装、继承、多态；对象的特征：属性、方法； 2、封装：隐藏事物内部的实现细节、有选择的提供数据； 封装优点： 内部的修改不影响外部的使用； 防止外界误修改程序单元； 对象使用变得更简单； 3、访问修饰符：public、protected、默认、private（都可以修饰属性和方法，只有默认和public可以修饰类）； public：所有类都可以访问（本类、同包、异包下的子类、异包下的其他类）； protected：该类及其子类成员可以访问，同一个包中的可以访问（本类、同包、异包下的子类）； 默认：相同数据包里的可以访问（本类及其同包下的类可以访问）； private：只有该类可以访问； 4、实体类：get与set方法称为访问器； 5、继承（extends）： 在一个类的基础上定义一个新类是继承； 父子关系是相对的； 继承关系由“子类是父类”确定； java中只有单继承； 继承效果： 子类可以拥有父类的属性和方法； 子类可以拥有新的属性和方法（扩展）； 子类可以重写覆盖父类方法和属性（修改）； 1@Override //注解，写给编译器 可以声明父类，创建子类（父类装载子类—向上转型），父类能出现的地方，子类一定能出现；声明的什么类型，就只能调用什么类型的属性方法；创建的什么类型，就真正运行什么类型的方法；创建的什么类型，就可以强转为什么类型（向下转型）； 1Person p = new Teacher();//父类装载子类，父类的引用指向子类的空间 继承的优点： 提高代码复用性； 父类的属性方法可以用于子类； 可以轻松的定义子类； 使设计应用程序变得简单； 6、关键字this与super： this：表示调用本类声明的属性和方法，this使用在构造方法中表示调用本类其它构造方法； super：表示调用父类声明的属性和方法； 7、继承中的构造方法： 创建子类一定会调用父类的构造方法； 子类默认调用父类无参（显式或隐式）构造方法； 子类只能调用父类存在的构造方法； 子类构造方法中使用super调用父类构造方法，并且super必须放在第一行； 8、子类要覆盖父类的属性或方法，子类的访问修饰符必须大于或等于父类的访问修饰符； 方法重载和多态1、方法重载（Overload）： 具有相同的方法名称、不同的参数（类型或者个数）； 要点： 与参数名无关； 与返回类型无关； 父子类方法重载； 构造方法重载； 2、多态： 多态可以理解为“多种形式”的意思； 多态在程序中表现为同一个引用在不同的条件下指向不同实例，从而表现出不同状态； 多态一般用方法重载和方法重写来实现； 3、雪雪是个多态：在学校是学生，在家里是儿女，在社会是工作者（同一个人在不同环境下表现出不同状态）； 4、static（强调只有一份）修饰符： static只能修饰属性和方法，不能修饰类； static修饰符修饰的变量叫静态变量； static修饰符修饰的方法叫静态方法；静态方法独立于类的实例，使用类去访问，而不是类实例，所以也叫类方法；静态方法只能调用静态成员，不能调用成员化东西；成员方法可以调用静态方法；静态方法和属性不能写this和super； 5、final修饰符： final可以修饰属性、方法和类； 不能修改该变量；不能继承该类；子类不能重写该方法； 6、static和final：final强调是不变的；static强调只有一份； 7、内存机制： 方法区：类结构的样子、静态属性、静态方法； 堆：对象的实例； 栈：对象的引用、基本数据类型； 栈（最快）&gt;堆（容量大、速度慢）； 8、Java内存图示： 9、值传递与址传递：基本数据类型采用值传递、引用类型址传递； 接口1、抽象方法： abstract修饰的方法就是抽象方法； 抽象方法不能有方法实现，只能有方法定义； 抽象方法必须出现在抽象类中； 构造方法和static方法不能是抽象的； 2、抽象类： abstract修饰的类就是抽象类； 抽象类中可以拥有若干个（0~多个）抽象方法，也可以拥有若干个（0~多个）普通方法； 抽象类不能被实例化，可被继承； 如果一个抽象类被另一个类继承，这个类必须重写抽象类中所有抽象方法； 3、接口（interface），达到多继承的效果，接口就是功能： 是一种“纯虚抽象类”，可以理解为半个类； 接口用来完成多继承的效果； 接口中只能有方法的定义，不能有方法的具体实现； 接口中可以定义常量（static final）； 接口可以被继承（接口继承接口），接口可以多继承； 接口可以多实现（类实现接口）； 弥补单继承的不足，实现多继承的效果； 实现者-使用者纽带作用； 用法：extends， implements 4、编程技术的趋势：面向过程、面向对象、面向接口、面向方面； 5、什么是什么，可以理解为类的继承；什么能干什么，可以理解为接口的实现； JavaAPI（Java.lang—基础包）1、包装类、String和StringBuffer类、Math、Class、Object； 2、java的main方法和8个基本数据类型不是面向对象的； 3、装箱：int-&gt;Interger（valueOf）；拆箱：Interger-&gt;int（intValue）； 4、包装类型 实例名 = 包装类型.valueOf(String);包装类型.parse基类型(String)；实例名.toString()； 5、字符串： 12String s0 = \"aa\";//字符串字面量String s1 = new String(\"aa\");//字符串对象 6、==：判断字符串指的是否为同一片空间；equals比较字符串值是否相等； 7、字符串字面量：值相等用==比较true；字符串对象：值相等用==比较false； 8、字符串lengh是方法，数组lengh是属性； 9、字符串比较内容：equals、compareTo、startswith、endswith； 10、搜索字符串：indexOf（String）； 11、操作字符串：split（）、charAt（）、subString（）、replace（）、concat（）、trim（）—去掉字符串前后包含的空格； 12、Object：toString、equals（在object里比较的是两个引用是否相等，无法比内容，需重写equals方法）、hashcode（重写hashcode，使重写equals方法后，业务逻辑和虚拟机保持一致）、finalize（析构方法，收空间，System.gc()—建议立即回收垃圾方法）； 13、Class：类的类，包装正在运行类的运行状态及信息，可用来动态加载类，得到类的实例； 14、字符串（空间）的不变性：String—&gt;有序的、不变的字符序列； StringBuffer：可变字符串，解决字符串的不变性，节省空间； 12StringBuffer sb = new StringBuffer(\"ok\");sb.append(\"halou\"); 异常处理1、try、catch、finally、throw、throws； 2、异常：就是不同寻常的事情，异常并不总是错误，一切不寻常的事情都是异常（其中包含错误）； 3、所有异常类型都是内置类Throwable的子类： Error类对象由java虚拟机生成并抛出（用于java运行时系统来显示与运行时系统本身有关的错误）—灾难，无法处理； Exception类对象由应用程序处理或抛出（用于用户程序可能捕获的异常，也是用来创建用户异常类型子类的类）—可以处理。RuntimeException可以忽略，除了RuntimeException其他子类不能忽略； 4、处理方式：直接处理、向上抛出； 5、是一个业务逻辑才能try在一起； 6、try-catch如果代码段有异常没被处理，在发生异常处及后面代码不被执行，如果处理，进入catch处理后后面代码依然执行； 7、throws处理后，后面代码不再执行，看到throw方法直接返回，位于throw下面的代码不再执行；如果希望throw后面的代码执行，最后加finally，不管有木有错finally里语句要执行； 8、里面throw-throws，外面try-catch；如果里面是Runtime可以throw不throws，外面可抓可不抓；里面不throw，外面直接catch； JDBC数据库连接（java.sql）1、JDBC（sun公司制定）是一种标准，不是技术，是一些类和接口的集合（jar包）； 2、sun公司制定标准（接口），数据库生产商按照标准生产数据库连接对象（类-实现），开发人员学习接口，使用类； 3、Driver（驱动程序）、Connection（表示与数据库的连接）、PreparedStatement（执行预编译的SQL语句）、ResultSet（查询出来的数据库数据结果集）、Statement（执行SQL语句并将数据检索到ResultSet中）； java.util1、Date、Calendar、GregorianCalendar（时间）；Arraylist、Vector、HashSet、HashMap、Hashtable（集合框架、容器）； 2、Date：表示特定的瞬间，精确到毫秒，获得当前时间； 3、toString原生出来是类名+地址； 4、Calender：日历类，抽象类，不能被实例化； 5、GregorianCalendar：标准日历类，是Calendar一个子类，日期类月份值跟业务逻辑相差1； 6、SimpleDateFormat：日期的格式化； 7、日历变日期：getTime()； 8、集合框架：用于表示和操纵集合的统一体系结构，集合用于存储、检索和操纵数据，Collection对象是将多个元素组成一个单元的对象； 9、集合框架包含三个组件：接口、实现、算法； 10、Iterator（迭代器）、Collection（多个变一个，用对象本身存集合里面，无序）、Map（多个变一个，键值对存储，无序）； 11、集合框架类层次结构： 12、List：有序的、带下标的、对象本身存；Set：无序、不带下标、对象本身存； Vector：线程安全的动态数组，ArrayList：线程不安全的动态数组； 13、Collection：可存储重复值； 迭代器-Iterator： 12345Iterator iterator = c1.iterator();while (iterator.hasNext()) &#123; Student temp = (Student) iterator.next(); System.out.println(temp.toString()); &#125; foreach迭代： 123for(Student s : c1) &#123; System.out.println(s.toString()); &#125; foreach里面内部就是iterator； 14、泛型：规定容器里只放一种东西； 15、Vector： 具有类似数组的数据结构，是动态的，容量可以递增； 可存储重复元素和NULL； 元素有序排列； 线程安全； 16、Set：无序、不能存储重复元素、可存null、线程不安全的； 17、Map： 键值对存储； 三种遍历方式—迭代（键、值）、entry（key-value）； 键不能重复，值可以重复； 键和值可以存null值，hashmap线程不安全； 12345678910111213141516171819System.out.println(\"通过keys进行遍历===========\");Set&lt;String&gt; keys = map.keySet();for(String keyStr: keys) &#123; System.out.println(keyStr); System.out.println(map.get(keyStr));&#125;System.out.println(\"通过values遍历=================\");Collection&lt;Student&gt; values = map.values();for(Student stu: values) &#123; System.out.println(stu);&#125;System.out.println(\"通过key-values（Entrys）遍历================\");Set&lt;Map.Entry&lt;String, Student&gt;&gt; entrys = map.entrySet();for(Map.Entry&lt;String, Student&gt; entry: entrys) &#123; System.out.println(entry.getKey()); System.out.println(entry.getValue());&#125; 18、hashtable线程安全，键和值都不可以存储null值，遍历的时候可以使用枚举类型； 1234567Hashtable&lt;String, Student&gt; ht = new Hashtable&lt;String, Student&gt;();ht.put(\"dd\", s1);System.out.println(\"枚举类型==============\");Enumeration&lt;Student&gt; enumeration = ht.elements();while (enumeration.hasMoreElements()) &#123; System.out.println(enumeration.nextElement());&#125; 19、实现comparable达到list集合排序功能； 20、集合框架的优点：提供有用的数据结构和算法，减少编程工作；提高程序速度和质量，因为它提供了高性能的数据结构和算法；可以方便地扩展或改写集合； JavaSwing1、GUI：图形用户界面； 2、Awt（抽象窗口工具-重量级页面技术）、Swing（波浪、翅膀-轻量级页面技术），swing是awt的子类； 3、Awt（重量级）：容器（包含Awt容器组件）、组件（以图形表示的对象允许用户交互）、布局管理器（定义GUI组件的位置）、图形和绘制方法（使用Awt图形方法相对于窗口绘制图形）、字体、事件（用于用户和系统交互）； 4、Swing（轻量级）：容器、组件、可改变的外观、Java2D图形绘制； 5、MVC（编程思想）：界面、操作、存储（视图、控制—业务的分发和流程的转发、持久—存储数据）； 6、页面主动拿数据（拉）、页面被动拿数据（推），swing是mvc的推； 7、重量级（直接借助于awt、被单独的显示）、中间层容器、功能性容器； 8、Dimention：描述矩形的单位； 9、JLabel：单向交互、显示图片或文字；JButton：交互；JTextField：文本域；JPasswordField、JTextArea、JScollPane； 10、布局管理器：屏幕组件可以按照一定的格式布局； 流式（FlowLayout）：默认，一直往下排列； BorderLayout：边框布局管理器，上下左右中； GridLayout：几行几列； GridBagLayout：高级布局管理器，实现精确的布局管理； 11、ActionListener：实现接口、完成事件方法、相应事件源上加事件； 12、JDialog（繁琐）和JOptionPane（简单）：弹出式对话框，完成于用户的交互； 13、对话框显示：模式（需处理）、非模式（不需处理）； 14、模式：观察者模式（事件的源、事件对象、事件处理对象）； 15、事件源（三个要素）：私有的监听者列表，公有的向监听者列表添加监听者的方法，公有的发生事情的方法； 16、事件源四种添加监听者接口实例：自己加自己、自己加别人实现接口、自己加别人（适配器）、参数匿名类（适配器）； 17、表格JTable：显示数据，表格模板（TableModel）：对数据操作，JMenu：菜单；热键：Alt+？ 18、JMenue不能做快捷键，可以做热键，不能带图片；JMenueIterm两个都可以做，可以带图片； 19、工具栏（JToolBar）挂在panel上； 20、标签面板（JTabbedPane）：是一种容器，提供一组标签显示不同页面； 设计模式1、模式：我们处理大量问题时，在很多不同的问题中重复出现的一种性质，它使得我们可以使用一种方法来描述问题实质并用本质上相同，但细节永不会重复的方法去解决，这种性质就叫模式。简单的说模式就是一种惯性的思维方式，用于解决同一类问题； 2、23种设计模式： 创建型：解决对象与对象之间创建性的问题； 结构型：解决对象与对象间搭配结构的问题； 行为型：解决对象与对象之间做事情； Java Io1、I/O流用来完成java的输入输出工作，包括磁盘文件、设备、其他程序以及内存数据等等的输入输出； 2、数据流（不间断—I/O流）、数据包（间断）； 3、分类：字节流（Stream）、字符流； 4、基于流技术可以用来传递数据，还可以用来操作或格式化数据； 5、外部进入代码里面：输入流；代码输出数据：输出流； 6、声明、创建、读写、关闭； 7、字符流的根：Reader和Writer； 8、 123reader = new BufferedReader(new FileReader(\"./test1.txt\"));writer = new BufferedWriter(new FileWriter(\"./test2.txt\"));里面节点流，外面处理流； 9、字节流、缓冲字节流、字符流、缓冲字符流； Java多线程1、进程（是执行中的程序，是活动的实体—正在通电的内存；是自包容的运行程序，有自己的地址空间）—是操作系统的最小单元；线程（是轻量级进程，是CPU使用的基本单元；线程属于某一个进程，一个进程中拥有一个或多个线程；多个线程共享同一个进程资源）；进程是重量级的、线程是轻量级的； 2、read方法是一种阻塞方法； 3、多任务处理： 基于进程：计算机同时运行多个进程；基于线程：一个进程包含多个线程； 4、使用多线程的理由：与用户交互更佳、模拟同步动作、利用多处理器、等待缓慢I/0操作时完成其他任务、简化对象模型；线程也需要开销资源，谨慎使用； 5、JVM中的线程：当操作系统启动（javac、java、javaw等命令）JVM时就创建了一个进程；JVM进程内至少包含了 两个线程：mian方法和垃圾回收线程，它们称为主线程，有时它们还会启动其他线程，它们必须最后完成执行，执行各种关闭、释放动作； 6、创建线程两种方法：声明一个Thread类的子类，并覆盖run（）方法；声明一个实现Runnable接口的类，并实现run（）方法； 7、线程的状态：新建态（New—尚未启动的线程）、可运行态（Runnable—可运行线程的线程状态）、锁定态（Blocked—受阻塞线程的线程状态）、等待态（Waiting）、定时等待态（Timed_Waiting）、中止态（Terminated—已终止线程的线程状态）； 8、yield：使正在执行的线程临时暂停，并允许其他线程执行； 9、优先级：线程抢占cpu的能力； Java网络编程1、网络（套接字、socket）编程； 2、网络：实现资源共享和通信，连接终端系统（主机）的通信系统； 3、OSI模型：物理层、数据链路层（怎么连）、网络层（怎么找）、传输层（怎么传）、会话层、表示层、应用层（传什么）； 4、TCP：双向的、稳定的、可靠的、有序的、不间断的数据流（打电话）；UDP：单向的、间断的、不可靠的数据包（写信）； 5、IP：连接至网络的每台计算机都是唯一的，32位数字，包括网络ID和主机ID；域名系统：将特定IP地址映射至字符串，映射由域名服务器系统维护； 6、客户端：向另一台计算机请求服务的计算机；服务器：处理客户端请求的计算机； 7、InetAddress：封装IP地址和DNS；ServerSocket：用来创建套接字（TCP）服务器；Socket：创建客户端套接字； 8、UDP（数据报）：DatagramPacket—邮包、DatagramSocket—邮递员；","comments":true,"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Python Selenium基础","date":"2019-02-27T08:38:02.000Z","path":"2019/02/27/Python-Selenium/","text":"Python + Selenium 测试基础 About自动化测试是用机器代替手工做一些事情。作为一个测试人员，做自动化一般是指接口自动化与UI自动化。（接口也是指对外的部分，通过各种协议，各系统或模块之间交流的接口）接口性价比更高，但不代表UI自动化没有价值。 自动化测试基础1、什么是自动化测试？ 首先理清自动化测试的概念，广义上来讲，自动化包括一切通过工具（程序）的方式来代替或辅助手工测试的行为都可以看做自动化，包括性能测试工具（loadrunner、jmeter），或自己所写的一段程序，用于生成1到100个测试数据。狭义上来讲，通过工具记录或编写脚本的方式模拟手工测试的过程，通过回放或运行脚本来执行测试用例，从而代替人工对系统的功能进行验证。当然，我们更普遍的认识把“自动化测试”看做“ 基于产品或项目UI层的自动化测试”。 2、分层的自动化测试 传统的自动化测试更关注的产品UI层的自动化测试，而分层的自动化测试倡导产品的不同阶段（层次）都需要自动化测试。 上面的金字塔就是对产品开发不同阶段所对应的测试！我们需要规范的来做单元测试同样需要相应的单元测试框架，如java的Junit、testNG，python 的unittest、pytest 等，几乎所有的主流语言，都会有其对应的单元测试框架。 集成、接口测试对于不少测试新手来说不太容易理解，单元测试关注代码的实现逻辑，例如一个if 分支或一个for循环的实现；那么集成、接口测试关注的一是个函数、类（方法）所提供的接口是否可靠。例如，我定义一个add()函数用于计算两个参数的结果并返回，那么我需要调用add()并传参，并比较返回值是否是两个参数相加。当然，接口测试也可以是url的形式进行传递。例如，我们通过get方式向服务器发送请求，那么我们发送的内容做为URL的一部分传递到服务器端。但比如 Web service 技术对外提供的一个公共接口，需要通过soapUI 等工具对其进行测试。 UI层的自动化测试，大部分测试人员的大部分工作都是对UI层的功能进行测试。例如，我们不断重复的对一个表单提交，结果查询等功能进行测试，我们可以通过相应的自动化测试工具来模拟这些操作，从而解放重复的劳动。UI层的自动化测试工具非常多，比较主流的是QTP，Robot Framework、watir、selenium 等。 在自动化测试中最怕的是变化，因为变化的直接结果就是导致测试用例的运行失败，那么就需要对自动化脚本进行维护；如何控制失败，降低维护成本对自化的成败至关重要。反过来讲，一份永远都运行成功的自动化测试用例是没有价值的。 对于google产品，70% 投入为单元测试，20% 为集成、接口测试，10% 为UI层的自动化测试。 3、为什么要做自动化测试？ 相对开发来说，测试的门槛底，薪资普遍较底，所要求的知识面虽然有一定广度，但缺乏深度。这是测试的普遍现状。 4、什么项目适合做自动化测试？ 软件需求变动不频繁 （相对稳定的模块进行自动化测试，而变动较大的仍是用手工测试）、项目周期较长 （自动化测试需求的确定、自动化测试框架的设计、测试脚本的编写与调试均需要相当长的时间来完成）、自动化测试脚本可重复使用 （自动化测试脚本的重复使用要从三个方面来考量，一方面所测试的项目之间是否很大的差异性（如C/S系统和B/S系统的差异）；所选择的测试工具是否适应这种差异；最后，测试人员是否有能力开发出适应这种差异的自动化测试框架）。 5、选择什么工具进行自动化测试 ？ 首先要先确认你所测试的产品是桌面程序（C/S）还是web应用（B/S）。 桌面程序的工具有：QTP、 AutoRunner ； web应用的工具有：QTP、AutoRunner、Robot Framework、watir、selenium ； 如果，被测产品是B/S 结构，那么推荐selenium ，为什么不是QTP 或其它工具？因为selenium 对B/S应用支持很好，更重要的一点，它支持多语言的开发，真正的使用selenium ，你所要掌握的不仅仅是一个工具而已，你还需要学习一门语言。我为什么要选择selenium？还要学一门语言，这无疑增加了我的学习成本。增加成本的同时，也增加的你的竞争力，而且，在这个过程中你不单单只是学会了一个自动化工具而已，你完全可以使用所学的语言去做更多的事情。 selenium 是支持java、python、ruby、php、C#、JavaScript 。 从语言易学性来讲，首选ruby ，python；从语言应用广度来讲，首选java、C#、php；从语言相关测试技术成度（及资料）来讲：ruby ，python ，java； selenium 概念1、selenium 并不是单纯的一个工具，它是一组工具的集合，而且，他还有1.0与2.0之分，当然3.0也已经到来。selenium 也不是简单一个工具，而是由几个工具组成，每个工具都有其特点和应用场景。 selenium IDE selenium IDE 是嵌入到Firefox浏览器中的一个插件，实现简单的浏览器操作的录制与回放功能。那么什么情况下用到它呢？ 快速的创建bug重现脚本，在测试人员的测试过程中，发现了bug之后可以通过IDE将重现的步骤录制下来，以帮助开发人员更容易的重现bug。 IDE录制的脚本可以可以转换成多种语言，从而帮助我们快速的开发脚本，关于这个功能后而用到时再详细介绍。 selenium Grid Selenium Grid是一种自动化的测试辅助工具，Grid通过利用现有的计算机基础设施，能加快Web-app的功能测试。利用Grid，可以很方便地同时在多台机器上和异构环境中并行运行多个测试事例。其特点为： 并行执行 通过一个主机统一控制用例在不同环境、不同浏览器下运行 灵活添加变动测试机 selenium RC selenium RC 是selenium 家族的核心工具，selenium RC 支持多种不同的语言编写自动化测试脚本，通过selenium RC 的服务器作为代理服务器去访问应用从而达到测试的目的。 selenium RC 使用分Client Libraries和selenium Server，Client Libraries库主要主要用于编写测试脚本，用来控制selenium Server的库。 Selenium Server负责控制浏览器行为，总的来说，Selenium Server主要包括3个部分：Launcher、Http Proxy、Core。其中Selenium Core是被Selenium Server嵌入到浏览器页面中的。其实Selenium Core就是一堆JS函数的集合，就是通过这些JS函数，我们才可以实现用程序对浏览器进行操作。Launcher用于启动浏览器，把selnium Core加载到浏览器页面当中，并把浏览器的代理设置为Selenium Server 的Http Proxy。 2、selenium 2.0 搞清了selenium 1.0 的家族关系，selenium 2.0 是把 WebDriver 加入到了这个家族中；简单用公式表示为： ​ selenium 2.0 = selenium 1.0 + WebDriver 需要强调的是，在selenium 2.0 中主推的是WebDriver ，WebDriver 是selenium RC 的替代品，因为 selenium 为了向下兼容性，所以selenium RC 并没有彻底抛弃，如果你使用selenium开发一个新自动化测试项目，强列推荐使用WebDriver 。那么selenium RC 与webdriver 主要有什么区别呢？ selenium RC 在浏览器中运行JavaScript应用，使用浏览器内置的JavaScript 翻译器来翻译和执行selenese命令（selenese 是selenium命令集合）。 WebDriver通过原生浏览器支持或者浏览器扩展直接控制浏览器。WebDriver针对各个浏览器而开发，取代了嵌入到被测Web应用中的JavaScript。与浏览器的紧密集成支持创建更高级的测试，避免了JavaScript安全模型导致的限制。除了来自浏览器厂商的支持，WebDriver还利用操作系统级的调用模拟用户输入。 如果是新项目直接学习webdriver 就OK了，RC是过时技术。 selenium学习路线配置测试环境，针对所学习语言，来配置相应的selenium 测试环境。selenium 好比定义的语义—“问好”，假如你使用的是中文，为了表术问好，你的写法是“你好”，假如你使用的是英语，你的写法是“hello”。 所以，同样有语义在不同的语言下会有不同的写法（语法）。 接着你需要熟悉webdriver API ，API就是selenium 所定义一方法，用于定位，操作页面上的各种元素。 先学习元素的定位，selenium 提供了id、name、class name、 tag name、link text、partial link text、 xpath、css等定位方法。xpath和css 功能强大语法稍微复杂，在这其间你可能还需要了解更多的前端知识。xml ，javascript 等。 定位元素的目的是为了操作元素，接就要学习各种元素的操作，输入框，下拉框，按钮点击，文件上传、下载，分页，对话框，警告框…等等。 经过一段时间的学习，你可以游刃有余的模拟手工测试来操作页面上的各种元素了。接着你需要做的就是把这些“用例”组织起来，统一来跑。 那么你需要做的就是学习并使用单元测试框架，单元测试框架本身就解决了用例的组织与运行。 当你写了一些“测试用例” 之后，你会发现用例中有大量重复的操作，能不能写到一个单独的文件中，需要的时候调用这些操作？当然可以，运用你的编程能力来实现这一点将非常简单。然后，你又发现每个用例中都有一些数据，这些数据也是一样的，但如果变化了修改起来非常麻烦，你也可以把他写到一个单独的文件中进行读取。 接着你又遇到了新的疑问，我写的脚本（用例）都是流水式的，我怎么知道用例运行失败还是成功。那么就需要在脚本中加一些验证与断言。 接着你又有了更多的想法，单元测试框架的log太简陋了，能不能生成一张漂亮的测试报告出来。我能不能定时的来跑这个脚本。能不能把每一次跑脚本的测试结果直接发到我的邮箱。能不能…… 为解决这些问题，你不得不学习更多的编程技术，然后你的“测试结构”会功能越来越强大，越来越灵活。产生了一定的通用性和移植性。一个有模有样的自动化测试框架诞生了。 总结： 配置测试环境 -&gt; 熟悉 webdriver API -&gt; 学习元素定位 -&gt; 操作元素 -&gt; 单元测试框架组织用例 -&gt; 抽取重复部分 -&gt; 加验证与断言 -&gt; 生成漂亮测试报告、定时跑脚本、测试结果发邮箱 -&gt;… PythonwebdriverAPI1、熟练掌握xpath/css定位使用；python版本的webdriver API；学习掌握js语言；与前端打交道，多熟悉前端技术，如http请求，HTML语言，cookie/session机制等 2、主要内容： 浏览器的操作（浏览器最大化；设置浏览器宽、高；控制浏览器前进、后退）； 简单对象的定位（id 和name的定位；tagname和classname定位；linktext和partiallinktext定位；xpath和css定位）； 操作测试对象（登录实例；webelement接口常用方法）； 鼠标事件；键盘事件；打印信息；设置等待时间； 定位一组对象；层级定位；定位frame中的对象；对话框处理；浏览器多窗口处理； alert/confirm/prompt处理； 下拉框处理；分页处理；上传文件；下载文件； 调用js；控制浏览器滚动条； cookie处理；获取对象的属性；验证码问题； 自动化测试模型1、一个自动化测试框架就是一个集成体系，在这一体系中包含测试功能的函数库、测试数据源、测试对象识别标准，以及可重用的模块。自动化测试框架在发展的过程中经历了几个阶段，模块驱动测试、数据驱动测试、对象驱动测试； 2、自动化测试模型：是自动化测试架构的基础； 线性测试：通过录制或编写脚本，一个脚本完成一个场景（一组完整功能操作），通过对脚本的回放来进行自动化测试；优势：每一个脚本都是独立的，任何一个脚本文件拿出来就能单独运行；缺点：用例的开发与维护成本很高；这种模式下数据和脚本是混在一起的，如果数据发生变也需要对脚本进行修改。这种模式下脚本没有可重复使用的概念。 模块化与类库：能把重复的部分写成一个公共的模块，需要的时候进行调用，这样就大大提高了编写脚本的效率；优点：提高了开发效率，不用重复的编写相同的脚本用，不同重复造轮子；方便了代码的维护； 数据驱动：数据的改变（更新）驱动自动化的执行，从而引起测试结果的改变。（可直白的理解成参数化，输入数据的不同从而引起输出结果的变化）—实现了数据与脚本的分离； 关键字驱动（我要做什么-命令？对谁做-对象？怎么做-值？）：是把“数据”换成“关键字”，通过关键字的改变引起测试结果的改变；Selenium IDE 脚本分：命令（command）、对象（target）、值（value）； 总结： 在实施自动化更多的是以需求为出发点，混合的来使用以上模型去解决问题；使脚本更易于开发与维护； 脚本的模块化与参数化是我们在自动化脚本开发中用到最多的两个技巧； 自动化测试用例设计1、测试用例是测试人员综合自己的经验从需求中挖掘和提炼而来。所以不管什么类型的测试工作，我们都不能盲目开展。任何测试工作都应该以需求为基础，以测试用例为导向进行实施； 2、手工测试用例与自动化测试用例：手工测试用例是针对手工测试人员，自动化测试用例是针对自动化测试框架，前者是手工测试用例人员应用手工方式进行用例解析，后者是应用脚本技术进行用例解析，两者最大的各自特点在于，前者具有较好的异常处理能力，而且能够基于测试用例，制造各种不同的逻辑判断，而且人工测试步步跟踪，能够细致的定位问题。而后者是完全按照测试用例的方式测试，而且异常处理能力不强，往往一个自动化测试用例运行完毕后，报一堆错误，对于测试人员来定位错误是一个难点，这样往往发现的问题很少。 手工测试用例与自动化测试用例对比： 手工测试用例： 较好的异常处理能力，能通过人为的逻辑判断校验当前步骤的功能实现正确与否； 人工执行用例具有一定的步骤跳跃性； 人工测试步步跟踪，能够细致的定位问题 ； 主要用来发现功能缺陷； 自动化测试用例： 执行对象是脚本，任何一个判断都需要编码定义； 用例步骤之间关联性强； 主要用来保证产品主体功能正确完整和让测试人员从繁琐重复的工作中解脱出来； 目前自动化测试阶段定位在冒烟测试和回归测试 ； 总结： 自动化测试替代不了手工测试，目的仅仅在于让测试人员从繁琐重复的机械式测试过程解脱出来，把时间和精力突入到更有价值的地方，从而挖掘更多的产品缺陷。目前自动化测试更多的时候是定位在冒烟测试和回归测试；冒烟测试执行的是主体功能点的用例，回归测试执行全部或部分的测试用例。 3、测试类型： 测试静态内容：静态内容测试是最简单的测试，用于验证静态的、不变化的 UI 元素的存在性； 每个页面都有其预期的页面标题，这可以用来验证链接指向一个预期的页面； 应用程序的主页包含一个应该在页面顶部的图片吗； 网站的每一个页面是否都包含一个页脚区域来显示公司的联系方式,隐私政策,以及商标信息； 每一页的标题文本都使用标签吗?每个页面有正确的头部文本内吗； 测试链接 ：Web 站点的一个常见错误为的失效的链接或链接指向无效页。链接测试涉及的各个链接和验证预期的页面是否存在。如果静态链接不经常更改，手动测试就足够。但是，如果你的网页设计师经常改变链接,或者文件不时被重定向，链接测试应该实现自动化。 功能测试：在您的应用程序中，需要测试应用的特定功能，需要一些类型的用户输入，并返回某种类型的结果。通常一个功能测试将涉及多个页面，一个基于表单的输入页面,其中包含若干输入字段、提交“和”取消“操作，以及一个或多个响应页面。用户输入可以通过文本输入域，复选框，下拉列表，或任何其他的浏览器所支持的输入。 功能测试通常是需要自动化测试的最复杂的测试类型，但也通常是最重要的。典型的测试是登录，注册网站账户，用户帐户操作，帐户设置变化，复杂的数据检索操作等等。功能测试通常对应着您的应用程序的描述应用特性或设计的使用场景。 测试动态元素：通常一个网页元素都有一个唯一的标识符，用于唯一地定位该网页中的元素。通常情况下，唯一标识符用 HTML 标记的’id’属性或’name’属性来实现。这些标识符可以是一个静态的，即不变的、字符串常量。它们也可以是动态生产值,在每个页面实例上都是变化的。例如,有些 Web 服务器可能在一个页面实例 上命名所显示的文件为 doc3861，并在其他页面实例上显示为 doc6148，这取决于用户在检索的‘文档’。验证文件是否存在的测试脚本，可能无法找到不变的识别码来定位该文件。通常情况下，具有变化的标识符的动态元素存在于基于用户操作的结果页面上，然而,显然这取决于 Web 应用程序。 Ajax 的测试：Ajax 是一种支持动态改变用户界面元素的技术。页面元素可以动态更改，但不需要浏览器重新载入页面,如动画，RSS 源，其他实时数据更新等等。Ajax 有不计其数的更新网页上的元素的方法。但是了解 AJAX 的最简单的方式，可以这样想，在 Ajax 驱动的应用程序中,数据可以从应用服务器检索，然后显示在页面上，而不需重新加载整个页面。只有一小部分的页面或者只有元素本身被重新加载。 断言 assert 与验证 verify：断言：测试将在检查失败时停止，并不运行任何后续的检查；验证：将不会终止测试； 4、python 异常断言：Try…except… ，try…finally… ，Raise 抛出异常 异常的抛出机制： 如果在运行时发生异常，解释器会查找相应的处理语句（称为 handler）； 要是在当前函数里没有找到的话，它会将异常传递给上层的调用函数，看看那里能不能处理； 如果在最外层（全局“main”）还是没有找到的话，解释器就会退出，同时打印出 traceback 以便让用户找到错误产生的原因； 注意：虽然大多数错误会导致异常，但一个异常不一定代表错误，有时候它们只是一个警告，有时候它们可能是一个终止信号，比如退出循环等。 5、weddriver 错误截图 ：Webdriver 提供错误截图函数 get_screenshot_as_file()，可以帮助我们跟踪 bug，在脚本无法继续执行时候， get_screenshot_as_file()函数将截取当前页面的截图保存到指定位置； 6、自动化测试用例设计实例：（编写自动化测试用例的原则） 一个脚本是一个完整的场景，从用户登陆操作到用户退出系统关闭浏览器； 一个脚本脚本只验证一个功能点，不要试图用户登陆系统后把所有的功能都进行验证再退出系统； 尽量只做功能中正向逻辑的验证，不要考虑太多逆向逻辑的验证，逆向逻辑的情况很多（例如手机号输错有很多种情况），验证一方面比较复杂，需要编写大量的脚本，另一方面自动化脚本本身比较脆弱， 很多非正常的逻辑的验证能力不强。（我们尽量遵循用户正常使用原则编写脚本即可）； 脚本之间不要产生关联性，也就是说编写的每一个脚本都是独立的，不能依赖或影响其他脚本； 如果对数据进行了修改，需要对数据进行还原； 在整个脚本中只对验证点进行验证，不要对整个脚本每一步都做验证； 登陆用例实例： 备注：通过匹配用户登录之后的昵称来判断用户是否登录成功。 添加文件用例实例： 备注：通过计算用户列表中的文件的数量来判断文件是否添加成功； 删除文件用例实例： 备注：因为删除了一个文件对文件的数据发生的改变，如果多次执行脚本，列表中的文件被删除完了就会引发异常，所以在删除一个文件后，需要再添加一文件，但添加文件操作不做验证。 重命名文件用例实例 ： 备注：文件的重命名其实我们很难找到证据（验证点）证明重命名成功，那么脚本整个运行没有报错， 我们也可模糊的判断功能测试是 OK 的。 引入 unittest 单元测试框架1、selenium IDE 介绍：可以将 selenium IDE 录制的脚本转换成不同语言脚本，有助于帮助我们尽快熟悉脚本语言以及测试框架； 2、引入 unittest 框架： 12345678910#Baidu 类继承 unittest.TestCase 类，从 TestCase 类继承是告诉 unittest 模块的方式，这是一个测试案例class Baidu(unittest.TestCase):#setUp 用于设置初始化的部分，在测试用例执行前，这个方法中的函数将先被调用def setUp(self): self.driver = webdriver.Firefox() self.base_url = \"http://www.baidu.com/\"#tearDown 方法在每个测试方法执行后调用，这个地方做所有测试用例执行完成的清理工作，如退出浏览器等def tearDown(self): self.driver.quit() self.assertEqual([], self.verificationErrors) 利用 Command 和 Composite 设计模式，多个 TestCase 还可以组合成测试用例集合。 组织用例集：完整的单元测试很少只执行一个测试用例，开发人员通常都需要编写多个测试用例才能对某一软件功能进行比较完整的测试，这些相关的测试用例称为一个测试用例集，在 PyUnit 中是用 TestSuite 类来表示的。 12345def suite(): suite = unittest.TestSuite() suite.addTest(WidgetTestCase(\"testSize\")) suite.addTest(WidgetTestCase(\"testResize\")) return suite 如果用于测试的类中所有的测试方法都以 test 开头，Python 程序员甚至可以用 PyUnit 模块提供的 makeSuite()方法来构造一个。 123#TestSuite 类可以看成是 TestCase 类的一个容器，用来对多个测试用例进行组织，这样多个测试用例可以自动在一次测试中全部完成。def suite(): return unittest.makeSuite(WidgetTestCase, \"test\") 运行测试集 ：PyUnit 使用 TestRunner 类作为测试用例的基本执行环境，来驱动整个单元测试过程。Python开发人员在进行单元测试时一般不直接使用 TestRunner 类，而是使用其子类 TextTestRunner 来完成测试，并将测试结果以文本方式显示出来； 12runner = unittest.TextTestRunner()runner.run(suite) 由于引入 unittest 框架的作用，一条用例失败后不会影响下一条用例的执行。 引入测试报告与结构优化1、引入漂亮的 HTMLTestRunner 测试报告，HTMLTestRunner 是 Python 标准库的 unittest 模块的一个扩展。它生成易于使用的 HTML 测试报告。 HTMLTestRunner 是在 BSD 许可证下发布； 2、测试套件 ：通过测试套件组织的用例结构； makeSuite 用于生产 testsuite 对象的实例，把所有的测试用例组装成 TestSuite，最后把 TestSuite 传给 TestRunner 进行执行。 123#将测试用例加入到测试容器(套件)中testunit.addTest(unittest.makeSuite(baidu.Baidu))testunit.addTest(unittest.makeSuite(youdao.Youdao)) 3、discover 解决用例的读取： TestLoader：测试用例加载器，其包括多个加载测试用例的方法。返回一个测试套件。 discover(start_dir，pattern=’test*.py’，top_level_dir=None) start_dir ：要测试的模块名或测试用例目录； pattern=’test.py’ ：表示用例文件名的匹配原则。星号“”表示任意多个字符； top_level_dir=None：测试模块的顶层目录。如果没顶层目录（也就是说测试用例不是放在多级目录 中），默认为 None。 自动化测试高级应用1、自动发邮件功能、多线程和定时任务，让我们的自动化工作真正变得高效而又强大起来。 2、自动发邮件功能：python 的 smtplib 模块提供了一种很方便的途径发送电子邮件。它对 smtp 协议进行了简单的封装。 一般 smtp 会话有两种方式： 邮件直接投递； 验证过后的发信 ； 3、python 多进程/线程基础： 什么是进程？ 计算机程序只不过是磁盘中可执行的，二进制（或其它类型）的数据。它们只有在被读取到内存中， 被操作系统调用的时候才开始它们的生命期。进程（有时被称为重量级进程）是程序的一次执行。每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据。操作系统管理在其上运行的所有进程，并为这些进程公平地分配时间。 什么是线程？ 线程（有时被称为轻量级进程）跟进程有些相似，不同的是，所有的线程运行在同一个进程中，共享相同的运行环境。我们可以想像成是在主进程或“主线程”中并行运行的“迷你进程”。 4、定时任务：可以设置定时任务，使我们自动化脚本在某个时间点自动运行脚本。实现这个需求的方式很多； 程序控制时间执行； windows 添加任务计划 ； linux 实现定时任务：可以通过 at 命令实现一次性计划任务，也可以通过 batch 实现周期性计划任务； 通过 at 命令创建任务：at 命令主要用于创建临时的任务，创建的任务只能被执行一次；—at -l / atq 两个命令查看 at 创建的任务—删除已经设置的任务：atrm 用于删除已经创建的任务at 命令指定时间的方式：—绝对计时方法： midnight noon teatimehh:mm [today]hh:mm tomorrowhh:mm 星期hh:mm MM/DD/YY —相对计时方法： now+n minutesmow+n hours now+n days 通过 crontab 命令创建任务：crontab 可以方便的用来创建周期性任务，也许你想每天某个时间执行 python 程序，或每周五的某个时间执行。crontab 像 windows 的计划任务一样方便，或者更加灵活 ；—crontab - e 命令进入 crontab 文件；—按键盘 i、o、a 任意一个键进入编辑状态，可以对文件进行修改；—分钟 小时 天 月 星期 命令/脚本 15 * * * * python /home/fnngj/test/file_time.py —ctrl+x 离开，提示是否保存任务？按 y 保存任务退出。（不同版本 linux 对 crontab 文件的编辑/退出会有差异。）—完成 crontab 任务创建后，会有如下提示： crontab: installing new crontab ；—启动 crontab 服务：注意（在完成编辑以后，要重新启动 cron 进程，crontab 服务操作说明） cron restart //重启服务，cron start //启动服务，cron stop //关闭服务，cron reload //重新载入配置 ； selenium grid2 分布式执行测试用例1、Selenium Grid 允许用户将测试案例分布在几台机器上并行执行。用户可以在一个集中控制点控制不同的环境。在不同的浏览器 / 系统组合上面更为容易的运行测试案例。允许用户更多的利用虚拟资源减少了维护测试环境的成本； 2、selenium-server 支持接收远程脚本的调用命令； 行为驱动开发 BDD 框架 lettuce 入门1、lettuce 是一个非常有用的和迷人的 BDD（行为驱动开发）工具。Python项目的自动化测试，它可以执行纯文本的功能描述； lettuce，使开发和测试过程变得很容易，可扩展性，可读性和-什么是最好的-它允许我们用自然语言去描述个一个系统的行为，你不能想象这些描述可以自动测试你的系统。 Feature（功能）， Scenario（情景），Given（给定）， And（和）， When（当），Then（则）； 说明：前半部分转载虫师和这篇博文，后半部分内容和插图来源于 《selenium2 python自动化测试实战》。","comments":true,"tags":[{"name":"Python Selenium","slug":"Python-Selenium","permalink":"http://yoursite.com/tags/Python-Selenium/"}]}]